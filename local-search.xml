<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++ 值类别探究</title>
    <link href="/2023/08/25/cpp-value-categories/"/>
    <url>/2023/08/25/cpp-value-categories/</url>
    
    <content type="html"><![CDATA[<p>C++ 在演进过程中逐渐增强和拓展了对类型的处理能力。</p><p>由于表达式产生的中间结果会产生导致多余的拷贝，因而在 C++11 中引入了移动语义来解决这个问题，同时对值类别的左值、右值进行重新定义。需要注意的是，值类别指的是表达式结果的类别，并不是值对象、变量或者类型的类别。</p><p>对值类别的准确理解，是掌握移动语义的关键，能够帮我我们写出更优雅高效的代码，那么今天让我们一起来探究一下值类别。</p><h2 id="1-引用"><a href="#1-引用" class="headerlink" title="1. 引用"></a>1. 引用</h2><p>引用是 C 语言所没有的概念。而这个概念，比它表面看起来要复杂一些。</p><h3 id="1-1-值与对象"><a href="#1-1-值与对象" class="headerlink" title="1.1 值与对象"></a>1.1 值与对象</h3><p>为了理解引用，我们需要首先搞清楚什么叫<strong>左值</strong>与<strong>右值</strong> 。</p><p>简而言之，<strong>左值</strong>是一种<strong>对象</strong>，而不是<strong>值</strong>。其与右值的关键区别在于，是否明确在内存中有其可访问的位置。即，其是否存在一个可访问的地址。如果有，那么它就是一个<strong>对象</strong>，也就是一个<strong>左值</strong> ，否则，它就只是一个<strong>值</strong>，即<strong>右值</strong>。</p><p>比如：你不可能对整数 <code>10</code> 取地址，因而这个表达式是一个<strong>右值</strong>。但是如果你定义了一个变量：</p><p><code>int a = 10;</code></p><p>变量 <code>a</code> 则代表一个<strong>对象</strong>，即<strong>左值</strong>。如果我们再进一步，表达式 <code>a + 1</code> 则是一个<strong>右值表达式</strong>，因为你无法对这个表达式取地址。</p><p>任何可以取地址的表达式，背后都必然存在一个<strong>对象</strong>，因而也必然属于<strong>左值</strong>。而如果我们把对象地址看作其<strong>身份证</strong>（Identifier）， 那么我们也可以换句话说：任何有<strong>身份证</strong>的表达式，都属于<strong>左值</strong>；否则，肯定属于<strong>右值</strong>。</p><h3 id="1-2-别名"><a href="#1-2-别名" class="headerlink" title="1.2 别名"></a>1.2 别名</h3><p><strong>引用</strong>是<strong>对象</strong>的<strong>别名</strong>。</p><p>所谓<strong>别名</strong>，是指你没有创建任何<strong>新事物</strong>，而只是对<strong>已存在事物</strong>赋予了另外一个名字。比如：</p><p><code>using Int = int;</code></p><p>你并没有创建一个叫做 <code>Int</code> 的新类型，而只是对已存在类型 <code>int</code> 赋予了另外一个名字。再比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> ArrayType = Array&lt;T, <span class="hljs-number">10</span>&gt;;<br></code></pre></td></tr></table></figure><p>你并没有创建一个签名为 <code>ArrayType&lt;T&gt;</code> 的新模板，而只是对已存在模板 <code>Array&lt;T, N&gt;</code> 进行部分实例化后得到的模板，赋予了一个新名字。</p><p>因而，<strong>引用</strong>作为<strong>对象别名</strong>，并没有创建任何<strong>新对象</strong>（包括引用自身），而仅仅是给已存在对象赋予了一个新名字。</p><h3 id="1-3-空间大小"><a href="#1-3-空间大小" class="headerlink" title="1.3 空间大小"></a>1.3 空间大小</h3><p>正是因为其<strong>别名</strong>的含义，C++ 没有规定<strong>引用</strong>的尺寸（事实上，从<strong>别名</strong>语义的角度，它本身不需要内存，因而也就没有尺寸而言）。</p><p>因而，如果你试图通过 <code>sizeof</code> 去获取一个<strong>引用</strong>的大小，是不可能的。你只能得到它所引用的对象的大小（由于别名语义）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>    std::<span class="hljs-type">size_t</span> a;<br>    std::<span class="hljs-type">size_t</span> b;<br>&#125;;<br><br>Foo  foo;<br>Foo&amp; ref = foo;<br><br><span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(ref) == <span class="hljs-built_in">sizeof</span>(Foo));<br></code></pre></td></tr></table></figure><p>也正是由于其<strong>别名语义</strong>，当你试图对一个引用取地址时，你得到的是对象的地址。比如，在上面的例子中，<code>&amp;ref</code> 与 <code>&amp;foo</code> 得到的结果是一样的。</p><p>因而，当你定义一个指针时，指针自身就是一个<strong>对象</strong>（左值）；它本身有自己明确的存储，并可以取自己的地址，可以通过 <code>sizeof</code> 获取自己的尺寸。</p><p>但是<strong>引用</strong>，本身不是一个像指针那样的额外对象，而是一个对象的别名，<strong>你对引用进行的任何操作，都是其所绑定对象的操作</strong>。</p><p>在上面的例子中，<code>ref</code> 与 <code>foo</code> 没有任何差别，都是对象的一个名字而已。它们本身都代表一个对象，都是一个左值表达式。</p><p>因而，在不必要时，编译器完全不需要为引用分配任何内存。</p><p>但是，当你需要在一个数据结构中保存一个引用，或者需要传递一个引用时，你事实上是在存储或传递对象的<strong>身份</strong>（即地址）。</p><p>虽然这并不意味着 <code>sizeof(T&amp;)</code> 就是引用的大小（从语义上，引用自身非对象，因而无大小，<code>sizeof(T&amp;) == sizeof(T)</code>），但对象的地址的确需要对应的空间来存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bar</span> &#123;<br>    Foo&amp; foo;<br>&#125;;<br><br><span class="hljs-comment">// still, reference keeps its semantics.</span><br><span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(Bar::foo) == <span class="hljs-built_in">sizeof</span>(Foo));<br><br><span class="hljs-comment">// but its storage size is identical to a pointer</span><br><span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(Bar) == <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*));<br><br><span class="hljs-comment">// interesting!!!</span><br><span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(Bar) &lt; <span class="hljs-built_in">sizeof</span>(Bar::foo));<br></code></pre></td></tr></table></figure><h3 id="1-4-受限的指针"><a href="#1-4-受限的指针" class="headerlink" title="1.4 受限的指针"></a>1.4 受限的指针</h3><p>在传递或需要存储时，一个引用的事实空间开销与指针无异。因而，在这些场景下，它经常被看作一个受限的指针：</p><ol><li><p>一个引用必须初始化。这是因为其<strong>对象别名</strong>语义，因而没有<strong>绑定</strong>到任何对象的引用，从语义上就不成立。</p></li><li><p>由于必须通过初始化将引用绑定到某一个对象，因而从语义上，不存在<strong>空引用</strong>的概念。这样的语义，对于我们的接口设计，有着很好的帮助： 如果一个参数，从约束上就不可能是空，那么就不要使用指针，而使用引用。这不仅可以让被调用方避免不必要的空指针判断；更重要的是准确的约束表达。</p><p> 不过，需要特别注意的是：虽然<strong>空引用</strong>从概念上是不存在的，但从事实上是可构造的。比如：<code>T&amp; ref = *(T*)nullptr</code>。</p><p> 因而，在项目中，任何时候，需要从指针转为引用时，都需要确保指针的非空性。</p><p> 另外，<strong>空引用</strong>本身这个概念就是不符合语义的，因为引用只是一个对象的别名。上面的表达式，事实上站在对象角度同样可以构造：<code>T obj = *(T*)nullptr</code> 。正如我们将指针所指向的对象赋值（或者初始化）给另一个对象一样，我们都必须确保指针的非空性。</p></li><li><p>像所有的左值一样，引用可以绑定到一个抽象类型，或者不完备类型（而右值是不可能的）。从这一点上，指针和引用具有相同的性质。因而，在传递参数时，决定使用指针，还是引用，仅仅受是否允许为空的设计约束。</p></li><li><p>一个引用不可能从一个对象，绑定到<strong>另外</strong>一个对象。原因很简单，依然由于其<strong>对象别名</strong>语义。它本身就代表它所绑定的对象，重新绑定另外一个对象，从概念上不通。</p></li></ol><p>而引用的<strong>不可更换性</strong>，导致任何存在引用类型非静态成员的对象，都不可能直接实现<strong>拷贝&#x2F;移动赋值</strong>函数。因而，标准库中，需要存储数据的，比如<strong>容器</strong>，<code>tuple</code>、<code>pair</code>、<code>optional</code> 等等结构，都不允许存储<strong>引用</strong>。</p><p>这就会导致，当一个对象需要选择是通过<strong>指针</strong>还是<strong>引用</strong>来作为数据成员时，除了<strong>非空性</strong>之外，相对于参数传递，还多了一个约束：<strong>可修改性</strong>。而这两个约束并不必然是一致的，甚至可以是冲突的。</p><p>比如，一个类的设计约束是，它必须引用另外一个对象（非空性），但是随后可以修改为引用另外一个对象。这种情况下， 使用指针就是唯一的选择。但代价是，必须通过其它手段来保证<strong>非空性</strong>约束。</p><h3 id="1-5-左值"><a href="#1-5-左值" class="headerlink" title="1.5 左值"></a>1.5 左值</h3><p>任何一个引用类型的<strong>变量</strong>，都必然是其所绑定<strong>对象</strong>的<strong>别名</strong>，因而都必然是<strong>左值</strong>。无论这个引用类型是<strong>左值引用</strong>，还是<strong>右值引用</strong>。关于这个话题，我们会在后续章节继续讨论。</p><div class="note note-info">            <p><strong>重要</strong></p><ol><li>引用是对象的别名，对于引用的一切操作都是对对象的操作；</li><li>引用自身从概念上没有大小（或者就是对象的大小）；但引用在传递或需要存储时，其传递或存储的大小为地址的大小。</li><li>引用必须初始化；</li><li>引用不可能重新绑定；</li><li>将指针所指向的对象绑定到一个引用时，需要确保指针非空。</li><li>任何引用类型的变量，都是左值。</li></ol>          </div><h2 id="2-右值引用"><a href="#2-右值引用" class="headerlink" title="2. 右值引用"></a>2. 右值引用</h2><h3 id="2-1-缺失的拼图"><a href="#2-1-缺失的拼图" class="headerlink" title="2.1 缺失的拼图"></a>2.1 缺失的拼图</h3><p>在 C++11 之前，表达式分类为<strong>左值表达式</strong>和<strong>右值表达式</strong>，简称<strong>左值</strong>和<strong>右值</strong>。<strong>左值</strong>都对应着一个明确的对象；从而也都必然可以通过 <code>&amp;</code> 进行取地址操作。而<strong>右值</strong>表达式虽然肯定都不能进行取地址操作，但在有些场景下，也会隐含着创建一个<strong>临时对象</strong>的语义。</p><p>比如 <code>Foo(10)</code>，在 C++98 的年代，其语义是：以 <code>10</code> 来构造一个 <code>Foo</code> 类型的临时对象。而这个表达式属于<strong>右值</strong>。</p><p>而引用，从常量性的角度，可以分为：<strong>非常引用</strong>和<strong>常引用</strong>。</p><p>因而，<strong>常量</strong>和<strong>引用</strong>的<strong>对象类别</strong>组合在一起，一共能产生四种类型的引用：</p><ol><li><strong>常左值引用</strong></li><li><strong>非常左值引用</strong></li><li><strong>常右值引用</strong></li><li><strong>非常右值引用</strong></li></ol><p>在 C++11 之前，通过符合 <code>&amp;</code> 和 <code>const</code> 的两种组合，可以覆盖三种场景：</p><ol><li><p><code>Foo&amp;</code></p><ul><li><strong>非常左值引用</strong><br> 比如：<code>Foo foo(10); Foo&amp; ref = foo;</code></li></ul></li><li><p><code>const Foo&amp;</code></p><ul><li><strong>常左值引用</strong><br>比如：<code>Foo foo(10); const Foo&amp; ref = foo;</code></li><li><strong>常右值引用</strong><br>比如：<code>const Foo&amp; ref = Foo(10);</code></li></ul></li></ol><p>但对于<strong>非常右值引用</strong>无法表达。</p><p>好在那时候并没有移动语义的支持，因而对于<strong>非常右值引用</strong>的需求也并不强烈。</p><h3 id="2-2-移动语义"><a href="#2-2-移动语义" class="headerlink" title="2.2 移动语义"></a>2.2 移动语义</h3><p>C++11 之前，只有复制语义，这对于极度关注性能的语言而言是一个重大的缺失。那时候程序员为了避免性能损失，只好采取规避的方式。比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str = s1;<br>s += s2;<br></code></pre></td></tr></table></figure><p>这种写法就可以规避不必要的拷贝。而更加直观的写法：</p><p><code>std::string str = s1 + s2;</code></p><p>则必须忍受一个 <code>s1 + s2</code> 所导致的中间<strong>临时对象</strong>到 <code>str</code> 的拷贝开销。 即便那个中间临时对象随着表达式的结束，会被销毁（更糟的是，销毁所伴随的资源释放，也是一种性能开销）。</p><p>对于移动语义的急迫需求，到了 C++11 终于被引入。其直接的驱动力很简单：在构造或者赋值时，如果等号右侧是一个中间临时对象，应直接将其占用的资源直接移动过来（对方就没有了）。</p><p>但问题是，如何让一个构造函数，或者赋值操作重载函数能够识别出来这是一个临时变量？</p><p>在 C++11 之前，拷贝构造和赋值重载的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">const</span> Foo&amp;);<br>    Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo&amp;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>参数类型都是 <code>const &amp;</code>，它可以匹配到三种情况：</p><ol><li><strong>非常左值引用</strong></li><li><strong>常左值引用</strong></li><li><strong>常右值引用</strong></li></ol><p>对于<strong>非常右值引用</strong>是无能为力的。另外，即便是能捕捉<strong>非常右值引用</strong>，比如：<code>foo = Foo(10)</code>; ，但其 <code>const</code> 修饰也保证了其资源不可能被移动走。</p><p>因而，能够被移动走资源的，恰恰是之前缺失的那种引用类型：<strong>非常右值引用</strong>。</p><p>这时候，就需要有一种表示法，明确识别出那是一种<strong>非常右值引用</strong>，最后定下来的表示法是 <code>T&amp;&amp;</code> 。这样，就可以这样来定义不同方式的构造和赋值操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">const</span> Foo&amp;); <span class="hljs-comment">// 拷贝构造</span><br>    <span class="hljs-built_in">Foo</span>(Foo&amp;&amp;);      <span class="hljs-comment">// 移动构造</span><br>    Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo&amp;); <span class="hljs-comment">// 拷贝赋值</span><br>    Foo&amp; <span class="hljs-keyword">operator</span>=(Foo&amp;&amp;);      <span class="hljs-comment">// 移动赋值</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>通过这样的方式，让 <code>Foo foo = Foo(10)</code> 或 <code>foo = Foo(10)</code> 这样的表达式，都可以匹配到移动语义的版本。与此同时，让 <code>Foo foo = foo1</code> 或 <code>foo = foo1</code> 这样的表达式，依然使用复制语义的版本。</p><h3 id="2-3-右值引用变量"><a href="#2-3-右值引用变量" class="headerlink" title="2.3 右值引用变量"></a>2.3 右值引用变量</h3><p>引入了<strong>右值引用</strong>之后，就有一系列的问题需要明确。</p><p>首先，在不存在重载的情况下：</p><ol><li><strong>左值</strong>是否可以匹配到<strong>右值引用类型参数</strong>？ 比如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">non_copyable</span> &#123;<br>    <span class="hljs-built_in">non_copyable</span>(non_copyable&amp;&amp;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>答案显然是 <strong>NO</strong>，否则，一个左值就会被移动构造函数将其资源偷走，而这很明显不是我们所期望的；</p><ol start="2"><li><strong>右值</strong>是否可以匹配到<strong>左值引用类型参数</strong>？比如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">non_movable</span> &#123;<br>    <span class="hljs-built_in">non_movable</span>(<span class="hljs-type">const</span> non_movable&amp;);<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">non_movable2</span> &#123;<br>    <span class="hljs-built_in">non_movable2</span>(non_movable&amp;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>答案是看情况。</p><ul><li>至少在 C++11 之前，一个右值，就可以被类型为 <code>const T&amp;</code> 类型的参数匹配；</li><li>但一个右值，不能被 <code>T&amp;</code> 类型的参数匹配；毕竟这种可以修改的承诺。而修改一个调用后即消失的<strong>临时对象</strong>上，没有任何意义，反而会导致程序员犯下潜在的错误，因而还是禁止了最好。</li></ul><p>这就遗留下来一种情况：</p><ol><li><p>一个<strong>非常右值引用</strong> 类型的变量，是否允许匹配<strong>非常左值引用</strong>类型的参数？</p><p> 比如：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Foo&amp; foo)</span> </span>&#123; foo.a *= <span class="hljs-number">10</span>; &#125;<br>Foo&amp;&amp; ref = Foo&#123;<span class="hljs-number">10</span>&#125;;<br><span class="hljs-built_in">f</span>(ref); <span class="hljs-comment">// 是否允许</span><br><span class="hljs-type">int</span> b = ref.a + <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>没有任何理由不允许这样的匹配。毕竟，自从变量 <code>ref</code> 被初始化后，其性质上和<strong>左值引用</strong>一样，都是引用了一个已经存在的对象。 例子中，经过 <code>f(ref)</code> 对 <code>ref</code> 所引用的对象内容进行修改之后，还会基于其内容进行进一步的处理。这都是非常合理的需求。 并且，<code>ref</code> 所引用的对象的生命周期，和 <code>ref</code> 一样长，不用担心在使用 <code>ref</code> 期间，对象已经不存在的问题。</p><p>这就导致了一个看起来很矛盾的现象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Foo&amp; foo)</span> </span>&#123; foo.a *= <span class="hljs-number">10</span>; &#125;<br><br>Foo&amp;&amp; ref = Foo&#123;<span class="hljs-number">10</span>&#125;;<br><span class="hljs-built_in">f</span>(ref);     <span class="hljs-comment">// OK</span><br><br><span class="hljs-built_in">f</span>(Foo&#123;<span class="hljs-number">10</span>&#125;); <span class="hljs-comment">// 不允许</span><br></code></pre></td></tr></table></figure><p>先将一个<strong>临时对象</strong>初始化给一个<strong>右值引用</strong>，再传递给函数 <code>f</code> ，与直接构造一个<strong>临时对象</strong>传递给 <code>f</code> ，一个是允许的，一个是禁止的。</p><p>这背后的差异究竟意味这什么？</p><p>一个类型为<strong>右值引用</strong>的变量，一旦被初始化之后，临时对象的生命将被扩展，会在其被创建的作用域内始终有效。因而，<code>Foo&amp;&amp; foo = Foo&#123;10&#125;</code>，从语义上相当于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>    Foo __temp_obj&#123;<span class="hljs-number">10</span>&#125;;<br>    Foo&amp; ref = __temp_obj;<br>    <span class="hljs-comment">// 各种对 ref 的操作</span><br>&#125;<br><span class="hljs-comment">// 离开作用域，__temp_obj 被销毁</span><br></code></pre></td></tr></table></figure><p>因而，看似 <code>foo</code> 被定义的类型为<strong>右值引用</strong>，但这<strong>仅仅约束它的初始化</strong>：只能从一个<strong>右值</strong>进行初始化。但一旦初始化完成，它就和一个<strong>左值引用</strong>再也没有任何差别：都是一个已存在对象的<strong>标识</strong>。</p><p>函数参数也没有任何特别之处，它就是一个普通的变量。无非是其可访问范围被限定在函数内部。调用一个函数时，传递实参的过程，就是一个对参数（变量）进行初始化的过程，而初始化的细节与一个普通变量没有任何差别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stupid</span><span class="hljs-params">(Foo&amp;&amp; foo)</span> </span>&#123;<br>    foo.a += <span class="hljs-number">10</span>;   <span class="hljs-comment">// 在函数体内，foo的性质与一个左值引用毫无差别</span><br>    <span class="hljs-comment">// blah ...</span><br>&#125;<br><span class="hljs-built_in">stupid</span>(Foo&#123;<span class="hljs-number">10</span>&#125;);  <span class="hljs-comment">// 在执行函数体之前，进行参数初始化: Foo&amp;&amp; foo = Foo&#123;10&#125;</span><br></code></pre></td></tr></table></figure><p>而临时对象 <code>Foo&#123;10&#125;</code> 的生命周期，会比参数变量 <code>foo</code> 更长。所以将 <code>foo</code> 看作<strong>左值引用</strong>随意访问，是没有任何风险的。</p><p>所以，任何一个类型为<strong>右值引用</strong>的变量，一旦初始化完成，性质上就变成和一个<strong>左值引用</strong>毫无差别。这样的语义，对于程序员的使用是最为合理的。</p><p>我们再看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string&amp;&amp; ref = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>std::string   obj = ref; <span class="hljs-comment">// 移动? 还是 拷贝?</span><br>std::string   s   = ref + <span class="hljs-string">&quot;cde&quot;</span>; <span class="hljs-comment">// 是否可以接着假设 ref 所引用的对象是合法的？</span><br></code></pre></td></tr></table></figure><p>既然在完成初始化之后，一个<strong>右值引用类型</strong>的变量，就变成了<strong>左值引用</strong>，按照这个语义，当然就只能选择<strong>拷贝构造</strong>。这样的选择，也让后面对于 <code>ref</code> 的继续使用是安全合理的， 这其实也在帮助程序员编写安全的代码。</p><p>毕竟，只有在调用移动构造函数那一刻，传入的是真正的临时变量，也就是说移动构造函数调用结束后，临时变量也就不再存在，无从访问的情况下，自动选择移动构造函数才是确定安全的。</p><p>经过之前讨论，我们知道这样的设计决策是最合理的，但矛盾和张力依然存在：毕竟，变量 <code>ref</code> 的类型是<strong>右值引用</strong>，而移动构造函数的参数类型也是<strong>右值引用</strong>，为什么它们不是最匹配的，反而是匹配了拷贝构造函数？另外，移动构造函数自动匹配真正的临时对象，毫无疑问是合理的（也是我们的初衷），但我们如何区分一个临时对象和一个类型为<strong>右值引用</strong>的变量？</p><p>这个并不难。因为 C++ 早就规定了，产生临时变量的表达式是<strong>右值</strong>，而任何变量都是一个对象的标识，因而都是<strong>左值</strong>，哪怕变量类型是<strong>右值引用</strong>。</p><p>因而，<strong>右值</strong>选择移动构造函数，<strong>左值</strong>选择拷贝构造函数。</p><p>更准确的说，所谓选择移动构造函数，其实是因为<strong>右值</strong>匹配的是移动构造函数参数，其类型是一个<strong>右值引用</strong>。我们知道，函数参数也是变量，而一个类型为<strong>右值引用</strong>的变量，只能由<strong>右值</strong>来初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Foo   foo &#123;<span class="hljs-number">10</span>&#125;;<br>Foo&amp;&amp; ref  = foo; <span class="hljs-comment">// 不合法，右值引用只能由右值初始化</span><br><br>Foo&amp;&amp; ref1 = Foo&#123;<span class="hljs-number">10</span>&#125;;<br>Foo&amp;&amp; ref2 = ref1; <span class="hljs-comment">// 不合法，ref1是个左值</span><br></code></pre></td></tr></table></figure><p>因而，作为类型为<strong>右值引用</strong>的函数参数，唯一能匹配的就是<strong>右值</strong>。这也是移动构造函数能精确识别临时变量的原因。</p><div class="note note-info">            <p><strong>重要</strong></p><ol><li>对于任何类型为<strong>右值引用</strong>的变量（当然也包括函数参数），只能由<strong>右值</strong>来初始化；</li><li>一旦初始化完成，<strong>右值引用</strong>类型的变量，其性质与一个<strong>左值引用</strong>再也没有任何差别。</li></ol>          </div><h3 id="2-4-将亡值"><a href="#2-4-将亡值" class="headerlink" title="2.4 将亡值"></a>2.4 将亡值</h3><p>我们现在已经明确了，只有右值临时对象可以初始化右值引用变量，从而也只有右值临时变量能够匹配参数类型为<strong>右值引用</strong>的函数，包括移动构造函数。</p><p>这中间依然有一个重要的缺口：如果程序员就是想把一个左值移动给另外一个对象，该怎么办？</p><p>最简单的选择是通过 <code>static_cast</code> 进行类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Foo   foo &#123;<span class="hljs-number">10</span>&#125;;<br>Foo&amp;&amp; ref  = Foo&#123;<span class="hljs-number">10</span>&#125;;<br>Foo   obj1 = <span class="hljs-built_in">static_cast</span>&lt;Foo&amp;&amp;&gt;(foo); <span class="hljs-comment">// 移动构造</span><br>Foo   obj2 = <span class="hljs-built_in">static_cast</span>&lt;Foo&amp;&amp;&gt;(ref); <span class="hljs-comment">// 移动构造</span><br></code></pre></td></tr></table></figure><p>我们之前说过，只有<strong>右值</strong>，才可以用来初始化一个<strong>右值引用</strong>类型的变量，因而也只有<strong>右值</strong>才能匹配移动构造。所以，<code>static_cast&lt;Foo&amp;&amp;&gt;(foo)</code>表达式，肯定是一个<strong>右值</strong>。</p><p>但同时，它返回的类型又非常明确的是一个<strong>引用</strong>，而这一点又不符合<strong>右值</strong>的定义。因为，所有的右值，都必须是一个<strong>具体类型</strong>，不能是不完备类型，也不能是抽象类型，但<strong>引用</strong>，无论左值引用，还是右值引用，都可以是不完备类型的引用或抽象类型的引用。这是<strong>左值</strong>才有的特征。</p><p>对于这种既有左值特征，又和右值临时对象一样，可以用来初始化右值引用类型的变量的表达式，只能将其归为新的类别。C++11 给这个新类别命名为<strong>将亡值</strong>(eXpiring value，简称 xvalue)。 而将原来的<strong>右值</strong>，重新命名为<strong>纯右值</strong>。而<strong>将亡值</strong>和<strong>纯右值</strong>合在一起，称为<strong>右值</strong>，其代表的含义是，所有可以直接用来初始化<strong>右值引用类型变量</strong>的表达式。</p><p>同时，由于<strong>将亡值</strong>又具备左值特征：可以是不完备类型，可以是抽象类型，可以进行运行时多态。所以，<strong>将亡值</strong>又和<strong>左值</strong>一起被归类为<strong>泛左值</strong>（generalized lvalue, 简称 glvalue）。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/images/cpp-value-categories/value-category-2.png" alt=" "></div><div class="group-image-wrap"><img src="/images/cpp-value-categories/value-category.png" alt=" "></div></div></div><p>除了 <code>static_cast&lt;T&amp;&amp;&gt;(expr)</code> 这样的表达式之外，任何返回值为<strong>右值引用</strong>类型的函数调用表达式也属于<strong>将亡值</strong>。 从而让用户可以实现任意复杂的逻辑，然后通过返回值为<strong>右值引用</strong>的方式，直接初始化一个右值引用类型的变量。 以此来达到匹配移动构造，移动赋值函数，以及任何其它参数类型为<strong>右值引用</strong>的函数的目的。</p><p>C++ 标准对其的定义为：</p><blockquote><p><strong>xvalue</strong>:<br>an xvalue (an “eXpiring” value) is a glvalue that denotes an object or bit-field whose resources can be reused.</p></blockquote><p>意思就是，这类表达式表明了自己可以被赋值给一个类型为<strong>右值引用</strong>的变量，当然自然也就可以被移动构造和移动赋值操作自然匹配，从而返回的引用所引用的对象可以通过移动而被重用。</p><p>所以，将亡值未必真的会将亡（expiring），它只是能用来初始化右值引用类型的变量而已。只有用到移动场景下，它才会真的导致所引用对象的失效。</p><p>最后，将亡表达式存在着一个异常场景，那就是函数类型的右值引用。因为函数地址被移动本身毫无意义。所以，对于返回值为<strong>函数类型右值引用</strong>的函数调用，或者 <code>static_cast&lt;FunctionType&amp;&amp;&gt;(expr)</code> 的表达式，其类别为<strong>左值</strong>，而不是<strong>将亡值</strong>。</p><div class="note note-info">            <p><strong>重要</strong></p><ul><li>类型为<strong>右值引用</strong>的变量，只能由<strong>右值</strong>表达式初始化；</li><li><strong>右值</strong>包括<strong>纯右值</strong>和<strong>将亡值</strong>，其中<strong>将亡值</strong>的类型是<strong>右值引用</strong>；</li><li>类型为<strong>右值引用</strong>的变量，是一个<strong>左值</strong>，因而不能赋值给其它类型为<strong>右值引用</strong>的变量， 当然也不能匹配参数类型为<strong>右值引用</strong>的函数。</li></ul>          </div><h2 id="3-值与对象"><a href="#3-值与对象" class="headerlink" title="3. 值与对象"></a>3. 值与对象</h2><p>在理解现代 C++ 的各种令人眼花缭乱的特性之前，必须先搞清楚两个基本概念：<strong>值</strong>（ value ）与<strong>对象</strong>（ object ）。这是理解很多特性的基础。</p><h3 id="3-1-值"><a href="#3-1-值" class="headerlink" title="3.1 值"></a>3.1 值</h3><p>简单说，<strong>值</strong>是一个纯粹的数学抽象概念，比如数字 <code>10</code> ，或者字符 <code>&#39;a&#39;</code> , 或者布尔值 <code>false</code>，等等。它们完全不需要依赖于计算机或者内存而存在，就只是一个纯粹的值：不需要存储到内存，当然也就不可修改。注意，这与存储在内存中，但不可变完全不是一个语义。</p><p>那么 <code>1+2</code> 呢？这是一个表达式，但这个表达式的求值结果也是一个<strong>值</strong>。因而，这是一个值类别的表达式。而数字 <code>10</code> 同样是一个表达式，其求值的结果毫无疑问也是一个<strong>值</strong>——它自身。因而，在这个角度，<code>1+2</code> 和数字 <code>10</code>，从性质上没有任何区别，都是<strong>值</strong>类别的表达式。</p><h3 id="3-2-对象"><a href="#3-2-对象" class="headerlink" title="3.2 对象"></a>3.2 对象</h3><p><strong>对象</strong>是一个在内存中占据了一定空间的有类型的东西。因而，它必然是与计算机内存这个物理上具体存在的设备关联在一起的一个物质。</p><p>因而，每一个对象都必然有一个<strong>标识</strong>（Identifier），从而你可以知道这个对象在内存中唯一的起始位置。否则，对象是一个与内存关联在一起的物质就无从谈起。</p><p>所以 <code>int i</code> 就定义了一个对象，系统必然会在内存中为其分配一段 <code>sizeof(int)</code> 大小的空间，而 <code>i</code> 就是这个对象的标识。</p><p>既然对象与内存有关联，并且有自己区别于其它对象的唯一起始内存地址，那么任何对象都必然可以被引用。引用作为一个对象的别名，当然也是对象的一种<strong>标识</strong>。</p><p>所以，区分<strong>对象</strong>和<strong>值</strong>的方法非常简单：是否有<strong>标识</strong>，或可否被<strong>引用</strong>（毕竟引用就是一种标识）。只有作为具体内存物质的对象才可能被引用；而值，作为一种抽象概念，引用无从谈起。</p><h3 id="3-3-值与对象的关系"><a href="#3-3-值与对象的关系" class="headerlink" title="3.3 值与对象的关系"></a>3.3 值与对象的关系</h3><p>那么<strong>值</strong>和<strong>对象</strong>之间是什么关系？</p><p>很简单，<strong>值</strong>用来初始化<strong>对象</strong>。比如：<code>bool b = true</code>，其语义是：用值 <code>true</code> 初始化对象 <code>b</code>；类似的，<code>int i = 1 + 2</code> 表示用值 <code>1+2</code> 的计算结果值，初始化对象 <code>i</code>。<strong>对象</strong>表示内存中的一段有类型的空间，<strong>值</strong>这则是个空间里的内容。用<strong>值</strong>来初始化<strong>对象</strong>的过程，是一个将值加载到空间的隐喻。</p><h3 id="3-4-纯右值"><a href="#3-4-纯右值" class="headerlink" title="3.4 纯右值"></a>3.4 纯右值</h3><p>所有的<strong>值</strong>语义的表达式，都归类为<strong>纯右值</strong>（pure right value，简称 prvalue）。在 C++11 之前，它们被称做<strong>右值</strong>。</p><p>规范对于纯右值的定义如下：</p><blockquote><p>A prvalue is an expression whose evaluation initializes an object or a bit-field, or computes the value of an operand of an operator, as specified by the context in which it appears, or an expression that has type cv void.</p></blockquote><p>其存在的唯一的目的，是为了初始化<strong>对象</strong>。单独写一个<strong>纯右值</strong>表达式的语句，比如：<code>1+2;</code>，或者 <code>true &amp;&amp; (1 == 2);</code>，这样的表达式被称做<strong>弃值表达式</strong>。从语义上，它们仍然会初始化一个临时对象，而临时对象也是泛左值。后面我们会进行解释。</p><p>而既然是一个<strong>值</strong>，就必须是某种具体类型的值，而不可能是某种<strong>不完备类型</strong>。当然也不可能是一个<strong>抽象类型</strong>（包含有纯虚函数的类）的值，即便其基类是某种抽象类型，但它自身必然是一个具体类型，因而对其任何虚函数的调用，都是对其具体类型所对应的函数实现的调用。</p><p>同时，你不可能对一个值进行取地址操作（语义上就不通），也不可能引用它。</p><h3 id="3-5-泛左值"><a href="#3-5-泛左值" class="headerlink" title="3.5 泛左值"></a>3.5 泛左值</h3><p>与<strong>纯右值</strong>对应的是<strong>泛左值</strong>（glvalue）。整个表达式的世界被分为这两大类别。前者全部是<strong>值</strong>语义，后者全部是<strong>对象</strong>语义。</p><p>规范对于泛左值的定义如下：</p><blockquote><p>A glvalue is an expression whose evaluation determines the identity of an object, bit-field, or function.</p></blockquote><p>从这个定义我们可以看出，泛左值表达式的求值结果是一个对象的标识。</p><p><img src="/images/cpp-value-categories/value-category-3.png" alt=" "></p><h4 id="3-5-1-左值"><a href="#3-5-1-左值" class="headerlink" title="3.5.1 左值"></a>3.5.1 左值</h4><p>左值很容易辨别：任何可以对其通过符号 <code>&amp;</code> 取地址的表达式，都属于<strong>左值</strong>。因而，任何变量（包括常量），无论是全局的，还是类成员的，还是函数参数，还是函数名字，都肯定属于左值。</p><p>另外，所有返回值是左值引用的函数调用表达式（包括用户自定义的重载操作符），以及 <code>static_cast&lt;T&amp;&gt;(expr)</code> 都必然也属于左值。毕竟，没有内存中的对象，哪里来的引用？而引用无非是对象的一个别名标识罢了。</p><p>剩下的就是系统的一些内建操作符的定义，比如对一个指针求引用操作：<code>*p</code> ，或者 <code>++i</code> （ <code>i++</code> 却是一个<strong>右值</strong>）。</p><p>其中，最为特殊的是字符串字面常量，比如： <code>&quot;abcd&quot;</code> ，这是一个左值对象。这有点违背直觉，但由于 C&#x2F;C++ 中字符串并不是一个内建基本类型。这些字符串字面常量都会在内存中得以存储。</p><p>需要注意的是，这两种情况下，无论是变量 <code>i</code>，还是函数参数 <code>r</code>，它们都是一个<strong>左值</strong>，虽然它们的类型是<strong>右值引用</strong>。我们之前谈到过，任何变量，无论其属于什么类型，都必然是一个左值。变量的名字，就是对应对象的标识。</p><h4 id="3-5-2-将亡值"><a href="#3-5-2-将亡值" class="headerlink" title="3.5.2 将亡值"></a>3.5.2 将亡值</h4><p>将亡值是所有返回类型为<strong>右值引用</strong>的非左值表达式。 这包括返回值类型为<strong>右值引用</strong>的函数调用表达式，<code>static_cast&lt;T&amp;&amp;&gt;(expr)</code> 表达式。</p><p>其所引用的对象，从理论上同样也是可以取其地址的。其目的是为了初始化类型为<strong>右值引用</strong>类型的变量。借此，也可以匹配参数类型为右值引用的函数。一旦允许取其地址，程序的其它部分将无从判断，一个地址来自于将亡值对象，还是来自于左值对象，从而让将亡值的存在失去了本来的意义。因而，对其取地址操作被强行禁止。</p><p>与右值引用和将亡值有关的详细讨论，请参考：<strong>右值引用</strong>。</p><h4 id="3-5-3-对象？值？"><a href="#3-5-3-对象？值？" class="headerlink" title="3.5.3 对象？值？"></a>3.5.3 对象？值？</h4><p>上面给的那些与值有关的例子，简单而直观，不难理解它们是数学意义上的值。我们来看一个不那么直观的例子：在 <code>Foo</code> 是一个类的情况下，<code>Foo&#123;10&#125;</code> 是一个对象还是一个值？</p><p>在 C++17 之前，这个表达式的语义是一个<strong>临时对象</strong>。</p><p>非常有说服力的例子是： <code>Foo&amp;&amp; foo = Foo&#123;10&#125;</code> 或者 <code>const Foo&amp; foo = Foo&#123;10&#125;</code>。这这两个初始化表达式里，毫无疑问 <code>Foo&#123;10&#125;</code> 是一个对象，因为它可以被引用，无论是一个右值引用 <code>Foo&amp;&amp;</code>，还是一个左值引用 <code>const Foo&amp;</code>，能被引用的必然是<strong>对象</strong>。</p><p>但后来人们发现，将其定义为对象语义，在一些场景下会带来不必要的麻烦：</p><p>比如：<code>Foo foo = Foo&#123;10&#125;</code> 的语义是：构造一个临时对象，然后拷贝&#x2F;移动给左边的对象 <code>foo</code> 。</p><p>注意，只要 <code>Foo&#123;10&#125;</code> 被定义为<strong>对象</strong>，那么拷贝&#x2F;移动语义也就变得不可避免，这就要求类 <code>Foo</code> 必须要隐式或显式的提供公有的拷贝&#x2F;移动构造函数。即便编译器肯定会将对拷贝&#x2F;移动构造函数的调用给优化掉，但这是到优化阶段的事，而语义检查发生在优化之前。如果类 <code>Foo</code> 没有公有的拷贝&#x2F;移动构造函数，语义检查阶段就会失败。</p><p>这就给一些设计带来了麻烦，比如，程序员不希望类 <code>Foo</code> 可以被拷贝&#x2F;移动 ，所有 <code>Foo</code> 实例的创建都必须通过一个工厂函数，比如：<code>Foo makeFoo()</code> 来创建；并且程序员也知道拷贝&#x2F;移动构造函数的调用必然会被任何像样的编译器给优化掉，但就是过不了那该死的对实际运行毫无影响的语义检查那一关。</p><p>于是，到了 C++17，对于类似于 <code>Foo&#123;10&#125;</code> 表达式的语义进行了重新定义，它们不再是一个<strong>对象</strong>语义，而只是一个<strong>值</strong>。即 <code>Foo&#123;10&#125;</code> 与内存临时对象再无任何关系，它就是一个<strong>值</strong>：其估值结果，是对构造函数 <code>Foo(int)</code> 进行调用所产生的<strong>值</strong>。而这个<strong>值</strong>，通过等号表达式，赋值给左边的<strong>对象</strong>，正如 <code>int i = 10</code> 所做的那样。从语义上，不再有对象间的拷贝&#x2F;移动，而是直接将构造函数调用表达式作用于等号左边的<strong>对象</strong>，从而完成用<strong>值</strong>初始化<strong>对象</strong>的过程。因而，<code>Foo foo = Foo&#123;10&#125;</code>，与 <code>Foo foo&#123;10&#125;</code>，在 C++17 之后，从语义上（而不是编译器优化上）完全等价。</p><p>一旦将其当作<strong>值</strong>语义，很多表达式的理解上也不再一样。比如：<code>Foo foo = Foo&#123;Foo&#123;Foo&#123;10&#125;&#125;&#125;</code>，如果 <code>Foo foo = Foo&#123;10&#125;</code> 与 <code>Foo foo&#123;10&#125;</code> 完全等价，那么就可以进行下列等价转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    Foo foo = Foo&#123;Foo&#123;Foo&#123;<span class="hljs-number">10</span>&#125;&#125;&#125;<br>&lt;=&gt; Foo foo&#123;Foo&#123;Foo&#123;<span class="hljs-number">10</span>&#125;&#125;&#125;<br>&lt;=&gt; Foo foo = Foo&#123;Foo&#123;<span class="hljs-number">10</span>&#125;&#125;<br>&lt;=&gt; Foo Foo&#123;Foo&#123;<span class="hljs-number">10</span>&#125;&#125;<br>&lt;=&gt; Foo foo = Foo&#123;<span class="hljs-number">10</span>&#125;<br>&lt;=&gt; Foo foo&#123;<span class="hljs-number">10</span>&#125;<br></code></pre></td></tr></table></figure><p>注意，这是一个自然的语义推论，而不是编译器优化的结果。</p><p>自然，对于 <code>Foo makeFoo()</code> 这样的函数，其调用表达式 <code>makeFoo()</code>，在 C++17 下也是<strong>值</strong>。而不像之前定义的那样：返回一个临时对象，然后在 <code>Foo foo = makeFoo()</code> 表示式里，拷贝&#x2F;移动给等号左侧的对象 <code>Foo</code>。虽然 C&#x2F;C++ 编译器很早就有 RVO&#x2F;NRVO 优化技术；但同样，那是优化阶段的事，而不是语义分析阶段如何理解这个表达式语义的问题。</p><h4 id="3-5-4-临时量实质化"><a href="#3-5-4-临时量实质化" class="headerlink" title="3.5.4 临时量实质化"></a>3.5.4 临时量实质化</h4><p>我们再回到前面的问题：<code>Foo&amp;&amp; foo = Foo&#123;10&#125;</code> 表达了什么语义？毕竟，按照我们之前的讨论，等号右边是一个<strong>值</strong>，而左边是一个对于对象的<strong>引用</strong>。而<strong>引用</strong>只能引用一个对象，引用一个<strong>值</strong>是逻辑上是讲不通的。</p><p>这中间隐含着一个过程：<strong>临时量实质化</strong>。即将一个<strong>纯右值</strong>，赋值给一个<strong>临时对象</strong>，其标识是一个无名字的<strong>右值引用</strong>，即<strong>将亡值</strong>。然后再将等号左边的<strong>引用</strong>绑定到这个<strong>将亡值</strong>对象上。</p><p><strong>临时量实质化</strong>的过程还发生在其它场景。</p><p>比如，<code>Foo&#123;10&#125;</code> 是一个<strong>纯右值</strong>，但如果我们试图访问其非静态成员，比如：<code>Foo&#123;10&#125;.m</code>，此时就必需要将这个临时量实质化，转化成<strong>将亡值</strong>。毕竟，对于任何非静态成员的访问，都需要对象的<strong>地址</strong>，与成员变量所代表的<strong>偏移</strong>两部分配合。没有对象的存在，仅靠偏移量访问其成员，根本不可能。</p><p>还有数组的订阅场景。比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> Array = <span class="hljs-type">char</span> [<span class="hljs-number">10</span>];<br><br>Array&#123;&#125;;    <span class="hljs-comment">// 纯右值</span><br>Array&#123;&#125;[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 将亡值</span><br></code></pre></td></tr></table></figure><p>另外，<code>static_cast&lt;T&gt;(expr)</code> 是一个<strong>直接初始化</strong>表达式， 即，中间存在一个隐含的 <code>T</code> 类型的未命名临时变量，通过 <code>expr</code> 进行初始化。如果 <code>expr</code> 是一个<strong>纯右值</strong>，而 <code>T</code> 是一个<strong>右值引用</strong>类型，则这个过程也是一个纯右值<strong>实质化</strong>的过程。</p><p>而之前提到的<strong>弃值表达式</strong>，也会有一个<strong>临时量实质化</strong>的过程。这样的表达式的存在主要是为了利用其副作用。如果编译器发现其并不存在副作用，往往会将其优化掉。但这是优化阶段的职责。在语义分析阶段，统统是<strong>临时量实质化</strong>语义。</p><p>在 C++17 之前的规范定义中，将<strong>纯右值</strong>和<strong>将亡值</strong>合在一起，称为<strong>右值</strong>。代表它们可以被一个<strong>右值引用类型的变量</strong>绑定（即初始化一个右值引用类型的变量）。因而，在进行重载匹配时，<strong>右值</strong>会优先匹配<strong>右值引用类型的参数</strong>。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Foo&amp;&amp;)</span></span>;       <span class="hljs-comment">// #1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> Foo&amp;)</span></span>;  <span class="hljs-comment">// #2</span><br><br><span class="hljs-function">Foo&amp;&amp; <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><br><br><span class="hljs-built_in">func</span>(Foo&#123;<span class="hljs-number">10</span>&#125;); <span class="hljs-comment">// #1</span><br><span class="hljs-built_in">func</span>(<span class="hljs-built_in">f</span>());     <span class="hljs-comment">// #1</span><br><br>Foo foo&#123;<span class="hljs-number">10</span>&#125;;<br><span class="hljs-built_in">func</span>(foo);     <span class="hljs-comment">// #2</span><br><br>Foo&amp;&amp; foo1 = Foo&#123;<span class="hljs-number">10</span>&#125;;<br><span class="hljs-built_in">func</span>(foo1);    <span class="hljs-comment">// #2</span><br></code></pre></td></tr></table></figure><p>到了 C++17，从匹配行为上没有变化，但语义上却有了变化。最终导致匹配右值引用版本的不是<strong>纯右值</strong>类别，而是<strong>将亡值</strong>。因为<strong>纯右值</strong>会首先进行<strong>实质化</strong>，得到一个<strong>将亡值</strong>。最终是用<strong>将亡值</strong>初始化了函数的对应参数。</p><p>一个<strong>纯右值</strong>，永远也无法匹配到移动构造函数。 因为 <code>Foo foo = Foo&#123;10&#125;</code> 与 <code>Foo foo&#123;10&#125;</code> 等价。这不需要将<strong>纯右值</strong>进行<strong>实质化</strong>，得到一个<strong>将亡值</strong>，然后匹配到移动构造函数的过程。</p><p>只有<strong>将亡值</strong>，才能匹配到移动构造。比如：<code>Foo foo = std::move(Foo&#123;10&#125;)</code> 将会导致移动构造的调用。</p><p>另外，一个表达式是<strong>将亡值</strong>，并不代表其所引用的对象一定是一个从<strong>纯右值</strong>实质化得到的临时对象。而是两种可能都存在。比如，如果 <code>foo</code> 是一个<strong>左值</strong>，<code>std::move(foo)</code> 这个<strong>将亡值</strong>所引用的对象就是一个<strong>左值</strong>； 而 <code>std::move(Foo&#123;10&#125;)</code> 则毫无疑问引用的是一个<strong>实质化</strong>后的到的临时对象。</p><p><img src="/images/cpp-value-categories/value-category-4.png" alt=" "></p><div class="note note-warning">            <p><strong>注意</strong></p><ul><li>所有的表达式都可以归类为<strong>纯右值</strong>和<strong>泛左值</strong>；</li><li>所有的<strong>纯右值</strong>都是<strong>值</strong>的概念；所有的<strong>泛左值</strong>都是<strong>对象</strong>的概念；</li><li><strong>左值</strong>可以求地址，<strong>将亡值</strong>不可以求地址；</li><li><strong>纯右值</strong>在需要临时对象存在的场景下，会通过<strong>实质化</strong>，转化成<strong>将亡值</strong>；</li><li><strong>泛左值</strong>可以是抽象类型和不完备类型，可以进行多态调用；<strong>纯右值</strong>只能是具体类型，无法进行多态调用；</li><li>用<strong>纯右值</strong>构造一个<strong>左值</strong>对象时，是<strong>直接构造</strong>语义；用<strong>将亡值</strong>构造一个<strong>左值</strong>对象时，是拷贝&#x2F;移动构造语义。</li></ul>          </div><h2 id="4-decltype-类型推导"><a href="#4-decltype-类型推导" class="headerlink" title="4. decltype 类型推导"></a>4. decltype 类型推导</h2><p><code>decltype</code> 是 C++11 加入的一个重要特性。它允许求一切合法表达式的类型。从而，让从类型到值，从值到类型形成了一个闭环，极大的扩展了泛型编程的能力。</p><p>C++ 规范中，对于 <code>decltype</code> 类型推导规则的定义如下：</p><ol><li>若实参为无括号的<strong>标识表达式</strong>或无括号的<strong>类成员访问表达式</strong>，则 <code>decltype</code> 产生以此表达式命名的实体的类型。 若无这种实体，或该实参指名某个重载函数，则程序非良构。</li><li>若实参是其他类型为 <code>T</code> 的任何表达式，且<br>a. 若<strong>表达式</strong>的值类别为<strong>将亡值</strong>，则 <code>decltype</code> 产生 <code>T&amp;&amp;</code>；<br>b. 若<strong>表达式</strong>的值类别为<strong>左值</strong>，则 <code>decltype</code> 产生 <code>T&amp;</code>；<br>c. 若<strong>表达式</strong>的值类别为<strong>纯右值</strong>，则 <code>decltype</code> 产生 <code>T</code>。</li></ol><p>若表达式是<strong>纯右值</strong>，则不从该纯右值<strong>实质化</strong>临时对象：这种纯右值无结果对象。</p><p>注意如果对象的名字带有括号，则它被当做通常的<strong>左值</strong>表达式，从而 <code>decltype(x)</code> 和 <code>decltype((x))</code> 通常是不同的类型。</p><p>这些规则，初看起来，有些让人困惑。但如果真的理解了背后的机制，其实非常容易理解。</p><p><code>decltype</code> 有两种表达方法：</p><ol><li>有括号：<code>decltype((expr))</code></li><li>无括号：<code>decltype(expr)</code></li></ol><h3 id="4-1-有括号语义"><a href="#4-1-有括号语义" class="headerlink" title="4.1 有括号语义"></a>4.1 有括号语义</h3><p>有括号的表达方法，语义是简单而统一的：它站在表达式类别的角度求类型。</p><ol><li>如果表达式属于<strong>纯右值</strong>，结果必然是<strong>非引用</strong>类型；</li><li>如果表达式属于<strong>泛左值</strong>，结果必然是<strong>引用</strong>类型；<ul><li>如果表达式属于<strong>左值</strong>，结果必然是<strong>左值引用</strong>；</li><li>如果表达式属于<strong>将亡值</strong>，结果必然是<strong>右值引用</strong>；</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123; <span class="hljs-type">int</span> a; &#125;;<br><br><span class="hljs-keyword">using</span> Func  = Foo&amp;();<br><span class="hljs-keyword">using</span> Array = <span class="hljs-type">char</span>[<span class="hljs-number">2</span>];<br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">E</span> &#123; OK, FAIL &#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> Foo   <span class="hljs-title">f_v</span><span class="hljs-params">()</span></span>;<br>      <span class="hljs-function">Foo&amp;  <span class="hljs-title">f_ref</span><span class="hljs-params">()</span></span>;<br>      <span class="hljs-function">Foo&amp;&amp; <span class="hljs-title">f_r</span><span class="hljs-params">()</span></span>;<br><br>      <span class="hljs-type">int</span>   a    = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>   b    = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> Foo   foo  = &#123;<span class="hljs-number">10</span>&#125;;<br>      Foo&amp;&amp; rref = Foo&#123;<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">const</span> Foo&amp;  ref  = foo;<br>      <span class="hljs-type">char</span>  c[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>      <span class="hljs-type">int</span>*  p    = &amp;a;<br><span class="hljs-type">const</span> Foo*  pFoo = &amp;foo;<br><br><span class="hljs-comment">// 左值</span><br><span class="hljs-keyword">decltype</span>((a))       v1;   <span class="hljs-comment">// int&amp;</span><br><span class="hljs-keyword">decltype</span>((foo))     v2;   <span class="hljs-comment">// const Foo&amp;</span><br><span class="hljs-keyword">decltype</span>((foo.a))   v3;   <span class="hljs-comment">// const int&amp;</span><br><span class="hljs-keyword">decltype</span>((<span class="hljs-built_in">f_ref</span>())) v4;   <span class="hljs-comment">// Foo&amp;</span><br><span class="hljs-keyword">decltype</span>((f_r))     v5;   <span class="hljs-comment">// Foo&amp;&amp; (&amp;)()</span><br><span class="hljs-keyword">decltype</span>((c))       v6;   <span class="hljs-comment">// char (&amp;)[2]</span><br><span class="hljs-keyword">decltype</span>((a += <span class="hljs-number">10</span>)) v7;   <span class="hljs-comment">// int&amp;</span><br><span class="hljs-keyword">decltype</span>((++a))     v8;   <span class="hljs-comment">// int&amp;</span><br><span class="hljs-keyword">decltype</span>((c[<span class="hljs-number">1</span>]))    v9;   <span class="hljs-comment">// char&amp;</span><br><span class="hljs-keyword">decltype</span>((*p))      v10;  <span class="hljs-comment">// int&amp;</span><br><span class="hljs-keyword">decltype</span>((p))       v11;  <span class="hljs-comment">// int*&amp;</span><br><span class="hljs-keyword">decltype</span>((pFoo))    v12;  <span class="hljs-comment">// const Foo*&amp;</span><br><span class="hljs-keyword">decltype</span>((pFoo-&gt;a)) v13;  <span class="hljs-comment">// const int&amp;</span><br><span class="hljs-keyword">decltype</span>((Foo::a))  v14;  <span class="hljs-comment">// int&amp;</span><br><span class="hljs-keyword">decltype</span>((rref))    v15;  <span class="hljs-comment">// Foo&amp;</span><br><span class="hljs-keyword">decltype</span>((ref))     v16;  <span class="hljs-comment">// const Foo&amp;</span><br><span class="hljs-keyword">decltype</span>((a &gt; <span class="hljs-number">0</span> ? a : b)) v;  <span class="hljs-comment">// int&amp;</span><br><span class="hljs-keyword">decltype</span>((<span class="hljs-built_in">static_cast</span>&lt;Func&amp;&amp;&gt;(f_ref))) f;  <span class="hljs-comment">// Foo&amp; (&amp;)()</span><br><br><span class="hljs-comment">// 纯右值</span><br><span class="hljs-keyword">decltype</span>((<span class="hljs-number">1</span>+<span class="hljs-number">2</span>))         v1;  <span class="hljs-comment">// int</span><br><span class="hljs-keyword">decltype</span>((Foo&#123;<span class="hljs-number">10</span>&#125;))     v2;  <span class="hljs-comment">// Foo</span><br><span class="hljs-keyword">decltype</span>((<span class="hljs-built_in">f_v</span>()))       v3;  <span class="hljs-comment">// const Foo</span><br><span class="hljs-keyword">decltype</span>((Array&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;)) v4;  <span class="hljs-comment">// char[2]</span><br><span class="hljs-keyword">decltype</span>((a++))         v5;  <span class="hljs-comment">// int</span><br><span class="hljs-keyword">decltype</span>((&amp;b))          v6;  <span class="hljs-comment">// const int*</span><br><span class="hljs-keyword">decltype</span>((OK))          v7;  <span class="hljs-comment">// E</span><br><span class="hljs-keyword">decltype</span>((a &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">10</span> : Foo&#123;<span class="hljs-number">0</span>&#125;.a)) v;  <span class="hljs-comment">// int</span><br><br><span class="hljs-comment">// 将亡值</span><br><span class="hljs-keyword">decltype</span>((Foo&#123;<span class="hljs-number">10</span>&#125;.a))    v1;  <span class="hljs-comment">// int&amp;&amp;</span><br><span class="hljs-keyword">decltype</span>((<span class="hljs-built_in">f_r</span>()))        v2;  <span class="hljs-comment">// Foo&amp;&amp;</span><br><span class="hljs-keyword">decltype</span>((Array&#123;&#125;[<span class="hljs-number">0</span>]))   v3;  <span class="hljs-comment">// char&amp;&amp;</span><br><span class="hljs-keyword">decltype</span>((std::<span class="hljs-built_in">move</span>(a))) v4;  <span class="hljs-comment">// int&amp;&amp;</span><br><span class="hljs-keyword">decltype</span>((a &gt; <span class="hljs-number">0</span> ? Foo&#123;<span class="hljs-number">1</span>&#125;.a : Foo&#123;<span class="hljs-number">0</span>&#125;.a)) v;  <span class="hljs-comment">// int&amp;&amp;</span><br></code></pre></td></tr></table></figure><p>这其中，最有趣的是 <code>decltype((rref))</code>，<code>rref</code> 本身的类型是一个右值引用 <code>Foo&amp;&amp;</code>，但做为左值表达式，它的类型却是 <code>Foo&amp;</code>，而这一点，请参见<strong>右值引用变量</strong>。</p><h3 id="4-2-无括号语义"><a href="#4-2-无括号语义" class="headerlink" title="4.2 无括号语义"></a>4.2 无括号语义</h3><p>无括号的情况下，除了一种例外，其它情况下，都与有括号场景一致。</p><p>这个例外就是对于变量（包括常量）名字的直接求类型。这种情况，会返回变量被定义时的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123; <span class="hljs-type">int</span> a; &#125;;<br><br><span class="hljs-keyword">using</span> Func  = Foo&amp;();<br><span class="hljs-keyword">using</span> Array = <span class="hljs-type">char</span>[<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">const</span> Foo   <span class="hljs-title">f_v</span><span class="hljs-params">()</span></span>;<br>      <span class="hljs-function">Foo&amp;  <span class="hljs-title">f_ref</span><span class="hljs-params">()</span></span>;<br>      <span class="hljs-function">Foo&amp;&amp; <span class="hljs-title">f_r</span><span class="hljs-params">()</span></span>;<br><br>      <span class="hljs-type">int</span>   a    = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>   b    = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> Foo   foo  = &#123;<span class="hljs-number">10</span>&#125;;<br>      Foo&amp;&amp; rref = Foo&#123;<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">const</span> Foo&amp;  ref  = foo;<br>      <span class="hljs-type">char</span>  c[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>      <span class="hljs-type">int</span>*  p    = &amp;a;<br><span class="hljs-type">const</span> Foo*  pFoo = &amp;foo;<br><br><span class="hljs-keyword">decltype</span>(a)        v1;   <span class="hljs-comment">// int</span><br><span class="hljs-keyword">decltype</span>(b)        v2;   <span class="hljs-comment">// const int</span><br><span class="hljs-keyword">decltype</span>(foo)      v3;   <span class="hljs-comment">// const Foo</span><br><span class="hljs-keyword">decltype</span>(ref)      v4;   <span class="hljs-comment">// const Foo&amp;</span><br><span class="hljs-keyword">decltype</span>(rref)     v5;   <span class="hljs-comment">//       Foo&amp;&amp;</span><br><span class="hljs-keyword">decltype</span>(c)        v6;   <span class="hljs-comment">// char[2]</span><br><span class="hljs-keyword">decltype</span>(p)        v7;   <span class="hljs-comment">// int*</span><br><span class="hljs-keyword">decltype</span>(foo.a)    v8;   <span class="hljs-comment">// int</span><br><span class="hljs-keyword">decltype</span>(ref.a)    v9;   <span class="hljs-comment">// int</span><br><span class="hljs-keyword">decltype</span>(rref.a)   v10;  <span class="hljs-comment">// int</span><br><span class="hljs-keyword">decltype</span>(pFoo)     v11;  <span class="hljs-comment">// const Foo*</span><br><span class="hljs-keyword">decltype</span>(pFoo-&gt;a)  v12;  <span class="hljs-comment">// int</span><br><span class="hljs-keyword">decltype</span>(Foo&#123;<span class="hljs-number">1</span>&#125;.a) v13;  <span class="hljs-comment">// int</span><br><span class="hljs-keyword">decltype</span>(Foo::a)   v14;  <span class="hljs-comment">// int</span><br></code></pre></td></tr></table></figure><p>从例子中不难看出，对于所有的变量访问，无论直接还是间接，由于每个变量在定义时都有自己的类型，因而求类型的结果就是这些变量被定义时的类型。</p><p>所以，之所以会出现有括号，无括号两种用法，正是因为每一个被定义的变量，都面临着两种需求：</p><ol><li>它们被定义时的类型</li><li>整体做为一个表达式的类型（一定是泛左值）</li></ol><p>前者是不关心表达式的，比如 <code>decltype(Foo&#123;1&#125;.a)</code>，它只关心 <code>a</code> 被定义时的类型：<code>int</code>； 而不关心整个表达式本身是一个<strong>将亡值</strong>，因而表达式必然应该是一种右值引用类型：<code>int&amp;&amp;</code>。</p><p>正是对于变量有这两种需求的存在，而其它表达式没有这样的问题，所以，才专门为变量定义了两种求类型的方法。而对于其它表达式则两种方式无差别。</p><h2 id="5-auto-类型推导"><a href="#5-auto-类型推导" class="headerlink" title="5. auto 类型推导"></a>5. auto 类型推导</h2><p><code>auto</code> 类型推导脱胎于模版函数的类型推导，它们的能力几乎等价（除了初始化列表的情况）。 这也就意味着，其实在 C++11 之前，C++ 早就具备了 <code>auto</code> 的能力，只是没有从语法上允许而已。</p><h3 id="5-1-auto-的语义"><a href="#5-1-auto-的语义" class="headerlink" title="5.1 auto 的语义"></a>5.1 auto 的语义</h3><p>和直觉不同的是，对于任意表达式：<code>auto v = expr</code>，<code>v</code> 的类型并不总是和 <code>expr</code> 所返回的类型一致。</p><p>首先，<code>auto</code> 不可能是一个<strong>引用</strong>，无论是<strong>左值引用</strong>，还是<strong>右值引用</strong>，所以，如果 <code>expr</code> 返回类型里包含任何引用，都会被舍弃。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Foo   foo &#123;<span class="hljs-number">1</span>&#125;;<br>Foo&amp;  ref  = foo;<br>Foo&amp;&amp; rref = Foo&#123;<span class="hljs-number">2</span>&#125;;<br><br><span class="hljs-function">Foo&amp;  <span class="hljs-title">getRef</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Foo&amp;&amp; <span class="hljs-title">getRref</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">auto</span> v1 = ref;        <span class="hljs-comment">// v1 type: Foo</span><br><span class="hljs-keyword">auto</span> v2 = rref;       <span class="hljs-comment">// v2 type: Foo</span><br><span class="hljs-keyword">auto</span> v3 = <span class="hljs-built_in">getRef</span>();   <span class="hljs-comment">// v3 type: Foo</span><br><span class="hljs-keyword">auto</span> v4 = <span class="hljs-built_in">getRref</span>();  <span class="hljs-comment">// v4 type: Foo</span><br></code></pre></td></tr></table></figure><p>其次，所有对值所修饰的 <code>const</code> 都会被丢弃。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Foo   foo &#123;<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">const</span> Foo&amp;  ref    = foo;<br><span class="hljs-type">const</span> Foo&amp;&amp; rref   = Foo&#123;<span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">const</span> Foo* <span class="hljs-type">const</span> p = &amp;foo;<br><br><span class="hljs-keyword">auto</span> v1 = foo;  <span class="hljs-comment">// Foo</span><br><span class="hljs-keyword">auto</span> v2 = ref;  <span class="hljs-comment">// Foo</span><br><span class="hljs-keyword">auto</span> v3 = rref; <span class="hljs-comment">// Foo</span><br><span class="hljs-keyword">auto</span> v4 = p;    <span class="hljs-comment">// const Foo*</span><br></code></pre></td></tr></table></figure><p>究其原因，是因为这种直接给出 <code>auto</code> 的写法，是一种拷贝&#x2F;移动语义。因而，等号右边的表达式本身类型是引用，并不影响等号左侧对象本身不是引用；同样的，等号右边表达式本身的常量性，拷贝&#x2F;移动后，并不会影响新定义变量的常量性 。</p><p>其推演语义，完全等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T value)</span></span>;<br></code></pre></td></tr></table></figure><p>其中 <code>T</code> 就是 <code>auto</code>，<code>value</code> 就是你用 <code>auto</code> 所定义的变量。</p><p>注意，到了 C++17 之后，并非所有的场景下，都是拷贝&#x2F;移动语义，比如 <code>auto v = Foo&#123;1&#125;</code>，其行为完全等价于：<code>Foo v&#123;1&#125;</code> 。具体可参见<strong>对象？值？</strong>。</p><p>因而，更准确的说，这不是拷贝&#x2F;移动语义，而属于构造初始化语义。</p><h3 id="5-2-引用及-const"><a href="#5-2-引用及-const" class="headerlink" title="5.2 引用及 const"></a>5.2 引用及 const</h3><p>因而，如果你希望让新定义的变量属于引用类型，或具备 <code>const</code>，则需要明确指定。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">      <span class="hljs-keyword">auto</span>   foo  = Foo&#123;<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp;  ref  = foo;<br>      <span class="hljs-keyword">auto</span>&amp;&amp; rref = Foo&#123;<span class="hljs-number">2</span>&#125;;<br></code></pre></td></tr></table></figure><p>而指针的情况则稍有特殊。</p><h3 id="5-3-指针"><a href="#5-3-指针" class="headerlink" title="5.3 指针"></a>5.3 指针</h3><p>当你不指定指针的情况下，如果等号右侧的表达式是一个指针类型，那么左侧的变量类型当然也是一个指针。</p><p>当你明确指定指针的情况下，则是要求右侧表达式必须是一个指针类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Foo  foo &#123;<span class="hljs-number">1</span>&#125;;<br>Foo* pFoo = &amp;foo;<br><br><span class="hljs-keyword">auto</span>  v1 = foo;  <span class="hljs-comment">// v1 type: Foo</span><br><span class="hljs-keyword">auto</span>  p1 = pFoo; <span class="hljs-comment">// p1 type: Foo*</span><br><span class="hljs-keyword">auto</span>* p2 = pFoo; <span class="hljs-comment">// p2 type: Foo*</span><br><span class="hljs-keyword">auto</span>* p3 = foo;  <span class="hljs-comment">// Error: foo is not a pointer</span><br></code></pre></td></tr></table></figure><h3 id="5-4-万能引用"><a href="#5-4-万能引用" class="headerlink" title="5.4 万能引用"></a>5.4 万能引用</h3><p>更为特殊的是 <code>auto&amp;&amp; v = expr</code> 的表达式。这并不必然导致 <code>v</code> 是一个右值引用。而是取决于 <code>expr</code> 的类别。</p><p>如果 <code>expr</code> 是一个<strong>左值</strong>表达式，那么 <code>v</code> 将是左值引用类型；</p><p>如果 <code>expr</code> 是一个<strong>右值</strong>表达式（参见<strong>对象？值？</strong>），那么 <code>v</code> 将会是右值引用类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Foo   foo &#123;<span class="hljs-number">1</span>&#125;;<br>Foo&amp;  ref  = foo;<br>Foo&amp;&amp; rref = Foo&#123;<span class="hljs-number">2</span>&#125;;<br><span class="hljs-function">Foo&amp;&amp; <span class="hljs-title">getRref</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Foo&amp;  <span class="hljs-title">getRef</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Foo   <span class="hljs-title">getFoo</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">auto</span>&amp;&amp; v1 = foo;       <span class="hljs-comment">// v1 type: Foo&amp;</span><br><span class="hljs-keyword">auto</span>&amp;&amp; v2 = Foo&#123;<span class="hljs-number">2</span>&#125;;    <span class="hljs-comment">// v2 type: Foo&amp;&amp;</span><br><span class="hljs-keyword">auto</span>&amp;&amp; v3 = <span class="hljs-built_in">getRref</span>(); <span class="hljs-comment">// v3 type: Foo&amp;&amp;</span><br><span class="hljs-keyword">auto</span>&amp;&amp; v4 = <span class="hljs-built_in">getRef</span>();  <span class="hljs-comment">// v4 type: Foo&amp;</span><br><span class="hljs-keyword">auto</span>&amp;&amp; v5 = <span class="hljs-built_in">getFoo</span>();  <span class="hljs-comment">// v5 type: Foo&amp;&amp;</span><br><span class="hljs-keyword">auto</span>&amp;&amp; v6 = ref;       <span class="hljs-comment">// v6 type: Foo&amp;</span><br><span class="hljs-keyword">auto</span>&amp;&amp; v7 = rref;      <span class="hljs-comment">// v7 type: Foo&amp;</span><br></code></pre></td></tr></table></figure><p>正是因为这样的写法，允许等号右侧是任意合法的表达式，而等号左侧总是可以根据表达式类别，推演出合适的引用类型。所以这种写法被称做<strong>万能引用</strong>。</p><p>其中，我们可以清晰的看出，虽然 <code>ref</code> 和 <code>rref</code> 分别被定义为<strong>左值引用</strong>和<strong>右值引用</strong>，但它们做为左值来讲，是等价的。都是左值引用。具体可参考<strong>右值引用变量</strong>。</p><h3 id="5-5-初始化列表"><a href="#5-5-初始化列表" class="headerlink" title="5.5 初始化列表"></a>5.5 初始化列表</h3><p>由于初始化列表不是一个表达式，因而类型也就无从谈起。所以 C++14 对其做了特殊的规定：</p><p>如果使用<strong>直接初始化</strong>（不用等号）的方式，比如：<code>auto i&#123;1&#125;</code> ，则初始化列表只允许有一个元素，其等价于 <code>auto i = 1</code>； 如果初始化列表超过一个元素，比如 <code>auto j&#123;1,2&#125;</code> ，则编译失败。</p><p>如果使用<strong>拷贝初始化</strong>（用等号）的方式，比如：<code>auto v = &#123;1, 2&#125;</code>，则初始化列表允许有多个同一类型的元素。其等价于 <code>std::initializer_list&lt;int&gt; v = &#123;1, 2&#125;</code> 。而 <code>auto v = &#123;1&#125;</code> 则等价于 <code>std::initializer_list&lt;int&gt; v = &#123;1&#125;</code>。</p><h3 id="5-6-decltype-auto"><a href="#5-6-decltype-auto" class="headerlink" title="5.6 decltype(auto)"></a>5.6 decltype(auto)</h3><p>由于 <code>auto</code> 推演总是会丢弃<strong>引用</strong>及 <code>const</code> 信息，明确给出<strong>引用</strong>又总是得到一个引用。明确给出 <code>const</code>，则总是得到一个 <code>const</code> 类型。这对于想精确遵从等号后面类型的情况非常不便，尤其在进行泛型编程时，很难通过 <code>auto</code> 符合通用的情况。</p><p>而 <code>decltype</code> 恰恰相反，它总是能准确捕捉右侧表达式的类型（参见 <code>decltype</code> ）。因而，我们可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">      Foo   foo &#123;<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">const</span> Foo&amp;  ref  = foo;<br>      Foo&amp;&amp; rref = Foo&#123;<span class="hljs-number">2</span>&#125;;<br>      <span class="hljs-type">int</span>   a    = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">decltype</span>(foo)    v1 = foo;   <span class="hljs-comment">// Foo</span><br><span class="hljs-keyword">decltype</span>((foo))  v2 = foo;   <span class="hljs-comment">// Foo&amp;</span><br><span class="hljs-keyword">decltype</span>(ref)    v3 = ref;   <span class="hljs-comment">// const Foo&amp;</span><br><span class="hljs-keyword">decltype</span>(rref)   v4 = rref;  <span class="hljs-comment">// Foo&amp;&amp;</span><br><span class="hljs-keyword">decltype</span>((rref)) v5 = rref;  <span class="hljs-comment">// Foo&amp;</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>)    v6 = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>; <span class="hljs-comment">// int</span><br><br><span class="hljs-keyword">decltype</span>((a &gt; <span class="hljs-number">0</span> ? Foo&#123;<span class="hljs-number">0</span>&#125;.a : Foo&#123;<span class="hljs-number">1</span>&#125;.a)) v7 = \<br>   a &gt; <span class="hljs-number">0</span> ? Foo&#123;<span class="hljs-number">0</span>&#125;.a : Foo&#123;<span class="hljs-number">1</span>&#125;.a; <span class="hljs-comment">// int&amp;&amp;</span><br></code></pre></td></tr></table></figure><p>但这样的写法，总是要把右边的表达式在 <code>decltype</code> 里重复写一遍，才能做到。到了 C++14 ，推出了一种新的写法：<code>decltype(auto)</code>，其中 <code>auto</code> 是一个自动占位符，代表等号右侧的表达式，这就大大简化了程序员的工作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) v1 = foo;    <span class="hljs-comment">// Foo</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) v2 = (foo);  <span class="hljs-comment">// Foo&amp;</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) v7 = (a &gt; <span class="hljs-number">0</span> ? Foo&#123;<span class="hljs-number">0</span>&#125;.a : Foo&#123;<span class="hljs-number">1</span>&#125;.a); <span class="hljs-comment">// int&amp;&amp;</span><br></code></pre></td></tr></table></figure><h3 id="5-7-函数返回值类型的自动推演"><a href="#5-7-函数返回值类型的自动推演" class="headerlink" title="5.7 函数返回值类型的自动推演"></a>5.7 函数返回值类型的自动推演</h3><p>到了 C++14 之后，对于普通函数的返回值自动推演，可以通过 <code>auto</code> 来完成，比如：</p><p><code>auto f() &#123; return Foo&#123;1&#125;.a; &#125; // 返回值类型为int</code></p><p>当然，如果希望返回值类型运用 <code>decltype</code> 规则，则可以用 <code>decltype(auto)</code> 。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> -&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) </span>&#123; <span class="hljs-comment">// 返回值为 int&amp;&amp;</span><br>  <span class="hljs-keyword">return</span> (Foo&#123;<span class="hljs-number">1</span>&#125;.a);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-8-非类型模版参数"><a href="#5-8-非类型模版参数" class="headerlink" title="5.8 非类型模版参数"></a>5.8 非类型模版参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">auto</span> V&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> &#123;<br>   <span class="hljs-comment">// ....</span><br>&#125;;<br><br>C&lt;<span class="hljs-number">10</span>&gt;   a; <span class="hljs-comment">// C&lt;int&gt;</span><br>C&lt;<span class="hljs-string">&#x27;c&#x27;</span>&gt;  b; <span class="hljs-comment">// C&lt;char&gt;</span><br>C&lt;<span class="hljs-literal">true</span>&gt; c; <span class="hljs-comment">// C&lt;bool&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-9-函数模版的便捷写法"><a href="#5-9-函数模版的便捷写法" class="headerlink" title="5.9 函数模版的便捷写法"></a>5.9 函数模版的便捷写法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T1 lhs, T2 rhs)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> lhs + rhs;<br>&#125;<br></code></pre></td></tr></table></figure><p>到了 C++20 ，允许让普通函数可以有更加便捷的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> lhs, <span class="hljs-keyword">auto</span> rhs)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> lhs + rhs;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果你想指明两个参数属于同一种类型，但另外的参数没有这样的约束，则仍然需要写模版头：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">(T a, <span class="hljs-keyword">auto</span> b, T c, <span class="hljs-keyword">auto</span> d)</span></span>; <span class="hljs-comment">// a, c 必须同一类型，b, d 各自有各自类型</span><br></code></pre></td></tr></table></figure><p>其等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">(T a, T1 b, T c, T2 d)</span></span>;<br></code></pre></td></tr></table></figure><p><em>本文摘自博客：<a href="https://modern-cpp.readthedocs.io/zh_CN/latest/index.html">https://modern-cpp.readthedocs.io/zh_CN/latest/index.html</a></em></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>特性</tag>
      
      <tag>值类别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 概念简介</title>
    <link href="/2023/08/22/cpp-concepts-introduction/"/>
    <url>/2023/08/22/cpp-concepts-introduction/</url>
    
    <content type="html"><![CDATA[<p>C++ 模板不仅具备强大的泛化能力，自身也是一种“图灵完备”的语言，掀起了 C++ 之父 Bjarne Stroustrup 自己都没料到的“模板元编程”这一子领域。</p><p>但是，使用模板做泛型编程，最大的问题就是缺少良好的接口，一旦使用过程中出现偏差，报错信息我们难以理解，甚至无从下手。更糟的是，使用模板的代码几乎无法做到程序 ABI 层面兼容。这些问题的根本原因是 C++ 语言本身缺乏模板参数约束能力，因此，既能拥有良好接口、高性能表达泛化，又能融入语言本身是非常困难的。</p><p>好在 C++20 标准及其后续演进中，为我们带来了 Concepts 核心语言特性变更来解决这一难题。那么它能为我们的编程体验带来多大的革新？能解决多少模板元编程的历史遗留问题？今天我们一起探究 Concepts。</p><h2 id="第-1-章-概念和约束的历史"><a href="#第-1-章-概念和约束的历史" class="headerlink" title="第 1 章 概念和约束的历史"></a>第 1 章 概念和约束的历史</h2><p>早在 1987 年，C++ 之父 Bjarne Stroustrup 就着手为模板参数设置合适的接口。长期以来，模板参数没有任何约束，仅仅在实例化的时候才能发现类型上的错误。他希望模板拥有如下三大特点：</p><ul><li>强大的泛化、表达能力。</li><li>相对于手写代码做到零成本开销。</li><li>良好的接口。</li></ul><p>目前看来 C++ 做到了前两点，强大的泛化与表达能力具备“图灵完备”的能力，能够在编译时完成大量计算任务，同时生成的代码拥有比手写更高的性能，在提供前所未有的灵活性的前提下并没有性能损失，这使得模板特性非常成功。</p><p>20 世纪 90 年代，泛型编程因 C++ 中的标准模板库而成为主流，开发人员也开始在库开发中广泛使用泛型编程手段。使用模板做泛型编程过程中遇到的问题是缺少良好的接口，导致编译错误信息非常难读，这困扰了开发人员许多年。除了错误信息不够友好之外，在阅读使用模板元编程的库时面对大量模板参数，在不深入实现的前提下也常常不知为何物。语言上的缺陷导致后来产生 <code>enable_if</code> 等变通方法。</p><p>包括 C++ 之父在内的许多人都在寻求解决方案，尤其是标准委员会的成员希望该方案能够在 C++0x 版本落地，但直到后来的 C++17 版本也都没能实现。没有人能够提出一种既能满足这三种目标，又能合适地融于语言，并且编译速度足够快的方案。</p><p>好在 C++20 起对 concept 特性进行了标准化，目前主流的编译器也提供了支持。concept 的名字由 STL 之父 Alex Stepanov 命名，将一类数据类型和对它的一组操作所满足的公理集称为 concept：不仅需要从语法上满足要求，还需要从语义层面上满足。</p><p>几十年来，计算机科学一直在追求软件重用的目标。有多种方法，但没有一种方法能像其他工程学科中的类似尝试那样成功。泛型编程提供了机会。它基于这样一个原则，即软件可以分解为组件，这些组件只对其他组件做出最小的假设（concept），从而得到允许组合的最大灵活性。</p><p>泛型编程的关键在于高度可复用的组件必须以 concept 为基础进行编程，而 concept 尽可能匹配更多的类型，并且要求在不牺牲性能的前提下完成这一任务。标准模板库就是基于少量广泛有用的概念，使得用户能够通过各种方式与它们灵活组合。因此，concept 是泛型编程的基石。</p><p>本章将详细介绍 C++ 的 concept 特性发展过程，从中我们能看到语言设计者们需要面临与考虑的问题。</p><h3 id="1-1-1994-年（早期想法）"><a href="#1-1-1994-年（早期想法）" class="headerlink" title="1.1 1994 年（早期想法）"></a>1.1 1994 年（早期想法）</h3><p>1994 年，在 Bjarne Stroustrup 的著作 <em>The Design and Evolution of C++</em> 中提到了两种对模板参数的约束方案，分别是继承形式和依据表达式的形式。</p><h4 id="1-1-1-继承方案"><a href="#1-1-1-继承方案" class="headerlink" title="1.1.1 继承方案"></a>1.1.1 继承方案</h4><p>该方案是通过继承方式来表达约束的，使用和声明类同样的语法，然后在模板定义的时候将模板参数派生自约束类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparable</span> &#123;<br>    T&amp;  <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> T&amp;);<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> T&amp;, <span class="hljs-type">const</span> T&amp;);<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> T&amp;, <span class="hljs-type">const</span> T&amp;);<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> T&amp;, <span class="hljs-type">const</span> T&amp;);<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> : Comparable&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vector</span> &#123; <span class="hljs-comment">/*...*/</span> &#125;;<br></code></pre></td></tr></table></figure><p>上述代码中我们声明了约束类 Comparable，它对模板参数的要求为能够进行复制、判等、比较操作，然后在定义模板类 vector 的时候，使用继承语法 T: Comparable 表明模板参数被约束。</p><p>这种方式有个几个问题，首先是滥用继承，由于约束被设计成类，因此想要表达约束，使用继承这个特性也合理，但对于表达“模板参数必须支持某些操作”与“模板参数派生自某些约束”的情况而言，后者是一种不灵活的表达方式，而且会导致继承的滥用。除此之外基础类型无法使用继承特性，那么模板参数也就对基础类型封闭，它仅限于用户自定义类型。继承通常表达 subtype 关系，而不是所有的约束都需要硬塞进继承体系中。</p><p>其次是它混淆了编程语言中的不同层次的概念：concept 与抽象类，前者是静态的函数而后者是动态的概念，上述实现方式使得它们无法被区分。最后的问题是这种方式不够灵活，由于约束类中声明了一系列函数原型，而这些原型是严格匹配的，这就无法适用于隐式类型转换与函数重载等场景；严格匹配也限制了该方法的灵活性，且存在过约束的问题。</p><h4 id="1-1-2-基于表达式使用"><a href="#1-1-2-基于表达式使用" class="headerlink" title="1.1.2 基于表达式使用"></a>1.1.2 基于表达式使用</h4><p>下述代码方案是依据表达式使用的形式，它比继承的方式灵活得多，能够解决隐式类型转换和函数重载的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">constraints</span><span class="hljs-params">(T* tp)</span> </span>&#123; <span class="hljs-comment">// 要求模板参数 T 必须满足：</span><br>        B* bp =tp;            <span class="hljs-comment">// 能够进行隐式类型转换到基类 B</span><br>        tp-&gt;<span class="hljs-built_in">f</span>();              <span class="hljs-comment">// 存在成员函数 f</span><br>        <span class="hljs-function">T <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;               <span class="hljs-comment">// 能够通过 int 类型构造该类</span><br>        a = *tp;              <span class="hljs-comment">// 支持拷贝构造</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种方式无须添加任何语言上的支持，但代码的编写取决于编译器实现。早期的 C++ 编译器 Cfront 会检查所有函数的语法，若模板参数不符合要求，constraints 函数将产生语法错误，用户通过错误信息找到函数 constraints 的实现便能得知对类型上的约束。而现代主流的编译器仅对被调用的函数进行代码生成，那么就要求用户使用的时候对 constraints 函数进行调用，这加重了用户的负担。</p><p>从这个例子我们能够看出缺少语言上的支持，那么会产生很多变通方案，包括第 10 章介绍的一些技巧。对于这个问题 Bjarne Stroustrup 想到了提供关键字 constraints 来编写约束，并且在函数调用前进行自动调用检查。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>constraints &#123;<br>    T* tp; <span class="hljs-comment">// 要求模板参数 T 必须满足</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123; <span class="hljs-comment">/*...*/</span> &#125;;<br></code></pre></td></tr></table></figure><p>这种方案基本不会对模板参数过约束，同时也能满足一定程度的泛化、简洁与可理解性，并且容易实现。</p><h3 id="1-2-2003-年（初步设计）"><a href="#1-2-2003-年（初步设计）" class="headerlink" title="1.2 2003 年（初步设计）"></a>1.2 2003 年（初步设计）</h3><p>对模板参数进行约束的想法持续到了 2003 年。Bjarne Stroustrup 在他的论文 Conceptchecking 中进一步细化并提出了 4 种解决方案。</p><h4 id="1-2-1-虚基类方式"><a href="#1-2-1-虚基类方式" class="headerlink" title="1.2.1 虚基类方式"></a>1.2.1 虚基类方式</h4><p>该方案与最初的继承方案不同，它完全采用虚函数机制。使用继承的好处是容易理解且不需要增加额外的语法符号，并且可视作面向对象方式的语法糖，降低了编译器实现的难度。另一个的好处是可以将模板的声明与实现分离，无须将它们统一定义到头文件中，从而隐藏了实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Element</span> &#123; <span class="hljs-comment">// 定义容器的元素支持排序操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">lessThan</span><span class="hljs-params">(Element&amp;)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Element&amp;)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> : Element&gt; <span class="hljs-comment">// 对模板参数进行约束</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Container&lt;T&gt;&amp; c)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Number</span> : Element &#123; <span class="hljs-comment">/*...*/</span> &#125;; <span class="hljs-comment">// 再次引入继承以满足要求</span><br></code></pre></td></tr></table></figure><p>这种方式带来的问题在于，具体实现 Element 实例的接口时，需要进行基类到具体类的转换，这需要运行时类型检查以确保类型安全。将泛型函数转换成面向对象的形式会带来性能损失：每一个模板函数的调用将触发虚函数调用。</p><p>虽然可以通过编译器对程序进行分析，或者通过编译器根据标记特殊处理某些模板函数的方式来提高性能，但这都不是最优雅的方式，同时也增添了编译器的实现负担。</p><p>另一个问题是，将对模板参数的要求提炼成基类会导致类的泛滥，而且这也不符合泛型编程的习惯。假如有两个人开发科学计算库，其中一个人表达加法使用 Addable 约束类，而另一个人表达加法使用 Add 约束类，当用户提供的 Number 类想要使用这两个人提供的泛型函数时，不得不同时派生自 Addable 约束类与 Add 约束类并实现两套接口，这样做会引入额外的复杂度。考虑如下常见的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Addable <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Addable&amp;, <span class="hljs-type">const</span> Addable);<br></code></pre></td></tr></table></figure><p>如何确保两个约束类 Addable 拥有同一个具体类型？返回类型又该如何确定？答案是基础类型需要额外的包装才能使用，而返回抽象类型的值在 C++ 语言中是非法的。</p><h4 id="1-2-2-函数匹配方案"><a href="#1-2-2-函数匹配方案" class="headerlink" title="1.2.2 函数匹配方案"></a>1.2.2 函数匹配方案</h4><p>更理想的方案是避免使用继承来表达约束，可以使用匹配（match）一词取而代之，表达如下：</p><p>我们要求模板参数类匹配由 match 声明的函数所指定的约束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">match Addable &#123; <span class="hljs-comment">// match 声明了一系列操作的约束</span><br>    Addable <span class="hljs-keyword">operator</span>+(Addable);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> match Addable&gt; <span class="hljs-comment">// 模板参数需要符合 Addable 的要求</span><br><span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;T&gt;&amp;)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Number</span> &#123; <span class="hljs-comment">/*...*/</span> &#125;; <span class="hljs-comment">// 无须使用继承满足要求，只需要提供 operator+</span><br></code></pre></td></tr></table></figure><p>当 <code>vector&lt;Number&gt;</code> 想要使用泛型函数 sum 时，要求 Number 的实现中能够提供成员函数 operator+，否则将导致编译错误。这种方式避免了基类方案中的很多缺点。</p><p>通过关键字 match 使得开发者可以表达自由函数与成员函数，而不仅仅局限于成员函数。此外基础数据类型也能很好地支持，只要基础类型匹配被要求的操作即可。这种灵活性一定程度带来了编译器实现上的复杂度：基类方案可以复用已有的语法规则，并且能够复用抽象类的实现模型；而函数匹配方案没有已有的实现模型，需要更复杂的代码生成策略以实现传统模板的性能。</p><p>该方案和基类方案都有一个共同的缺点，它们都需要严格匹配函数的签名。就操作符重载而言，可以通过成员函数与非成员函数实现，那么在声明 match 的时候就需要考虑支持这两种方式中的一种；同样需要考虑，函数的参数既可以声明成 const 也可以声明非 const 等。严格匹配无法很好地表达那些函数涉及重载与参数隐式类型转换的场景。</p><h4 id="1-2-3-基于表达式使用"><a href="#1-2-3-基于表达式使用" class="headerlink" title="1.2.3 基于表达式使用"></a>1.2.3 基于表达式使用</h4><p>这个方案后来也被称为得克萨斯提案，它在论文中占据近一半的篇幅。相比前两种方案一直要求模板参数能够满足什么操作，这个方案则进一步表达该如何使用这些操作，使用两个新的关键字：concept 定义概念，constraints 描述表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">concept</span> Element &#123; <span class="hljs-comment">// 定义约束 Element</span><br>    <span class="hljs-built_in">constraints</span>(Element e1, Element e2) &#123;<br>        <span class="hljs-type">bool</span> b = e1 &lt; e2; <span class="hljs-comment">// 要求两个 Element 能够使用 &lt; 操作，返回值能够类型转换成 bool</span><br>                          <span class="hljs-comment">// 不管是以成员函数还是自由函数方式提供的</span><br>        <span class="hljs-built_in">swap</span>(e1, e2); <span class="hljs-comment">// 都要求能够进行交换操作</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 模板参数声明 typename 替换成 Element 约束</span><br><span class="hljs-keyword">template</span> &lt;Element E&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(vector&lt;E&gt;&amp; c)</span></span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span> &#123; <span class="hljs-comment">/* 满足约束无须使用继承 */</span> &#125;;<br></code></pre></td></tr></table></figure><p>这种方案是基于 1994 年的 constraints 函数的想法，和普通函数类似，也需要使用合法的 C++ 表达式、语句。编译时可以通过检查 constraints 的语法来判断模板参数是否满足要求，且毫无运行时开销。与函数匹配方案相比，它无须显式指明要求的函数签名，而是以一种很自然的使用方式来表达。</p><p>更进一步，它还可以对多个 concept 进行组合，并使用逻辑操作符来表达：同时满足约束、满足其中一个、要求不满足。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt; Printable &amp;&amp; ValueType T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123; <span class="hljs-comment">/*...*/</span> &#125;;<br><span class="hljs-keyword">template</span> &lt; Printable || ValueType T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span> &#123; <span class="hljs-comment">/*...*/</span> &#125;;<br><span class="hljs-keyword">template</span> &lt;!Printable &amp;&amp; ValueType T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Z</span> &#123; <span class="hljs-comment">/*...*/</span> &#125;;<br></code></pre></td></tr></table></figure><p>因为 concept 是一组类型的模型，是从现有类型产生新类型的常用方法，所以参数化（模板）、派生等方式也自然适用于 concept。</p><p>考虑通过参数化从已有的 concept 产生的新的 concept，例如标准库中迭代器的概念代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;ValueType V&gt; <span class="hljs-comment">// 参数化类型 V，需满足 ValueType</span><br><span class="hljs-keyword">concept</span> ForwardIterator &#123;<br>    <span class="hljs-built_in">constraints</span>(ForwardIterator p) &#123;<br>        ForwardIterator q = p; p = q; <span class="hljs-comment">// 可复制迭代器</span><br>        V v = *p; q = &amp;v;             <span class="hljs-comment">// 迭代器解引用得到 V 类型</span><br>        p++; ++p;                     <span class="hljs-comment">// 可以对迭代器进行 ++ 操作</span><br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;ForwardIterator&lt;ValueType&gt; Iter&gt; <span class="hljs-comment">// 使用模板 concept</span><br><span class="hljs-function">Iter <span class="hljs-title">find</span><span class="hljs-params">(Iter first, Iter last)</span></span>;<br></code></pre></td></tr></table></figure><p>和模板类型类似，concept 模板也能通过接受模板参数形成新的 concept，在这个例子中当作 find 与 int 数组使用，可以形成约束 <code>ForwardIterator&lt;int&gt;</code>。concept 也可以在定义时接受多个模板参数。</p><p>考虑通过派生的方式从已有的 concept 形成新的 concept，同样以标准库中迭代器的概念作为例子，定义随机访问迭代器最合适的方式是通过派生已有迭代器概念。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">concept</span> RandomAccessIterator&lt;ValueType T&gt; <br>    : ForwardIterator&lt;T&gt; &#123;<br>    <span class="hljs-built_in">constraints</span>(RandomAccessIterator p) &#123;<br>        --p; p--; p + <span class="hljs-number">1</span>; p[<span class="hljs-number">1</span>]; p - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当对模板函数进行重载时，可以提供一个毫无约束的普通版本，并提供一个带约束的版本，在重载决议时，被替换的具体类型如果满足约束将使用约束版本。这也被称为基于 concept 的重载，它可以替换传统上使用的 enable_if 或标签分发技术。</p><p>模板参数支持非类型参数，因此可以对非类型参数进行约束，例如要求传递的非类型参数为奇数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">concept</span> Odd &#123; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">constraints</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Odd % <span class="hljs-number">2</span>; &#125; &#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, Odd N&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> &#123; <span class="hljs-comment">/*...*/</span> &#125;;<br><br>Buffer&lt;<span class="hljs-type">int</span>, <span class="hljs-number">5</span>&gt; buffer; <span class="hljs-comment">// OK</span><br>Buffer&lt;<span class="hljs-type">int</span>, <span class="hljs-number">6</span>&gt; buffer; <span class="hljs-comment">// 不符合约束，编译错误</span><br></code></pre></td></tr></table></figure><h4 id="1-2-4-基于伪签名方案"><a href="#1-2-4-基于伪签名方案" class="headerlink" title="1.2.4 基于伪签名方案"></a>1.2.4 基于伪签名方案</h4><p>使用函数签名来表达约束存在的缺点是必须严格匹配签名，这样会导致过约束问题。我们是不是可以考虑同样使用签名方式来表达，但是又不会导致过约束呢？考虑使用伪签名方式，代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">concept</span> Element &#123;<br>    &lt;(Element, Element) -&gt; <span class="hljs-function"><span class="hljs-type">bool</span></span><br><span class="hljs-function">    <span class="hljs-title">swap</span><span class="hljs-params">(Element, Element)</span> -&gt; <span class="hljs-type">void</span></span><br><span class="hljs-function">&#125;</span>;<br></code></pre></td></tr></table></figure><p>上述代码引入了新的语法和新的语义，这要求符合 Element 约束的类型能够支持 operator&lt; 与 swap 操作，而不关心它们的形参是否为 const 或引用形式等。它与前一个方案的表达力相同。这两种方案基于同一思想，只是语法形式不同，论文中没有对这一方案进行过多的分析。</p><h4 id="1-2-5-设计目标"><a href="#1-2-5-设计目标" class="headerlink" title="1.2.5 设计目标"></a>1.2.5 设计目标</h4><p>Stroustrup 在对现有模板机制进行分析，以及对比当时支持泛型的编程语言，思考如何在 C++ 中更好地支持泛型编程技术，尝试从不同角度来处理 concept 的问题，并提出了 concept 的一些设计目标。下面的设计目标是按照优先级列出的，并不是所有的目标都需要满足。</p><ol><li>灵活性。在传统的面向对象编程范式中，通过接口来保证调用者与实现者之间的约定，而 concept 约束不应该显式指明类型，并且应该是非层次体系结构的。对于基础数据类型应该天然支持而不是采用变通方案。</li><li>模板检查。模板的定义不应该依赖于实际被替换的类型，而是检查 concept 中声明的要求，简而言之，模板应该依赖 concept 而不是实际类型。最好是在模板使用处就能进行检查，而无须看到定义。</li><li>友好、精确的错误信息。模板的编译错误信息应该比之前更加友好，尤其是受约束的模板。错误信息分为三类：检查模板的定义是否使用了 concept 中未声明的操作（无须使用模板）、被替换的实际类型是否符合要求（使用模板但无须看到模板定义）、实例化时的模板是否有无效表达式（使用模板且需要看到模板的定义）。</li><li>基于 concept 的模板特化、函数重载。能够定义一系列受约束的模板并根据实际的模板参数选择使用哪个模板。</li><li>无运行时开销。借助抽象类的手段很容易实现对模板参数的检查，但这是以失去一定的灵活性与运行时性能为代价实现的。concept 约束必须延续并增强编译时计算和内联能力，这是传统模板性能的根基。</li><li>对编译器实现友好。模板特性本身对于编译器而言非常难实现，concept 不应该比它们更难，另一方面 concept 应该会减轻编译器检查模板代码的难度。</li><li>向后兼容。即便引入新的语法，也不能对已有的模板代码产生冲击。</li><li>分离编译。这个想法可能需要像虚函数表那样来实现模板参数与模板实现的接口，从而做到独立编译。</li><li>简洁的语法，强大的表达力。约束应该简单明了地表达对模板参数的要求，并且能够利用逻辑关系将已有的 concept 组合成新的 concept。一个 concept 应该能够支持多个模板参数的输入，以便表达它们之间关系的要求。除了能够从语法的角度表达，还应该能够表达它们的语义。</li></ol><p>以上便是设计 concept 特性的所有目标，当然它们也存在矛盾的地方，比如基于 concept 的重载与分离编译这两点，一个是编译时目标，而另一个是运行时目标。</p><h3 id="1-3-2004-年（印第安纳提案与得克萨斯提案）"><a href="#1-3-2004-年（印第安纳提案与得克萨斯提案）" class="headerlink" title="1.3 2004 年（印第安纳提案与得克萨斯提案）"></a>1.3 2004 年（印第安纳提案与得克萨斯提案）</h3><p>2004 年，concept 特性出现了两大提案，分别被称为“印第安纳提案”与“得克萨斯提案”，它们分别对伪签名方案与基于表达式方案做出了更加深入的分析。</p><h4 id="1-3-1-印第安纳提案"><a href="#1-3-1-印第安纳提案" class="headerlink" title="1.3.1 印第安纳提案"></a>1.3.1 印第安纳提案</h4><p>该提案基于伪签名方案并提供如下的语法形式，它看上去和函数匹配方案类似，但是匹配要求没那么严格。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typeid</span> T&gt; <span class="hljs-comment">// 定义小于概念</span><br><span class="hljs-keyword">concept</span> LessThanComparable &#123;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(T x, T y);<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(T x, T y);<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typeid</span> T&gt; <span class="hljs-comment">// 对模板参数 T 进行约束，要求小于、拷贝</span><br>    where &#123; LessThanComparable&lt;T&gt;, CopyConstructible&lt;T&gt; &#125;<br><span class="hljs-function">T <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x, <span class="hljs-type">const</span> T&amp; y)</span> </span>&#123; <span class="hljs-comment">/*...*/</span> &#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，只要被替换后的实际类型支持 operator&lt; 和 operator&lt;&#x3D; 操作即可：不管是内建方式、还是自由函数方式或者成员函数，只要这两个操作符能够接受两个相同的类型并且返回类型为 bool 或者能够通过隐式类型转换成 bool 即可。</p><p>另一个值得注意的点是模板参数被声明为 typeid，笔者建议复用该关键字来区分受约束与未受约束的模板参数。引入新的关键字 where 来提高表达力。</p><p>通过使用派生语法并基于已有的 concept 创建新的作法，被称为概念改良（concept refinement）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typeid</span> Iter&gt; <span class="hljs-comment">// 由多个概念组合而成，复用它们的要求</span><br><span class="hljs-keyword">concept</span> InputIterator <br>    : CopyConstructible&lt;Iter&gt;, Assignable&lt;Iter&gt;<br>    , EqualityComparable&lt;Iter&gt; &#123; <span class="hljs-comment">/*...*/</span> &#125;<br></code></pre></td></tr></table></figure><p>定义 concept 时，能够对函数提供默认实现，从而减少被约束的类型所需要满足的函数数量。当被约束类型仅提供 operator&#x3D;&#x3D; 时，下述代码的概念会自动满足 operator!&#x3D; 的要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typeid</span> T&gt;<br><span class="hljs-keyword">concept</span> EqualityComparable &#123;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> T&amp;, <span class="hljs-type">const</span> T&amp;); <span class="hljs-comment">// 提供 operator!= 的默认实现</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> T&amp; x, <span class="hljs-type">const</span> T&amp; y) &#123; <span class="hljs-keyword">return</span> !(x == y); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在泛型类中有很多关联类型可供使用，例如 vector 会提供成员类型 value_type 来存储容器中每个元素的类型。同样地，定义 concept 时也可以要求一个类提供一些关联类型，并且能为某些关联类型提供默认值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typeid</span> G&gt;<br><span class="hljs-keyword">concept</span> Graph &#123; <span class="hljs-comment">// 要求模板参数 G 提供如下两个关联类型</span><br>    <span class="hljs-keyword">typename</span> edge;<br>    <span class="hljs-keyword">typename</span> vertex;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当定义一个概念时，会要求模板参数的关联类型也满足概念的要求，这时候可以使用 require 子句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typeid</span> X&gt;<br><span class="hljs-keyword">concept</span> Container &#123; <span class="hljs-comment">// 关联类型 X::iterator 需要满足概念 InputIterator</span><br>    require <span class="hljs-keyword">typename</span> X::iterator;<br>    require InputIterator&lt;X::iterator&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在设计层面上，该提案提出了一个显著的问题：结构一致性与名字一致性的问题，并通过对实际类型进行显式概念建模声明（explicit model declarations）的方式来解决，这也是该提案的特点。通常来说有两种方案可以确定类型是否符合接口（概念）的要求：结构一致性与名字一致性。</p><p>结构一致性仅依赖接口的内容，而不关心接口的名字。例如有两个不同名字的 concept，但是它们的要求（结构）是一样的，那么它们实际上是同一个接口。这种方式无须对实际类型进行声明是否实现接口，即可满足多个的要求，只要在模板参数被替换成实际类型时能够通过约束检查。前文介绍的几个方案都是这种形式。</p><p>名字一致性依赖于接口的名字，因此两个不同名的接口即便内容一样，它们也是不同的。这就要求对一个类型进行显式声明是否实现了接口，C++ 中的 subtype 使用了名字一致性的方式，显式声明一个类继承了另一个接口类。在泛型编程的术语中，名字一致性意味着显式建模，表明实际类型对概念进行建模。</p><p>之所以会出现这个问题，原因在于一个概念不仅需要从语法层面满足要求，还需要从语义层面满足要求。一个比较明显的例子是在标准模板库中输入迭代器与前向迭代器的概念，它们的定义（结构）是一样的，但语义不一样：前者只能迭代一轮，后者可以保证多轮迭代，仅从语法角度上无法区分两者。</p><p>那么结构一致性存在的可能是，实际类型既匹配输入迭代器也匹配前向迭代器，从语义角度而言输入迭代器不是前向迭代器，如果使用基于 concept 重载的函数，将可能决策出错误的重载实现。</p><p>如果使用名字一致性并对实际类型进行显式概念建模，就能够通过名字来实现对语义上的区分。比如声明 MyFileIterator 是一个输入迭代器，那么重载决议时仅使用输入迭代器的版本，不会出现实际类型符合语法但不符合语义的情况。</p><p><code>model InputIterator&lt;MyFileIterator&gt; &#123;&#125;; // 对实际类型进行概念建模声明</code></p><p>即使该类型不包含概念所需的函数定义，也可以对实际类型进行概念建模声明，因为能够通过 model 子句补充被要求的函数定义，从而满足概念。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123; <span class="hljs-type">int</span> x, y; &#125;<br>model EqualityComparable&lt;Point&gt; &#123;     <span class="hljs-comment">// 对 Point 显示概念建模</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Point&amp; rhs) <span class="hljs-comment">// 子句补充了所需的函数定义</span><br>    &#123; <span class="hljs-keyword">return</span> x == rhs.x &amp;&amp; y == rhs.y; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>名字一致性的另一个好处是提供了一种简单的机制来支持关联类型，只要用户对实际类型声明了概念建模，就无须再使用 type traits 方式访问关联类型。该方式也有利于编译器的实现。</p><p>结构一致性的好处在于无须开发者为每一个类型进行概念建模声明，这有助于将当前的泛型库过渡到基于概念的泛型库。可以借助编译器的帮助生成一些默认的声明来解决显式概念建模的问题。</p><h4 id="1-3-2-得克萨斯提案"><a href="#1-3-2-得克萨斯提案" class="headerlink" title="1.3.2 得克萨斯提案"></a>1.3.2 得克萨斯提案</h4><p>继印第安纳提案之后得克萨斯提案也诞生了，该提案对基于表达式使用方式做了进一步细化。通过列出一系列函数、操作符、关联类型的使用来定义一个 concept，如下是前向迭代器概念的定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">concept</span> ForwardIterator&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Iter</span>&gt; <span class="hljs-comment">// 对前向迭代器的要求</span><br>&#123;<br>    Iter p;                         <span class="hljs-comment">// 支持默认构造</span><br>    Iter q = p;                     <span class="hljs-comment">// 支持拷贝构造</span><br>    p = q;                          <span class="hljs-comment">// 支持赋值</span><br>    Iter&amp; q = ++p;                  <span class="hljs-comment">// 前自增，结果能够被引用</span><br>    <span class="hljs-type">const</span> Iter&amp; cq = p++;           <span class="hljs-comment">// 后自增</span><br>    <span class="hljs-type">bool</span> b1 = (p == q);             <span class="hljs-comment">// 判等，结果为 bool 或者能够隐式转换成 bool</span><br>    <span class="hljs-type">bool</span> b2 = (p != q);             <span class="hljs-comment">// 判不等</span><br>    ValueType Iter::value_type;     <span class="hljs-comment">// 拥有成员类型 value_type</span><br>    Iter::value_type v = *p;        <span class="hljs-comment">// 解引用，结果能够被赋 value_type 类型</span><br>    *p = v;                         <span class="hljs-comment">// value_type 类型的值能够被赋给解引用后的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>前向迭代器的概念定义直接从 C++ 标准中与前向迭代器相关的语法要求表而得。如果一个模板类型满足概念的所有要求，我们可以说该类型“匹配”对应的概念，印第安纳提案中使用的类似术语叫作“建模”。通常不使用术语“是一个”（is-a）来表达，因为这样会和类体系中的术语相混淆。</p><p>概念是一个编译期谓词，得克萨斯提案中通过使用静态断言可以判断具体类型是否匹配概念，若不匹配则编译报错。值得一提的是编译器可以缓存概念匹配的结果，供后续使用。</p><p><code>static_assert ForwardIterator&lt;int*&gt;; // 静态断言类型 int* 是否匹配前向迭代器概念</code></p><p>可惜的是上述断言将失败，因为指针类型没有成员类型 value_type，这不符合我们的预期。为了让基础数据类型也能够匹配概念，需要通过静态断言来对基础类型做扩展。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static_assert</span> <span class="hljs-keyword">template</span>&lt;ValueType T&gt; ForwardIterator&lt;T*&gt; &#123;<br>    <span class="hljs-keyword">typedef</span> T* pointer_type; <span class="hljs-comment">// 对 T* 类型拓展，定义关联类型 value_type 为 T</span><br>    <span class="hljs-keyword">typedef</span> T  pointer_type::value_type;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在印第安纳提案中提到，如果不通过显式建模声明的方式，会出现因为语法相同、语义不同而导致决策错误的问题，因此得克萨斯提案考虑使用否定断言（Negative assertions）的方式来解决，例如断言 MyIterator 虽然从语法上匹配前向迭代器，但从语义上不匹配。</p><p><code>static_assert ! ForwardIterator&lt;MyIterator&gt;;</code></p><p>因此，得克萨斯提案的静态断言有三个语义：第一、通过及早断言给定的类型是否匹配概念来及时发现错误；第二、通过对诸如基础数据类型进行扩展；第三、通过否定断言来声明指定类型不匹配概念。这样做可以避免为每个类型都显式建模声明。</p><h4 id="1-3-3-ConceptGCC"><a href="#1-3-3-ConceptGCC" class="headerlink" title="1.3.3 ConceptGCC"></a>1.3.3 ConceptGCC</h4><p>2005 年下半年，印第安纳提案的修订版本中移除了 typeid 关键字，它被替换成标准的关键字 typename。</p><p>与此同时 GCC 编译器基于印第安纳提案衍生出一个分支：ConceptGCC，这个原型项目至关重要，因为它是首个证明该提案可行的实现。然而这个过程中遇到了很多问题：实现赶不上标准制定的进展，存在非常多的 bug 并且编译速度慢，这些都使其很难用于大型泛型库中。</p><h3 id="1-4-2006-年（妥协）"><a href="#1-4-2006-年（妥协）" class="headerlink" title="1.4 2006 年（妥协）"></a>1.4 2006 年（妥协）</h3><p>Alexander Stepanov 于 2006 年邀请得克萨斯提案和印第安纳提案的团队参与 Adobe 公司举行的会议，旨在解决双方提案之间存在显著差异的问题，从而进一步在设计上达成一致。一些权衡的点主要包括采用伪签名模式还是依据表达式使用模式、使用哪种手段对 concept 进行组合、关于显式建模还是隐式匹配等。</p><p>两个团队经过数个月的合作并公布了折中方案，后由 Stroustrup 等人汇总并正式向 C++ 标准委员会提出提案，该提案的一些要点如下：</p><p>基于伪签名模式与依据表达式使用模式拥有等价的语义，两种方式应该能够相互转换，只是表现形式不一样，因此需要考虑其他方面的问题。尽管依据表达式模式很贴近文档中的约束描述，但是应该采用伪签名方式，原因是它的表现形式与类和类所需的成员函数具有相似性以及与显式建模声明子句的一致性。伪签名的另一个优势是容易构造原型类（archetypes），它是提供所需函数、成员以满足概念的最小类，在提案中便于对受约束的模板参数定义进行检查。</p><p>对模板类或模板函数使用约束时，拥有两种表现形式，分别是应对简单的场是与应对复杂的场景，在复杂的情况下可以使用逻辑关系来组合多个概念。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;Comparable T&gt; <span class="hljs-comment">// 简单的语法对应简单的场景</span><br><span class="hljs-function">T <span class="hljs-title">mymin</span><span class="hljs-params">(T a, T b)</span> </span>&#123; <span class="hljs-keyword">return</span> a &lt; b ? a : b; &#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// concept 的逻辑组合</span><br>    where &#123; Comparable&lt;T&gt; &amp;&amp; AnotherConcept&lt;T&gt; &#125;<br><span class="hljs-function">T <span class="hljs-title">mymin</span><span class="hljs-params">(T a, T b)</span> </span>&#123; <span class="hljs-keyword">return</span> a &lt; b ? a : b; &#125;<br></code></pre></td></tr></table></figure><p>在提案中提出了基于概念重载的规则来决策哪个可行函数更优的方式：受概念约束的重载比未受约束的更具体，同样受约束的多个概念逻辑组合关系的比较，例如 <code>A&lt;T&gt;</code> 与 <code>A&lt;T&gt; &amp;&amp; B&lt;T&gt;</code> 相比，根据规则后者将更具体。</p><p>关于显式建模还是隐式匹配的抉择也是个很大的问题。显式建模能够避免给定类型仅因为语义差别而导致误匹配概念的情况，但是它增加了简单场景的复杂度：需要大量的 model 声明语句，使得一个类型变得相当模糊。该提案给出的解决方案是将 concept 分成两种：一种是默认 concept 需要显式建模，而另一种是需要在 concept 定义前使用 auto 修饰来表明它可以隐式匹配。</p><p>由于显式建模的关键字 model 太过平凡，可能会与现存代码造成冲突，因此提案中将该关键字修改为 concept_map，它的子句中可以对不满足概念要求的指定类型进行补充扩展定义，从而满足概念要求。顾名思义，concept_map 可视作模板参数到指定类型的概念映射。</p><p>公理（axiom）表达了概念的语义要求，虽然编译器仅能检查语法要求，但是它可以提示编译器基于这些假设对类型做出优化。例如，某个概念要求类型的二元操作 op 符合结合律，那么编译器可能会将表达式 <code>op(x, op(y, z))</code> 等价替换成 <code>op(op(x, y), z)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">concept</span> Semigroup &lt;<span class="hljs-keyword">typename</span> Op, <span class="hljs-keyword">typename</span> T&gt; &#123;<br>    <span class="hljs-function">T <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Op, T, T)</span></span>; <span class="hljs-comment">// axiom 公理作为语义要求</span><br>    <span class="hljs-function">axiom <span class="hljs-title">Associativity</span><span class="hljs-params">(Op op, T x, T y)</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-built_in">op</span>(x, <span class="hljs-built_in">op</span>(y, z)) == <span class="hljs-built_in">op</span>(<span class="hljs-built_in">op</span>(x, y), z); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-5-2009-年（标准化投票）"><a href="#1-5-2009-年（标准化投票）" class="headerlink" title="1.5 2009 年（标准化投票）"></a>1.5 2009 年（标准化投票）</h3><p>Stroustrup 在 2009 年写了一篇论文，总结了标准委员会对 ConceptGCC 提案的担忧，他们担心这个特性对普通的 C++ 程序员来说太复杂了，所以决定简化设计。</p><p>其中一点是建议将默认的显式建模改成默认隐式匹配，并提出了相关手段，这样能够减少 concept_map 声明的数量，使得对普通程序员更加友好，但这一手段需要相当大的改动。</p><p>同年7月的法兰克福会议上，C++ 标准委员会对该特性进行投票，有如下选项。</p><ol><li>将当前的 concept 特性提案直接写入 C++0x 标准化。</li><li>根据 Stroustrup 的建议进行修改，并写入 C++0x 标准化。</li><li>从 C++0x 标准中移除该特性。</li></ol><p>标准委员会注意到当前设计的缺点并将投票分成第二、第三个选项。然而大多数人选择了更安全的选项：从当前标准中移除该特性。因为时间相当紧张，离第一个标准 C++98 已经过去了近二十年，如果对concept特性进行修改将进一步推迟 C++ 的标准化进程。此外，更多人担心的是 ConceptGCC 的运行效率太低了，最后委员会决定延期到下一个标准中。参与到 concept 开发的成员们虽然都很失望，但他们更愿意提供一个高质量的解决方案。</p><h3 id="1-6-2013-年轻量级概念（conceptslite）"><a href="#1-6-2013-年轻量级概念（conceptslite）" class="headerlink" title="1.6 2013 年轻量级概念（conceptslite）"></a>1.6 2013 年轻量级概念（conceptslite）</h3><p>在 concept 特性未能进入 C++11(C++0x) 标准后，相关人员不仅简化了设计，而且改变了开发的方式。考虑到一次性将如此复杂的特性融入语言的困难程度，Stroustrup 和他的同事们专注于 concept 设计的第一部分：模板参数约束，这也在后来被称为轻量级概念，使用谓词来约束模板参数。</p><p>轻量级概念仅检查被约束的模板是否使用正确，而不检查模板的定义是否正确。换句话说，模板的定义可以使用概念要求之外的操作。它的目的是让程序员简单、轻松地接受并使用。它仅满足如下目标：</p><ol><li>允许程序员直接将声明一组模板参数的要求作为模板接口的一部分。</li><li>支持基于 concept 的函数重载与模板类特化。</li><li>明确模板使用时检查模板参数的诊断信息。</li><li>无任何运行时开销，且能提高编译速度。</li></ol><p>值得一提的是，GCC 编译器在设计报告编写时已经完成了大部分目标与实现，并且包含了配套使用 concept 的标准库。</p><p>轻量级概念定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">concept</span> <span class="hljs-type">bool</span> <span class="hljs-title">EqualityComparable</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">requires</span>(T a, T b) &#123;<br>        &#123;a == b&#125; -&gt; <span class="hljs-type">bool</span>;<br>        &#123;a != b&#125; -&gt; <span class="hljs-type">bool</span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以发现 concept 的定义发生了变化，它相当于 constexpr 谓词函数，能够在编译时求值，原型要求返回类型为 bool 的无参函数。</p><p>同时引入了 requires 表达式，它提供了可以简明表示表达式是否合法和关联的类型是否满足要求的能力。requires 表达式能够声明一些参数，然后罗列这些参数的表达式来判断其是否符合要求。这个例子中通过声明模板类型T的两个实例 a 和 b，并通过表达式 a&#x3D;&#x3D;b 来判断它们是否能够判等，并且最终判等的结果是否为 bool。</p><p>当实例化时若这些表达式无效，则 requires 表达式最终结果为 false，表明模板参数不满足要求。在这个设计报告中使用了基于表达式使用的方式而不是伪签名方式，它的一个优势在于能够根据标准库的文档代码样例简单地转换成概念的定义。此外，基于表达式使用的方式比伪签名更加抽象，它们表达更多的是如何（How）使用而不是提供什么（What）签名，这使得程序员能够写出更加通用的代码。</p><p>接着看看概念的使用，同样提供了两种方式分别应对简单与复杂的场景，使用 requires 子句来表达多个概念的逻辑组合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;FloatingPoint T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>; <span class="hljs-comment">// 概念的简单使用</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 概念的复杂场景，使用 requires 子句组合</span><br>    <span class="hljs-keyword">requires</span> <span class="hljs-built_in">Same</span>&lt;T, <span class="hljs-type">float</span>&gt;() || <span class="hljs-built_in">Same</span>&lt;T, <span class="hljs-type">double</span>&gt;() || <span class="hljs-built_in">Same</span>&lt;T, <span class="hljs-type">long</span> <span class="hljs-type">double</span>&gt;()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>;<br></code></pre></td></tr></table></figure><p>如上两种方式是等价的，前者使用概念 FloatingPoint 来约束模板参数，而后者使用 requires 对三个 Same 概念进行组合约束。</p><p>对于模板类型可以基于概念的特化实现，考虑如下例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;Arithmetic T&gt;    <span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>;<br><span class="hljs-keyword">template</span> &lt;FloatingPoint T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&lt;T&gt; &#123; <span class="hljs-comment">/*...*/</span> &#125;;<br><span class="hljs-keyword">template</span> &lt;Integral T&gt;      <span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&lt;T&gt; &#123; <span class="hljs-comment">/*...*/</span> &#125;;<br></code></pre></td></tr></table></figure><p>上述代码声明了一个模板类型 complex，将模板参数约束为数值类型，既可以是浮点类型也可以是整数类型，接着分别对浮点类型和整数类型进行特化，当用户使用 <code>complex&lt;int&gt;</code> 时将使用 Integral 概念约束的特化版本。</p><p>设计报告没有使用显式建模 concept_map 方案，而是隐式匹配方案。同样地，这种方案也面临着语法相同、语义不同而导致的 concept 无法区分的情况。目前的变通方案是将语义要求的差异转换成语法上的差异，以此进行区分。</p><h3 id="1-7-2015-年（ConceptsTS）"><a href="#1-7-2015-年（ConceptsTS）" class="headerlink" title="1.7 2015 年（ConceptsTS）"></a>1.7 2015 年（ConceptsTS）</h3><p>C++14 的目标是完成 C++11 的特性并修复一些已知问题，concept 没有足够的时间进入 C++14 标准，标准委员会决定为该特性单独编写一份技术规范文档（TechnicalSpecification，TS）。</p><p>2012 年，标准委员会的工作方式发生了变化，其主要工作独立于标准制定，并行地以技术规范形式交付，随后可以纳入标准。这种工作方式允许标准委员会能够快节奏、可预测地交付。Concepts TS 形成了最终的技术规范，在 GCC 编译器中能够使用选项 -fconcepts 来使用该特性。</p><h3 id="1-8-2016-年（C-17）"><a href="#1-8-2016-年（C-17）" class="headerlink" title="1.8 2016 年（C++17）"></a>1.8 2016 年（C++17）</h3><p>轻量级概念本应该进入 C++17 标准，但最终未能实现。由于社区存在两种声音，有支持的也有反对的，对立双方的论点如下。</p><p>支持的声音是，模板参数约束（即便只检查模板的使用而不是定义）正是程序员想要的：它拥有友好的报错信息、文档、表现形式与重载。在各种各样的项目中都已经验证了轻量级概念，仅有少量问题。而且它在学术演讲中也得到了积极的响应，此外，程序员等待该特性实在太久了，由于缺乏 concept 的支持，导致各种各样的类 concept 库被开发，并产生了一系列变通方法。</p><p>反对的声音是，目前缺乏基于 concept 支持的标准库，仅仅拥有语言特性仍不足够。在不借助基础概念支持的情况下很难去编写一个高质量的库。甚至负责新的标准模板库开发的专家们也遇到了如何建立可靠概念体系的问题。另外，轻量级概念只是整个 concept 特性的第一部分，后续部分需要对第一部分的设计进行修改，加上最终的技术标准刚落地，目前只有 GCC 这一个编译器实现了概念特性，而语法上还存在一些问题。</p><p>所以标准委员会在 2016 年决定再次延后 concept 的标准化。</p><h3 id="1-9-2020-年（C-20）"><a href="#1-9-2020-年（C-20）" class="headerlink" title="1.9 2020 年（C++20）"></a>1.9 2020 年（C++20）</h3><p>随后，概念的语法经过了一些精简。首先，concept 为编译时概念谓词，那么指明返回类型为 bool 则有些多余。其次，concept 的定义不再是一个类 constexpr 模板函数，而是变成了模板变量的形式。标准库的一些 concept 命名风格也发生了变化，例如 View 被命名为 view。千呼万唤始出来，轻量级概念终于进入了 C++20 标准。</p><h3 id="1-10-小结"><a href="#1-10-小结" class="headerlink" title="1.10 小结"></a>1.10 小结</h3><p>概念的目标非常简单：提供接口约束模板参数。然而随着对概念特性的开发在这一过程中也产生了许多问题，即使通过技术规范的工作方式集中于轻量级概念，依然存在问题。这表明了语言设计师必须时刻意识到项目中可能存在的困难与风险。</p><p>另外，是为设计负责。在不考虑后果的情况下轻易创造、修改设计是不明智的，还有对于新特性的开发很难预见所有决策的后果。这种风险和项目类型有关，如果是小项目，那么能够接受试错成本；而在复杂的大型项目中，错误的决策将导致不可逆转的结果。语言设计师应尽最大的努力来避免这种灾难性的决定。</p><p>方案的多样性也是有价值的，对于印第安纳提案与得克萨斯提案而言，它们提供了不同的思路来解决同一问题，并且一起改善了提案；缺少编译器实现（最初仅 GCC 编译器实现）上的多样性导致了概念被延期进入标准。因此，面对与讨论不同的方案以及进行广泛的测试验证是有价值的。</p><h2 id="第-2-章-C-20-标准的概念特性"><a href="#第-2-章-C-20-标准的概念特性" class="headerlink" title="第 2 章 C++20 标准的概念特性"></a>第 2 章 C++20 标准的概念特性</h2><h3 id="2-1-定义概念"><a href="#2-1-定义概念" class="headerlink" title="2.1 定义概念"></a>2.1 定义概念</h3><p>这里正式给 concept 下定义，它是一个对类型约束的编译期谓词，给定一个类型判断其能否满足语法和语义要求，这对泛型编程而言极为重要。举个例子，给定模板参数 <code>T</code>，对它的要求如下。</p><ol><li>一种迭代器类型 <code>Iterator&lt;T&gt;</code>。</li><li>一种数字类型 <code>Number&lt;T&gt;</code>。</li></ol><p>符号 <code>C&lt;T&gt;</code> 中的 <code>C`` 就是概念，</code>T<code>是一个类型，它表达“如果</code>T<code>满足</code>C&#96; 的所有要求，那么为真，否则为假。”</p><p>类似地，我们能够指定一组模板参数来满足概念的要求，例如 <code>Same&lt;T, U&gt;</code> 概念可定义为类型 <code>T</code> 与 <code>U</code> 相等。这种多类型概念对于 STL 来说是必不可少的，同时也能应用于其他领域中。</p><p>concept 拥有强大的表达力并且对编译时间友好，程序员能够通过非常简单地定义一个概念，也可以借助概念库对已有的概念进行组合。概念支持重载，能够消除对变通方案（诸如 enable_if 等技巧）的依赖，因此不仅大大降低了元编程的难度，同时也简化了泛型编程。在 C++ 中定义一个 concept 的语法为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;被约束的模板参数列表&gt;<br><span class="hljs-keyword">concept</span> 概念名 = 约束表达式;<br></code></pre></td></tr></table></figure><p>概念被定义为约束表达式（constraint-expression），也可以简单理解成布尔常量表达式。在实现一些简单的概念时可以复用在标准库 <code>&lt;type_traits&gt;</code> 中的组件，它们是编译时查询类型特征的接口，在配套的概念标准库 <code>&lt;concepts&gt;</code> 中可以看到一些和数值相关的概念被定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> integral = is_integral_v&lt;T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> floating_point = is_floating_point_v&lt;T&gt;;<br></code></pre></td></tr></table></figure><p>这种简单的概念定义能否不依托于 type traits 呢？答案是可能不行，根据 C++20 标准，概念不允许做特化且约束表达式在定义时处于不求值环境中，因此除了 type traits 之外没有更好的方式了。</p><p>概念和模板 using 的别名很类似，前者是对布尔表达式的别名，而后者是对模板类型的别名，它们都不允许自身进行实例化或特化。记住这个有助于对后文介绍的约束偏序规则的理解。</p><p>在判断类型是否满足概念时，编译器将会对概念定义的约束表达式进行求值，因此可以通过静态断言来检测类型是否满足。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">static_assert</span>( floating_point&lt;<span class="hljs-type">float</span>&gt;); <span class="hljs-comment">// 对约束表达式 is_floating_point_v 进行求值</span><br><span class="hljs-built_in">static_assert</span>(!floating_point&lt;<span class="hljs-type">int</span>&gt;);<br></code></pre></td></tr></table></figure><p>如果在定义概念时约束表达式类型不为 bool 类型，将引发一个编译错误，而不是返回不满足（假）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// atomic constraint must be of type &#x27;bool&#x27; (found &#x27;int&#x27;)</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">concept</span> Foo = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>约束表达式通过逻辑操作符的方式进行组合以定义更复杂的概念，这种操作符有两种：合取（conjunction）与析取（disjunction），C++ 标准中使用符号 ∧ 来代表合取操作，符号 ∨ 代表析取操作。</p><p>由于在 C++ 语法中并没有定义这两个符号，而是复用逻辑与（&amp;&amp;）和逻辑或（||）来分别表达合取与析取，那么它们在约束表达式中的语义相对布尔运算也就有了细微区别。</p><p>约束的合取表达式由两个约束组成，判断一个合取是否满足要求，首先要对第一个约束进行检查，如果它不满足，整个合取表达式也不满足；否则，当且仅当第二个约束也满足时，整个表达式满足要求。</p><p>约束的析取表达式同样由两个约束组成，判断一个析取是否满足要求，首先对第一个约束进行检查，如果它满足，整个析取表达式满足要求；否则，当且仅当第二个约束也满足时，整个表达式满足要求。</p><p>合取与析取操作与逻辑表达式中的与或运算类似，也是一个短路操作符。在依次对每个约束进行检查时，首先检查表达式是否合法，若不合法则该约束不满足，否则进一步对约束进行求值判断是否满足。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 析取表达式 is_integral_v&lt;T::type&gt; ∨ sizeof(T) &gt; 1</span><br><span class="hljs-keyword">concept</span> C = is_integral_v&lt;<span class="hljs-keyword">typename</span> T::type&gt; || (<span class="hljs-built_in">sizeof</span>(T) &gt; <span class="hljs-number">1</span>);<br><span class="hljs-built_in">static_assert</span>(C&lt;<span class="hljs-type">double</span>&gt;);<br></code></pre></td></tr></table></figure><p>对 <code>C&lt;double&gt;</code> 进行求值的过程中，模板类型参数T被替换为 double，整个约束表达式为 <code>is_integral_v&lt;double::type&gt; ∨ sizeof(double) &gt; 1</code>，显然第一个约束的表达式非法，结果为不满足要求，然而第二个表达式满足要求，因此整个结果为真。</p><p>对于可变参数模板形成的约束表达式，既不是约束合取也不是约束析取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... TS&gt;<br><span class="hljs-keyword">concept</span> C = (is_integral_v&lt;<span class="hljs-keyword">typename</span> Ts::type&gt; || ...);<br></code></pre></td></tr></table></figure><p>上述代码不是析取表达式，因此没有短路操作，它首先检查整个表达式是否合法，只要有一个模板参数没有类型成员 <code>type</code>，整个表达式将为假。若要表达“至少一个模板参数存在类型成员 <code>type</code> 且类型成员为整数”，则可以添加一层间接层解决：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 额外的间接层</span><br><span class="hljs-keyword">concept</span> IntegralWithNestType = is_integral_v&lt;<span class="hljs-keyword">typename</span> T::type&gt;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-keyword">concept</span> C = (IntegralWithNestType&lt;Ts&gt; || ...);<br></code></pre></td></tr></table></figure><p>由于约束表达式使用的合取与析取操作符分别与逻辑表达式的逻辑与和逻辑或相同，若要表达“逻辑表达式”的合法性，而不是被当成析取或合取表达式处理则需要额外的工作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt; <span class="hljs-comment">// 约束析取表达式</span><br><span class="hljs-keyword">concept</span> C1 = is_integral_v&lt;<span class="hljs-keyword">typename</span> T::type&gt; || is_integral_v&lt;<span class="hljs-keyword">typename</span> U::type&gt;;<br><br><span class="hljs-keyword">template</span> &lt;typanme T, <span class="hljs-keyword">typename</span> U&gt; <span class="hljs-comment">// 原子约束</span><br><span class="hljs-keyword">concept</span> C2 = <span class="hljs-built_in">bool</span>(is_integral_v&lt;<span class="hljs-keyword">typename</span> T::type&gt; || is_integral_v&lt;<span class="hljs-keyword">typename</span> U::type&gt;);<br></code></pre></td></tr></table></figure><p>概念 <code>C1</code> 中的约束表达式为析取表达式，它具有短路性质，表达“要求存在一个模板参数拥有类型成员 <code>type</code> 且类型成员为整数”，而 <code>C2</code> 表达了一条完整的逻辑表达式：“要求两个模板参数存在类型成员 <code>type</code> 且其中一个为整数”。</p><p>另一个比较特殊的是逻辑否定（negation），在对概念进行求值的过程中，若约束中的模板参数替换发生错误（表达式非法），则该约束的结果为不满足。考虑如下情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">concept</span> C1 =  is_integral_v&lt;<span class="hljs-keyword">typename</span> T::type&gt;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">concept</span> C2 = !is_integral_v&lt;<span class="hljs-keyword">typename</span> T::type&gt;;<br><br><span class="hljs-built_in">static_assert</span>(!C1&lt;<span class="hljs-type">int</span>&gt;);<br><span class="hljs-built_in">static_assert</span>(!C2&lt;<span class="hljs-type">int</span>&gt;);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123; <span class="hljs-keyword">using</span> type = <span class="hljs-type">float</span>; &#125;;<br><span class="hljs-built_in">static_assert</span>(C2&lt;Foo&gt;);<br></code></pre></td></tr></table></figure><p>其中 <code>C1</code> 表达式“要求类型 <code>T</code> 存在关联类型 <code>type</code>，且关联类型为整数类型”，<code>C1</code> 的否定“要求类型 <code>T</code> 不存在关联类型 <code>type</code>，或关联类型不为整数”。</p><p>根据约束否定的特殊性质，<code>C2</code> 并不是 <code>C1</code> 的否定，它表达的是“要求类型 <code>T</code> 存在关联类型 <code>type</code>，且关联类型不为整数类型”，在断言 <code>C2&lt;Foo&gt;</code> 和 <code>C2&lt;int&gt;</code> 时我们可以确认这一点。</p><p>如果需要表达 <code>C1</code> 的否定“要求类型 <code>T</code> 不存在关联类型 <code>type</code>，或关联类型不为整数”，应该定义为如下形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">concept</span> C3 = !C1&lt;T&gt;;<br><span class="hljs-built_in">static_assert</span>(C3&lt;Foo&gt;);<br><span class="hljs-built_in">static_assert</span>(C3&lt;<span class="hljs-type">int</span>&gt;);<br></code></pre></td></tr></table></figure><h3 id="2-2-requires-表达式"><a href="#2-2-requires-表达式" class="headerlink" title="2.2 requires 表达式"></a>2.2 requires 表达式</h3><p>除了使用 type traits 来定义概念之外，requires 表达式也提供了一种简明的方式来表达对模板参数及其对象的特征要求：成员函数、自由函数、关联类型等。在 C++ 中定义 requires 表达式的语法为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">requires</span> (可选的形参列表) &#123; <span class="hljs-comment">// 表达式体，提出要求</span><br>    一系列表达式（要求）<br>&#125;<br></code></pre></td></tr></table></figure><p>requires 表达式的结果为 bool 类型，即编译时谓词。表达式体应至少提出一条要求，同样地在表达式体中处于不求值环境。当对 requires 表达式进行求值时，按照表达式体中声明的先后顺序依次检查表达式的合法性，当遇到一条非法的表达式时，返回结果为不满足（假），与短路类似的后续表达式也无须进一步检查；当所有表达式都合法时，返回的结果为满足（真）。</p><p>可选的形参列表声明了一系列局部变量，这些局部变量不允许提供默认参数，它们对整个表达式体可见。这些变量没有链接性、存储性与生命周期，仅仅用作提出要求时的符号。如果在表达式体中引用了未声明的符号，则视作语法错误。</p><p>requires 表达式提供了四种形式的要求：简单要求、类型要求、复合要求与嵌套要求，它们分别应对不同场景。</p><h4 id="2-2-1-简单要求"><a href="#2-2-1-简单要求" class="headerlink" title="2.2.1 简单要求"></a>2.2.1 简单要求</h4><p>对于简单的要求，仅仅通过表达式就能表达。考虑定义一个机器的概念，能够上电与下电。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> M&gt;<br><span class="hljs-keyword">concept</span> Machine = <span class="hljs-built_in">requires</span>(M m) &#123;<br>    m.<span class="hljs-built_in">powerUp</span>();   <span class="hljs-comment">// 需要存在的成员函数</span><br>    m.<span class="hljs-built_in">powerDown</span>(); <span class="hljs-comment">// powerUp/powerDown</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里涉及两个特性，首先通过 concept 定义机器概念，其次约束表达式为 requires 表达式，它声明了模板参数 <code>M</code> 的局部对象 <code>m</code>，然后在表达式体中提出了两个要求，分别是能够使用对象的上下电接口。</p><p>对约束表达式求值的过程中并不会去创建对象，因此我们可以使用简单的值语义，而无须添加额外的引用或者指针形式，这样代码更简洁。此外也不会进行接口调用，仅仅是依据表达式是否合法来确认是否满足要求。</p><p>有时候我们要求模板参数的对象含有相关的自由函数，以及含有静态成员函数，或者成员变量，这些要求都可以通过下面这种形式来表达。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Animal = <span class="hljs-built_in">requires</span>(T a, T b, T c) &#123;<br>    <span class="hljs-built_in">play</span>(animal);      <span class="hljs-comment">// 要求存在自由函数 play</span><br>    T::count;          <span class="hljs-comment">// 存在静态成员 count</span><br>    animal.age;        <span class="hljs-comment">// 要求存在成员变量 age</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>又或者需要进行复杂的操作符运算时，可以声明几个对象，并在提出要求的同时表达对象之间的操作。目的只是检查表达式的合法性，不会去进行真正的计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Number = <span class="hljs-built_in">requires</span>(T a, T b, T c) &#123;<br>    a == a;     <span class="hljs-comment">// 要求对象能进行判等操作</span><br>    a + b * c;  <span class="hljs-comment">// 要求对象能够进行加、乘操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-类型要求"><a href="#2-2-2-类型要求" class="headerlink" title="2.2.2 类型要求"></a>2.2.2 类型要求</h4><p>简单要求虽然可以表达对象的成员函数、成员变量，但无法表达对象的类成员。类型要求可以表达一个类型是否含有成员类型，该类型是否能够和其他模板类型组合等。考虑如下情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> C = <span class="hljs-keyword">requires</span> &#123;<br>    <span class="hljs-keyword">typename</span> T::type;    <span class="hljs-comment">// 要求存在类型成员 type</span><br>    <span class="hljs-keyword">typename</span> vector&lt;T&gt;;  <span class="hljs-comment">// 要求能够与 vector 组合，能够模板实例化</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123; <span class="hljs-keyword">using</span> type = first; &#125;;<br><span class="hljs-built_in">static_assert</span>(C&lt;Foo&gt;);<br></code></pre></td></tr></table></figure><p>这段代码中的 requires 表达式无须引入局部变量，直接对类型提出要求即可。表达式体中使用关键字 typename 来表达它是一个类型要求。</p><h4 id="2-2-3-复合要求"><a href="#2-2-3-复合要求" class="headerlink" title="2.2.3 复合要求"></a>2.2.3 复合要求</h4><p>有时候我们会希望一个表达式的类型也能够符合要求，例如要求函数的返回类型为 int，希望表达式不会抛异常等，这时候可以使用复合要求来表达。复合要求的语法如下。</p><p><code>&#123; 表达式 &#125; 可选的 noexcept，可选的返回类型概念要求</code></p><p>复合要求需要用大括号将表达式括起来，最简单的复合要求和简单要求几乎没什么区别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> M&gt;<br><span class="hljs-keyword">concept</span> Machine = <span class="hljs-built_in">requires</span>(M m) &#123;<br>    &#123; m.<span class="hljs-built_in">powerUp</span>() &#125;;   <span class="hljs-comment">// 需要存在成员函数</span><br>    &#123; m.<span class="hljs-built_in">powerDown</span>() &#125;; <span class="hljs-comment">// powerUp/powerDown</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如果要求表达式不能抛异常，这时候 <code>noexcept</code> 关键字便派上了用场。考虑定义一个概念 <code>Movable</code>，要求对象之间的移动禁止抛异常。当用户自定义移动赋值操作符而忘记声明 <code>noexcept</code> 时，将无法通过约束的检查。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Movable = <span class="hljs-built_in">requires</span>(T a, T b) &#123;<br>    &#123; a = std::<span class="hljs-built_in">move</span>(b) &#125; <span class="hljs-keyword">noexcept</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们对一个表达式的类型提出要求时，有两个问题需要考虑。首先，是明确要求为某个确定的类型；其次，是由于在 C++ 中允许类型转换，对表达式的类型要求可以稍微放宽，只要能隐式转换到要求的类型即可。</p><p>C++ 标准库 <code>&lt;concepts&gt;</code> 提供了两个概念 <code>same_as</code> 和 <code>convertible_to</code> 来分别表达这两种情况，它们的声明如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">concept</span> same_as = <span class="hljs-comment">/*...*/</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _From, <span class="hljs-keyword">typename</span> _To&gt;<br><span class="hljs-keyword">concept</span> convertible_to = <span class="hljs-comment">/*...*/</span>;<br></code></pre></td></tr></table></figure><p>借助这两个概念的帮助，我们可以定义如下的概念。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> C = <span class="hljs-built_in">requires</span>(T x) &#123;<br>    &#123; <span class="hljs-built_in">f</span>(x) &#125; -&gt; same_as&lt;T&gt;;             <span class="hljs-comment">// 要求 f(x) 的返回类型与 x 类型一致</span><br>    &#123; <span class="hljs-built_in">g</span>(x) &#125; -&gt; convertible_to&lt;<span class="hljs-type">double</span>&gt;; <span class="hljs-comment">// 要求 g(x) 的返回类型能够转换成 double</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>使用箭头“-&gt;”来表达对表达式类型的要求，后面紧接着的是需要满足的概念。值得注意的是，这两个概念本应该接受两个模板类型参数，为何这里只需要提供一个？其实这是 concept 的性质，它会将表达式的类型补充到概念的第一个参数，如果读者将 <code>same_as</code> 替换成元函数 <code>is_same_v</code> 那么编译时将提示需要提供两个类型参数。上述代码等价于如下形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> C = <span class="hljs-built_in">requires</span>(T x) &#123;<br>    <span class="hljs-built_in">f</span>(x); <span class="hljs-keyword">requires</span> same_as&lt;<span class="hljs-keyword">decltype</span>((<span class="hljs-built_in">f</span>(x))), T&gt;;<br>    <span class="hljs-built_in">g</span>(x); <span class="hljs-keyword">requires</span> convertible_to&lt;<span class="hljs-keyword">decltype</span>((<span class="hljs-built_in">g</span>(x))), <span class="hljs-type">double</span>&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>细心的读者会发现 requires 表达式体中又出现了 requires 关键字，这正是下一小节将介绍的嵌套要求。</p><h4 id="2-2-4-嵌套要求"><a href="#2-2-4-嵌套要求" class="headerlink" title="2.2.4 嵌套要求"></a>2.2.4 嵌套要求</h4><p>除了前面几种要求，最后一种是嵌套要求，它在表达式体中通过 requires 连接一个编译时常量谓词来表达额外的约束。根据定义，嵌套要求的额外约束有如下几种形式。</p><ul><li>type traits。</li><li>concept。</li><li>requires 表达式。</li><li>constexpr 值或函数。</li></ul><p>requires 表达式体通常只检查表达式的合法性，而嵌套要求的谓词约束则通过对表达式求值来确认是否满足要求。在 2.2.3 节中我们不仅要求 <code>f(x)</code> 表达式有效，还通过 <code>requires same_as&lt;decltype（f(x)）, T&gt;</code> 嵌套要求 <code>same_as</code> 的概念为真。</p><p>通过嵌套要求定义一个概念，它要求给定的类型大小大于指针大小，并且是平凡的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> C = <span class="hljs-keyword">requires</span> &#123; <span class="hljs-comment">// 使用嵌套要求连接编译期谓词</span><br>    <span class="hljs-keyword">requires</span> <span class="hljs-built_in">sizeof</span>(T) &gt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*);<br>    <span class="hljs-keyword">requires</span> is_trivial_v&lt;T&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-2-5-注意事项"><a href="#2-2-5-注意事项" class="headerlink" title="2.2.5 注意事项"></a>2.2.5 注意事项</h4><p>本小节介绍 requires 表达式的一些特殊性质，以及使用的时候需要注意的地方。requires 表达式为编译时谓词，它不一定需要在 concept 定义的时候出现，只要是能够接受布尔表达式的地方都允许它的存在。</p><p>最容易想到的是在定义变量模板的时候，判断给定类型是否存在成员函数 swap。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> has_member_swap = <span class="hljs-built_in">requires</span>(T a, T b) &#123;<br>    a.<span class="hljs-built_in">swap</span>(b);<br>&#125;;<br></code></pre></td></tr></table></figure><p>requires 表达式难道只能对模板参数或者其对象提出要求么？如果对具体类型提出要求又会怎么样？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> has_int_member_swap = <span class="hljs-built_in">requires</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>    a.<span class="hljs-built_in">swap</span>(b); <span class="hljs-comment">// member reference base type &#x27;int&#x27; is not a structure or union</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>从设计角度来看。requires 表达式是服务于模板参数约束的，结果是编译错误而不是返回不满足（假）。除了支持类模板参数外，它还支持非类型模板参数，考虑定义一个偶数概念，要求输入的模板参数为偶数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">size_t</span> N&gt;<br><span class="hljs-keyword">concept</span> Even = <span class="hljs-keyword">requires</span> &#123;<br>    <span class="hljs-built_in">requires</span> (N % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>在模板函数 <code>if constexpr</code> 中，也有可能出现 requires 表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clever_swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">requires</span>(T a, T b) &#123; a.swap(b); &#125;)</span> </span>&#123;<br>        a.<span class="hljs-built_in">swap</span>(b);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">using</span> std::swap;<br>        <span class="hljs-built_in">swap</span>(a, b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了以上场景外，还有很多地方能够接受布尔表达式，例如非类型模板参数中，定义 constexpr 谓词函数时，<code>static_assert</code> 中，实现 type traits 时，还有后面将介绍的 requires 子句等。一个容易混淆的地方是简单要求与嵌套要求中对布尔表达式的约束，考虑如下两种形式的差异。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">requires</span> &#123;<br>    布尔表达式; <span class="hljs-comment">// 只检查表达式的合法性</span><br>    <span class="hljs-keyword">requires</span> 布尔表达式; <span class="hljs-comment">// 在合法性基础上求值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果用户写了如下代码，那么很可能违背约束条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">requires</span> &#123; <span class="hljs-comment">// 永远满足</span><br>    <span class="hljs-built_in">sizeof</span>(T) &lt;= <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>用户可能要求模板类型 T 的大小不应该超过 int 的大小，然而从编译器的角度来看，这仅仅是检查表达式的合法性，对 sizeof 的结果进行比较是永远满足的。想达成用户的意图应该是用嵌套要求，让编译器进一步对这个布尔表达式进行求值判断以查看其是否满足。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">requires</span> &#123; <span class="hljs-comment">// 对布尔表达式进行求值</span><br>    <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">sizeof</span><span class="hljs-params">(T)</span> &lt;</span>= <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个容易出错的地方在于嵌套要求可以接受一个 requires 表达式，考虑如下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">requires</span> (T v) &#123; <span class="hljs-comment">// 仅仅检查如下 requires 表达式是否合法</span><br>    <span class="hljs-built_in">requires</span> (<span class="hljs-keyword">typename</span> T::value_type x) &#123; ++x; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过分析会发现，以上代码表达式体中的 requires 并不是表达嵌套要求，而是简单要求形式，仅仅检查了表达式体中的 requires 表达式是否合法。好在 C++ 标准不接受这种代码，只要是以 requires 开头的代码都会被当作嵌套要求处理，其后还紧接着一个编译时谓词；现有的编译器实现也会对该代码报错。这时需要通过添加 requires 前缀进一步表达嵌套要求，具体代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">requires</span> (T v) &#123; <span class="hljs-comment">// 嵌套要求，接受一个 requires 表达式</span><br>    <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span> <span class="hljs-params">(<span class="hljs-keyword">typename</span> T::value_type x)</span> </span>&#123; ++x; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后一个需要注意的地方是，requires 表达式的可选形参列表中可能涉及非法表达式的问题，考虑如下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 若不存在关联类型 value_type 则编译错误</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> P = <span class="hljs-built_in">requires</span>(<span class="hljs-keyword">typename</span> T::value_type v) &#123; ++v; &#125;;<br></code></pre></td></tr></table></figure><p>形参 v 是否有效取，决于类型 T 是否含有类型成员 value_type，在形参无效的情况下，requires 表达式是否应该返回不满足（假）？根据 C++ 标准提到，编译器仅检查 requires 表达式体中的表达式要求是否合法，如果形参列表中的表达式非法，那么程序非良构，所以上述代码将产生一个编译错误。</p><p>如果使用 concept 定义，那么在可选的形参无效的情况下，requires 表达式将返回假，不过这是 concept 的特殊性质，和 requires 表达式无关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 若不存在关联类型 value_type 则编译错误</span><br><span class="hljs-keyword">concept</span> P = <span class="hljs-built_in">requires</span>(<span class="hljs-keyword">typename</span> T::value_type v) &#123; ++v; &#125;;<br></code></pre></td></tr></table></figure><h3 id="2-3-requires子句"><a href="#2-3-requires子句" class="headerlink" title="2.3 requires子句"></a>2.3 requires子句</h3><p>我们通过 concept、requires 表达式、constexpr 谓词常量或函数及 type traits 能够定义对类型的谓词，本节将介绍如何应用这些编译期谓词对模板参数添加约束，所有可以用来实例化这个模板的参数都必须满足这些约束。</p><p>使用 requires 子句可以为一个模板类或者模板函数添加约束，考虑如下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">requires</span> is_integral_v&lt;T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">gcd</span><span class="hljs-params">(T a, T b)</span></span>;<br><br><span class="hljs-built_in">gcd</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>); <span class="hljs-comment">// use of function &#x27;T gcd(T, T) [with T = double]&#x27;</span><br>               <span class="hljs-comment">// with unsatisfied constraints</span><br><span class="hljs-built_in">gcd</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>模板头中额外的 requires 子句表达了模板参数应该在什么条件下工作，同样地，它还可以接受一个约束表达式。当我们错误地使用受约束的 gcd 函数，编译器将产生一个友好的错误信息。设计 requires 子句的意图是判断它所约束的声明在某些上下文中是否可行。对于函数模板而言，上下文是在执行重载决议中进行的；对于模板类而言，是在决策合适的特化版本中；对于模板类中的成员函数而言，是决策当显式实例化时是否生成该函数。</p><p>我们讨论第一个场景，在重载决议中，考虑如下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 受约束版本</span><br><span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;1&quot;</span> &lt;&lt; std::endl; &#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 通用版本</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;2&quot;</span> &lt;&lt; std::endl; &#125;<br><br><span class="hljs-built_in">f</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;&#125;); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>这里提供了两个模板函数f，前者要求类型是平凡的，后者则没有任何约束。当对函数进行调用时，传递一个非平凡对象 <code>vector&lt;int&gt;</code>，由于候选集中的第一个可行函数的类型不满足要求，将其从候选集中删除，只剩下一个不受约束的版本，因此重载决议没有产生歧义，最终输出的结果为 2。</p><p>这里的关键在于违反约束本身并不是一个错误，除非候选集中没有可行函数了，但那是另一回事。上述情况也可以被看作 SFINAE，但我们不需要继续使用诸如 enable_if 等变通方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 曾经的元编程技巧：enable_if</span><br><span class="hljs-type">enable_if_t</span>&lt;is_trivial_v&lt;T&gt;&gt; <span class="hljs-built_in">f</span>(T) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;1&quot;</span> &lt;&lt; std::endl; &#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 否定条件</span><br><span class="hljs-type">enable_if_t</span>&lt;!is_trivial_v&lt;T&gt;&gt; <span class="hljs-built_in">f</span>(T) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;2&quot;</span> &lt;&lt; std::endl; &#125;<br></code></pre></td></tr></table></figure><p>enable_if 提供的可行函数之间的条件必须两两互斥，以避免重载决策上的歧义。而 concept 本身存在优先级机制，这一机制能避免上述问题，这是重大的改进。</p><p>在概念标准化之前，除了 enable_if 之外，人们常常使用 decltype 操作符与表达式进行组合来决策重载函数，考虑如下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 如果类型提供了成员函数 OnInit，决策这个版本</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">initialize</span><span class="hljs-params">(T&amp; obj)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(obj.OnInit())</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;1&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> obj.<span class="hljs-built_in">OnInit</span>();<br>&#125;<br><span class="hljs-comment">// 决策什么也不做的版本</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(...)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;2&quot;</span> &lt;&lt; std::endl; &#125;<br></code></pre></td></tr></table></figure><p>如果用户提供的类型拥有成员函数 <code>OnInit</code>，那么候选集中的这两个函数都可行，根据重载决议的规则，不定参数函数的优先级较低，编译器将选择正确的第一个版本；若用户提供的类型没有该成员函数，那么第一个版本将触发 SFINAE 机制，候选集中仅剩下第二个版本的函数，最终将什么也不做。</p><p>如果使用 requires 子句结合 requires 表达式来实现将更加合理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 使用 requires 子句，连接一个 requires 表达式</span><br><span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span><span class="hljs-params">(T obj)</span> </span>&#123; obj.<span class="hljs-built_in">OnInit</span>(); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; obj)</span> </span>&#123; <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;1&quot;</span> &lt;&lt; std::endl;<br>    obj.<span class="hljs-built_in">OnInit</span>(); <br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 什么也不做的版本</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;2&quot;</span> &lt;&lt; std::endl; &#125;<br></code></pre></td></tr></table></figure><p>如果用户提供的类型拥有成员函数 <code>OnInit</code>，那么候选集中这两个函数都可行，根据标准，受约束的函数比未受约束的更优，编译器将选择正确的第一个版本；若用户提供的类型没有该成员函数，第一个版本不符合要求，候选集中仅剩下第二个版本的函数，同理最终将什么也不做。</p><p>从这两个例子中我们能够看到 concept 特性所带来的优势，它不需要那么多元编程技巧，让新人也能够容易接受、上手，而无须理解变通技巧中涉及的一些隐晦问题。</p><p>requires 子句拥有和 concept 类似的性质，考虑如下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">requires</span> is_integral_v&lt;<span class="hljs-keyword">typename</span> T::type&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span></span>;<br></code></pre></td></tr></table></figure><p>当用户对该函数进行调用时，首先检查表达式是否合法，如果模板参数类型没有类型成员 <code>type</code>，将不满足要求；否则进一步判断类型成员是否为整数类型，如果是则满足要求，函数能够被正常调用，否则不满足要求，产生编译错误。</p><p>当对 requires 子句中的约束使用否定时需要额外注意，它可能并不是在表达否定的意思，回忆在 2.1 节提到的一个例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-built_in">requires</span>(!is_integral_v&lt;<span class="hljs-keyword">typename</span> T::type&gt;)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span></span>;<br></code></pre></td></tr></table></figure><p>程序员可能把这个否定理解为“要求模板参数类型没有类型成员 <code>type</code> 或类型成员不为整数”，而它真正的语义为“要求模板参数类型拥有类型成员 <code>type</code> 且类型成员不为整数”，如果需要表达前者语义，可以参考 2.1 节提到的方式，这里不再赘述。</p><p>可能有读者注意到了 requires 子句中对约束的否定使用了圆括号，这是因为编译器对代码进行解析的过程中存在困难，考虑如下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span> <span class="hljs-comment">// 语法错误，P(0) 需要通过括号括起来</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T )</span> </span>&#123; &#125;<br></code></pre></td></tr></table></figure><p>编译器在解析这段代码时，遇到约束 <code>P(0)</code> 会认为这是一个类型转换表达式，将数值类型转换成其他类型 <code>P</code>，然而实际上表达的是一个谓词函数调用，这时候需要通过括号将 <code>P(0)</code> 括起来。好在编译器又足够智能，能通过错误信息提醒用户更正这个错误。</p><p>requires 子句中的约束表达式也支持对约束进行合取与析取操作。除了通过 requires 子句引入约束之外，在简单情况下还可以通过更简洁的语法来引入约束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;integral T, integral U&gt;<br><span class="hljs-comment">// requires(integral&lt;T&gt; &amp;&amp; integral&lt;U&gt;)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T, U)</span></span>;<br></code></pre></td></tr></table></figure><p>我们可以看到关键字 typename 被替换成了概念 <code>integral</code>，对多个模板参数添加概念约束，将产生一个约束合取表达式，正如注释中提到的一样。此外，不需要填充概念中的模板参数，根据 concept 的性质它会自动将模板参数补充到概念中第一个参数位置，这是 type traits 做不到的。</p><p>另一方面也说明了，不需要通过 requires 子句也能施加约束。约束的合取比较容易得到，而约束的析取需要通过 requires 子句才能得到。</p><p>如不关心模板参数类型，则 C++20 模板函数的参数可以使用 auto 来简化，并同时支持添加约束。如下函数原型和上面一样。</p><p><code>void f(integral auto a, integral auto b);</code></p><p>此外，泛型 lambda 也能够通过使用概念进行约束。</p><p><code>auto f = [](integral auto lhs, integral auto rhs) &#123; return lhs + rhs; &#125;;</code></p><p>前面提到模板类与它的特化版本能够通过 requires 子句施加约束，根据约束比较规则可以决策出约束最强的版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Optional</span> &#123; <span class="hljs-comment">// 主模板</span><br>    <span class="hljs-keyword">union</span> &#123; T val; <span class="hljs-type">char</span> dummy; &#125; storage_;<br>    <span class="hljs-type">bool</span> initialized_&#123;&#125;;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">requires</span> is_trivial_v&lt;T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Optional</span>&lt;T&gt; &#123; <span class="hljs-comment">// 受约束的特化版本</span><br>    T storage_;<br>    <span class="hljs-type">bool</span> initialized_&#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用 <code>Optional&lt;int&gt;</code>，因为 int 类型为平凡类型，符合特化版本中的约束要求，那么将决策特化版本而不是更一般的版本，这样能够有针对性地进行优化。在传统的元编程技巧中，常常使用 <code>enable_if_t</code> 与 <code>void_t</code> 进行特化版本的决策，通过使用约束方式降低了程序员学习的难度。</p><p>当对模板类型进行显式实例化时，若受约束的成员函数不符合要求，编译器将不为这个函数生成代码，这是 <code>enable_if_t</code> 做不到的地方。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wrapper</span> &#123;<br>    T value_;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">requires</span> is_invocable_v&lt;T&gt;</span><br><span class="hljs-function">    </span>&#123; <span class="hljs-built_in">value_</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(T v)</span> </span>&#123; value_ = v; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 显式实例化，由于不满足约束，不生成成员函数 operator()()</span><br><span class="hljs-keyword">template</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wrapper</span>&lt;<span class="hljs-type">int</span>&gt;;<br></code></pre></td></tr></table></figure><p>这里的 requires 子句写在了函数声明后，当对该模板类进行实例化时，由于成员函数 <code>operator()()</code> 不满足要求，编译器将不为它生成代码。</p><h3 id="2-4-约束的偏序规则"><a href="#2-4-约束的偏序规则" class="headerlink" title="2.4 约束的偏序规则"></a>2.4 约束的偏序规则</h3><p>在前一节我们看到了通过给模板施加约束，受约束的版本比未受约束的版本更优，如果两个版本同样含有约束且都满足，哪个最优呢？</p><p>之所以会有这个问题，要回到 C++ 最初的标准模板库中的设计，迭代器是算法与容器之间的桥梁，并且分为几类。同一个算法针对不同类的迭代器中拥有不同的高效实现：如 rotate 旋转算法在随机访问迭代器、双向迭代器、单向迭代器中拥有不同的实现，其中随机访问迭代器的效率最高。</p><p>如果一个随机访问迭代器使用了单向迭代器的算法，那么效率不是最优。在 C++11 之前。使用标签分发技术来决策最优算法，迭代器种类标签之间存在继承关系，重载决议时通过比较规则决策出正确的版本；在 C++17 中，可以使用 if constexpr 来决策最优算法；进入 C++20 后，则使用概念约束进行决策。</p><p>在 C++ 的概念特性发展历史中，它曾经支持以继承形式扩展，这被称为概念改良。概念继承形式能够比较自然地表达合取关系，但在表达析取关系就不那么自然了。因此在 C++20 标准中废除了这一形式，而是采用更加自然的合取与析取关系。</p><p>在模板函数重载决议与类模板特化决策中，约束的合取与析取关系以及 concept 扮演至关重要的角色，对于两个约束都满足的模板，可以通过约束的偏序规则决策出谁最优。</p><h4 id="2-4-1-约束表达式归一化"><a href="#2-4-1-约束表达式归一化" class="headerlink" title="2.4.1 约束表达式归一化"></a>2.4.1 约束表达式归一化</h4><p>对于受约束的模板函数、模板类而言，施加的约束表达式被称为关联约束（associated constraint），为了进一步判断是否满足约束以及谁更优，需要将关联约束分解成原子约束的合取与析取形式，这个过程被称为归一化（normalization）。</p><p>前面提到 concept 只是约束表达式的别名，在归一化过程中会对 concept 进行展开，展开后的约束表达式若包含 concept，则会进一步递归展开。直到所有的约束都无法进一步展开，这些约束即为原子约束，那么最终的形式就是原子约束的合取与析取表达式。每个原子约束既不是合取也不是析取形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">concept</span> C1 = <span class="hljs-built_in">sizeof</span>(T) == <span class="hljs-number">1</span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">concept</span> C2 = C1&lt;T&gt; &amp;&amp; <span class="hljs-number">1</span> == <span class="hljs-number">2</span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">concept</span> C3 = <span class="hljs-built_in">requires</span> (T x) &#123; ++x; &#125; || C2&lt;T&gt;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;C2 T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(T)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;C3 T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(T)</span></span>;<br></code></pre></td></tr></table></figure><p>函数 f1 的关联约束为 <code>C2&lt;T&gt;</code>，为了判断关联约束是否满足要求，将对它进行归一化，展开过程如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">C2 =&gt; C1&lt;T&gt; ∧ <span class="hljs-number">1</span> == <span class="hljs-number">2</span> <span class="hljs-comment">// 再次递归展开</span><br>   =&gt; (<span class="hljs-built_in">sizeof</span>(T) == <span class="hljs-number">1</span>) ∧ (<span class="hljs-number">1</span> ==<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>最终形式是原子约束 <code>sizeof(T)==1</code> 与原子约束 <code>1==2</code> 的合取形式，归一化过程在模板参数替换时没有产生非法表达式，这时进行最终的求值，可以发现约束不满足。函数 <code>f2</code> 的关联约束为 <code>C3&lt;T&gt;</code>，归一化过程类似。需要注意 requires 表达式、约束的否定是原子约束，最终结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">C3&lt;T&gt; =&gt; <span class="hljs-built_in">requires</span> (T x) &#123; ++x; &#125; ∨ ((<span class="hljs-built_in">sizeof</span>(T) == <span class="hljs-number">1</span>) ∧ (<span class="hljs-number">1</span> == <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h4 id="2-4-2-简单约束的包含关系"><a href="#2-4-2-简单约束的包含关系" class="headerlink" title="2.4.2 简单约束的包含关系"></a>2.4.2 简单约束的包含关系</h4><p>对于同样满足要求的两个约束表达式的关系，C++ 标准中拥有更正式的规则来描述，本小节首先考虑简单的合取与析取表达式。</p><p>约束表达式 <code>P</code> 与 <code>Q</code> 的偏序关系也被称为包含关系（subsumption），如果它们拥有包含关系，若 <code>P</code> 包含 <code>Q</code> 而 <code>Q</code> 不包含 <code>P</code>，则 <code>P</code> 比 <code>Q</code> 更优；反之，<code>Q</code> 比 <code>P</code> 更优。<code>P</code> 和 <code>Q</code> 可能没有包含关系，那么将产生决议歧义的编译错误。</p><p>约束表达式 <code>P</code> 包含 <code>Q</code>，当且仅当 <code>P</code> 满足要求时 <code>Q</code> 也满足；<code>Q</code> 不包含 <code>P</code>，则当 <code>Q</code> 满足时 <code>P</code> 不一定满足。考虑如下两个约束表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> EqualityComparable = <span class="hljs-comment">/*...*/</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> TotallyOrdered = EqualityComparable&lt;T&gt; &amp;&amp; PartiallyOrderedWith&lt;T, T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;EqualityComparable T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span></span>; <span class="hljs-comment">// #1</span><br><span class="hljs-keyword">template</span> &lt;TotallyOrdered T&gt;     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span></span>; <span class="hljs-comment">// #2</span><br></code></pre></td></tr></table></figure><p>当 <code>TotallyOrdered&lt;T&gt;</code> 所指的约束合取表达式满足要求时，意味着它的两个约束都为真，可以得出 <code>EqualityComparable&lt;T&gt;</code> 满足要求，因此 <code>TotallyOrdered&lt;T&gt;</code> 包含 <code>EqualityComparable&lt;T&gt;</code>。</p><p>当 <code>EqualityComparable&lt;T&gt;</code> 所指的约束表达式满足要求时，不能得出 <code>TotallyOrdered&lt;T&gt;</code> 也满足要求，因此 <code>EqualityComparable&lt;T&gt;</code> 不包含 <code>TotallyOrdered&lt;T&gt;</code>（见图 3.1）。</p><p>图3.1约束的合取包含关系</p><p>在对两个都满足约束的函数 f 决议中，将决出更优的第二个版本。</p><p>再来看看约束析取表达式，同样给出两个约束表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> FloatingPoint = is_floating_point_v&lt;T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Arithmetic = FloatingPoint&lt;T&gt; || Integral&lt;T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;FloatingPoint T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span></span>; <span class="hljs-comment">// #1</span><br><span class="hljs-keyword">template</span> &lt;Arithmetic T&gt;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span></span>; <span class="hljs-comment">// #2</span><br></code></pre></td></tr></table></figure><p>当 <code>Arithmetic&lt;T&gt;</code> 所指的约束表达式满足要求时，意味着它的两个约束中至少有一个为真，不能得出 <code>FloatingPoint&lt;T&gt;</code> 也满足要求，因此 <code>Arithmetic&lt;T&gt;</code> 不包含 <code>FloatingPoint&lt;T&gt;</code>。</p><p>当 <code>FloatingPoint&lt;T&gt;</code> 所指的约束合取表达式满足要求时，得出 <code>Arithmetic&lt;T&gt;</code> 满足要求，因此 <code>FloatingPoint&lt;T&gt;</code> 包含 <code>Arithmetic&lt;T&gt;</code>（见图 3.2）。</p><p>图 3.2 约束的析取包含关系<br>在对两个都满足约束的函数 <code>f</code> 的决议中，将决策出第一个版本更优。</p><p>通过这两个例子我们可以发现，约束的合取形式 <code>R∧S</code> 要比 <code>R</code> 更优，而析取形式 <code>R</code> 要比 <code>R∨S</code> 更优。</p><h4 id="2-4-3一般约束的包含关系"><a href="#2-4-3一般约束的包含关系" class="headerlink" title="2.4.3一般约束的包含关系"></a>2.4.3一般约束的包含关系</h4><p>上一小节介绍了简单约束表达式的包含关系，这一节将介绍更为通用的规则，当编译器面临复杂的约束表达式时，是如何决策出最优的。</p><p>首先，考虑如下两个约束表达式，谁更优？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// P</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span> <span class="hljs-keyword">requires</span> is_integral_v&lt;T&gt;</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// Q</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span> <span class="hljs-keyword">requires</span> is_integral_v&lt;T&gt; &amp;&amp; is_signed_v&lt;T&gt;</span>; <span class="hljs-comment">// #2</span><br></code></pre></td></tr></table></figure><p>当模板参数 <code>T</code> 为 <code>int</code> 时，这两个函数都满足要求，那么它们究竟谁更优呢？答案是由于编译错误，它们没有任何关系，无法决策出最优版本。2.4.2 节提到“约束的合取形式 <code>R∧S</code> 要比 <code>R</code> 更优”，为什么结论在这里不成立了？</p><p>其实不然，之前为了简化讨论，忽略了对约束表达式进行归一化的过程：约束表达式中的 concept（如果存在）会递归展开成最终原子约束的合取与析取形式。判断两个约束表达式之间 是否存在关系，需要进一步判断它们归一化后的原子约束之间是否存在相同（identical）关系。</p><p>原子约束 <code>Ai</code> 和 <code>Aj</code> 的相同关系被定义为：它们是否词法上相等且来自于同一个 concept。这个例子中的两个约束表达式都没有 concept，归一化后的原子约束表达式分别为：</p><p>原子约束表达式 <code>P</code> 和 <code>Q</code> 存在词法上相等的原子约束 <code>is_integral_v&lt;T&gt;</code>，但它们不是来自于同一个 concept ，因此这两个原子约束其实不相同，最终两个表达式没有包含关系，它们相当于“ <code>R∧S</code> 与 <code>T</code> 没有关系”，因此无法决策出谁最优。</p><p>使用 concept 改写这个例子，代码如下。</p><p>同样地，当模板参数 <code>T</code> 为 <code>int</code> 时，两个版本都满足要求，但是这次编译器选择了第二个版本作为更优的版本。对这两个原子约束表达式进行归一化，过程如下。</p><p>归一化后的结果和前面一样，唯一不同的是这期间 <code>Integral</code> 概念进行了展开：两个原子约束 <code>is_integral_v&lt;T&gt;</code> 来自于同一个概念 <code>Integral</code>。上一节的结论再次成立。</p><p>虽然我们能够一眼看出来谁更优，但是编译器却不那样认为。当使用 concept 时，编译器才会在需要的时候尝试计算它们之间的关系，这也是 concept 具有的独特性质。</p><p>更一般地，C++ 标准通过如下的规则来计算约束表达式 <code>P</code> 与 <code>Q</code> 之间的偏序关系。<code>P</code> 包含 <code>Q</code>，当且仅当 <code>P</code> 的析取范式中的每个析取子句Pi包含Q的合取范式的每个合取子句 <code>Qj</code>，那么 <code>P</code> 包含 <code>Q</code>。原子约束归一化后可以标准化为析取范式与合取范式，其中析取范式的析取子句为约束合取表达式，合取范式的合取子句为约束析取表达式。</p><p>考虑原子约束 A、B、C，归一化后的约束表达式 <code>A∧(B∨C)</code> ，将它写成析取范式时需要进一步转换成 <code>(A∧B)∨(A∧C)</code> ，它的两个析取子句分别为合取表达式 <code>A∧B</code> 和 <code>A∧C</code>；将它写成合取范式时为它本身，两个合取子句分别为析取表达式 <code>A</code> 和 <code>B∨C</code>。</p><p>析取子句 <code>Pi</code> 包含合取子句 <code>Qj</code> 当且仅当 <code>Pi</code> 存在一个原子约束 <code>Pia</code> 且 <code>Pia</code> 与 <code>Qj</code> 中的一个原子约束 <code>Qjb</code> 相同。</p><p>这些规则相当抽象，我们可以结合具体的例子来分析一下。</p><p>考虑归一化后约束表达式 <code>P=R∧S</code> 与 <code>Q=R</code>，首先判断 <code>P</code> 是否包含 <code>Q</code>，将 <code>P</code> 写成析取范式，它只有一个析取子句 <code>P0=R∧S</code>，将 <code>Q</code> 写成合取范式，同样只有一个合取子句 <code>Q0=R</code>，<code>P0</code> 和 <code>Q0</code> 存在相同的原子约束 <code>R</code>，因此 <code>P</code> 包含 <code>Q</code>；接下来判断 <code>Q</code> 是否包含 <code>P</code>，将 <code>Q</code> 写成析取范式，它只有一个析取子句 <code>Q0=R</code>，将 <code>P</code> 写成合取范式，它有两个合取子句 <code>P0=R</code> 与 <code>P1=S</code>，显然 <code>Q0</code> 包含 <code>P0</code>（因为存在相同的原子约束 <code>R</code>），而 <code>Q0</code> 不包含 <code>P1</code>（因为不存在相同的原子约束），最后得到 <code>Q</code> 不包含 <code>P</code>。综上所述，<code>R∧S</code> 要比 <code>R</code> 更优。</p><p>考虑归一化后约束表达式 <code>P=R∨S</code> 与 <code>Q=R</code>，首先判断 <code>P</code> 是否包含 <code>Q</code>，将 <code>P</code> 写成析取范式，它有两个析取子句 <code>P0=R</code> 与 <code>P1=S</code>，将 <code>Q</code> 写成合取范式，它只有一个合取子句 <code>Q0=R</code>，<code>P0</code>和 <code>Q0</code> 存在相同的原子约束 <code>R</code>，因此 <code>P0</code> 包含 <code>Q0</code>，而 <code>P1</code> 不包含 <code>Q0</code>（由于不存在相同的原子约束），因此 <code>P</code> 不包含 <code>Q</code>；接下来判断 <code>Q</code> 是否包含 <code>P</code>，将 <code>Q</code> 写成析取范式，它只有一个析取子句 <code>Q0=R</code>，将 <code>P</code> 写成合取范式，同样只有一个合取子句 <code>P0=R∨S</code>，显然 <code>Q0</code> 包含 <code>P0</code>（因为存在相同的原子约束 <code>R</code>），最后得到 <code>Q</code> 包含 <code>P</code>。综上所述，<code>R</code> 比 <code>R∨S</code> 要更优。</p><p>接下来考虑更为复杂的情况，考虑为一个假想的数学库提供概念设计，例如标量概念中要求为整数或者浮点类型。</p><p>该数学库考虑为用户提供的类型进行扩展，提供一个叫作 <code>MathematicalTraits</code> 的元函数，用户需要通过特化实现该元函数，以便让数学库识别。</p><p>同时，数学库提供了一个概念 <code>CustomMath</code> 用于识别给定类型是否为用户扩展的类型。最后，需要用一个概念 <code>Mathematical</code> 来表达要么为内置的标量类型，要么为用户扩展的自定义类型，即通过两个概念的析取来表达。</p><p>数学库提供了一个计算函数 <code>calculate</code>，它接受两个模板参数类型，对类型的约束为 <code>Mathematical</code>，关联约束为合取表达式。</p><p>这个计算函数要求的两个类型不一定一样，其中一个有可能属于标量类型，另一个属于自定义类型。该数学库可能会提供一个性能更优的计算函数的重载版本，只要给定的两个类型属于同一个概念：要么都属于标量概念 <code>Scalar</code>，要么都属于自定义概念 <code>CustomMath</code>。</p><p>当用户使用两个标量类型对该函数进行调用时，可发现两个候选函数都满足要求，那么究竟哪个更优呢？</p><p>首先，我们判断第二个重载版本的关联约束 <code>P</code> 是否包含第一个版本中的关联约束 <code>Q</code>。将 <code>P</code> 和 <code>Q</code> 分别写成析取范式与合取范式。</p><p>于是我们需要进一步判断P的每个析取子句 <code>Pi</code> 是否包含 <code>Q</code> 的每个合取子句 <code>Qj</code>，也就是证明如下命题都为真。</p><ul><li><code>P0</code> 包含 <code>Q0</code>。</li><li><code>P0</code> 包含 <code>Q1</code>。</li><li><code>P1</code> 包含 <code>Q0</code>。</li><li><code>P1</code> 包含 <code>Q1</code>。</li></ul><p>为了进一步证明 <code>Pi</code> 是否包含 <code>Qj</code>，需要在 <code>Pi</code> 中找到一个原子约束 <code>Pia</code> 使得，它与 <code>Qj</code> 中的原子约束 <code>Qjb</code> 相同。显然，我们可以找出它们共同的原子约束：</p><ul><li>对于 <code>P0</code> 与 <code>Q0</code> 而言，存在相同的原子约束 <code>Scalar&lt;T&gt;</code>。</li><li>对于 <code>P0</code> 与 <code>Q1</code> 而言，存在相同的原子约束 <code>Scalar&lt;U&gt;</code>。</li><li>对于 <code>P1</code> 与 <code>Q0</code> 而言，存在相同的原子约束 <code>CustomMath&lt;T&gt;</code>。</li><li>对于 <code>P1</code> 与 <code>Q1</code> 而言，存在相同的原子约束 <code>CustomMath&lt;U&gt;</code>。</li></ul><p>因此可以得出 <code>P</code> 包含 <code>Q</code> 的结论，为了证明 <code>P</code> 比 <code>Q</code> 更优而不是重载歧义，我们需要证明 <code>Q</code> 不包含 <code>P</code>。类似地，将 <code>Q</code> 和 <code>P</code> 分别写成析取范式与合取范式。</p><p>析取范式与合取范式互相转换，每个子句间的原子约束将两两分配，最终子句数量最多为原范式子句数量的指数级别。</p><p>在这个例子中 <code>Q</code> 的合取范式只有两个子句，每个子句由两个原子约束组成，转换成析取范式后各子句中的原子约束两两分配产生 $2^2&#x3D;4$ 个子句。</p><p><code>P</code> 的析取范式转换成合取范式也是类似的过程。</p><p>需要进一步判断 <code>Q</code> 的每个析取子句 <code>Qi</code> 是否包含 <code>P</code> 的每个合取子句 <code>Pj</code>，这需要证明 <code>16</code> 个命题，只要我们能够找到一个 <code>Qj</code> 不包含 <code>Pi</code> 即可证明 <code>Q</code> 不包含 <code>P</code>。仔细观察可以发现，<code>Q1</code> 与 <code>P2</code> 之间、<code>Q2</code> 与 <code>P1</code> 之间都不存在相同的原子约束，这就证明了 <code>Q</code> 不包含 <code>P</code>。</p><p>最后的结果符合我们的预期，第二个重载 <code>calculate</code> 函数为最优的候选函数，最终输出的结果为 <code>P</code>。</p><p>从这个过程中我们也能够发现，当涉及复杂的约束表达式时，编译器的计算量将大幅增加。约束合取表达式是难以避免的，因为可以通过多种方式引入，而约束析取表达式则没那么多。如果可能的话，应尽可能避免使用析取表达式，这将有助于减少编译器的计算量。</p><h4 id="2-4-4-using-类型别名与-concept-表达式别名"><a href="#2-4-4-using-类型别名与-concept-表达式别名" class="headerlink" title="2.4.4 using 类型别名与 concept 表达式别名"></a>2.4.4 using 类型别名与 concept 表达式别名</h4><p>前面提到 concept 作为表达式别名，其机制和 using 作为类型别名类似。C++ 中判断两个类型别名是否相同也是通过展开后判断词法与位置是否相等。考虑如下两个类型。</p><p>这里的类型别名 <code>A</code> 和 <code>B</code> 其实是一个类型，它们都为 <code>Point</code>。而如下两个类型却是不相同的类型，尽管它们词法上相等。</p><p>两个原子约束是否存在包含关系仅取决于它们是否相同，这就要求原子约束在词法上相等，并且来源于同一个 concept。</p><h3 id="2-5-概念标准库"><a href="#2-5-概念标准库" class="headerlink" title="2.5 概念标准库 &lt;concepts&gt;"></a>2.5 概念标准库 <code>&lt;concepts&gt;</code></h3><p>C++20 标准库 <code>&lt;concepts&gt;</code> 提供了一些基本的概念，用于在编译期对模板参数进行校验和基于概念的函数重载。标准库中的许多概念都有语法和语义上的要求，如果一个模板参数符合语法上的约束，那么它通常被称为“满足（satisfy）要求”。更进一步，如果模板参数符合语义上的约束，则被称为“对该概念进行建模（model）”。通常编译器只能检查语法上的要求，对于语义上的要求需要程序员自行检查。</p><p>本节将介绍一些常用的 concept，基于这些 concept 能够组合出更为强大的概念。</p><h4 id="2-5-1-same-as（与某类相同）"><a href="#2-5-1-same-as（与某类相同）" class="headerlink" title="2.5.1 same_as（与某类相同）"></a>2.5.1 same_as（与某类相同）</h4><p><code>same_as</code> 概念要求输入两个类型参数，借此判断这两个类型是否满足相同的约束。一个可能的实现如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">concept</span> same_as = is_same_v&lt;T, U&gt;;<br></code></pre></td></tr></table></figure><p>上述实现是有问题的，所以考虑要求两个模板参数类型一致的函数，并提供一个特别的重载版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">requires</span> same_as&lt;T, U&gt; <span class="hljs-comment">// P</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T, U)</span></span>; <span class="hljs-comment">// 一般的版本</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">requires</span> same_as&lt;U, T&gt; &amp;&amp; is_integral_v&lt;T&gt; <span class="hljs-comment">// Q</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T, U)</span></span>; <span class="hljs-comment">// 提个一个特别的版本</span><br></code></pre></td></tr></table></figure><p>需要注意的是，特别版本中的 requires 子句中的约束 <code>same_as</code> 的类型参数正好与一般的版本相反，前者为 <code>same_as&lt;U, T&gt;</code>，后者为 <code>same_as&lt;T, U&gt;</code>，根据 <code>same_as</code> 的对称性可知，两者应该<br>是一样的，当使用 <code>f(1, 1)</code> 时，预期应该决策使用特别的版本。</p><p>然而在编译器决策的时候发生了重载歧义，无法决策出最优的实现。分别将两个版本的约束表达式进行正规化后，得到如下结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">P =&gt; same_as&lt;T, U&gt; =&gt; is_same_v&lt;T, U&gt;<br>Q =&gt; same_as&lt;U, T&gt; ∧ is_integral_v&lt;T&gt; =&gt; is_same_v&lt;U, T&gt; ∧ is_integral_v&lt;T&gt;<br></code></pre></td></tr></table></figure><p>虽然这两个表达式最终的原子表达式 <code>is_same_v</code> 都来自于同一个概念 <code>same_as</code>，但是它们在词法上不相等，因此这两个原子约束不相同，也就没法进一步判断它们之间的偏序关系了。</p><p>为了解决这个问题，标准中通过添加一层间接层来解决，即引入额外的 concept。最后，<code>same_as</code> 的正确实现如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">concept</span> _same_as = is_same_v&lt;T, U&gt;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">concept</span> same_as = _same_as&lt;T, U&gt; &amp;&amp; _same_as&lt;U, T&gt;;<br></code></pre></td></tr></table></figure><p>这表达了一种对称关系：<code>same_as&lt;T，U&gt;</code> 包含 <code>same_as&lt;U，T&gt;</code>，反之亦然。</p><h4 id="2-5-2-derived-from（派生自某类）"><a href="#2-5-2-derived-from（派生自某类）" class="headerlink" title="2.5.2 derived_from（派生自某类）"></a>2.5.2 derived_from（派生自某类）</h4><p><code>derived_from</code> 用于表达两个类之间是否存在 is-a 的关系，也就是判断两个类之间是否存在公有继承关系。在元编程场景中，通常定义一个空标签类来代表某一族类，然后同一族类派生自该特征标签，后续只需要判断某个类是否派生自该特征类即可判断是否为所需。</p><p><code>derived_from</code> 的实现比较简单，需要注意的是，同样的类在忽略 cv 修饰符的情况下也满足派生关系，这通过给类型都加上 cv 属性来保证。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Derived, <span class="hljs-keyword">typename</span> Base&gt;<br><span class="hljs-keyword">concept</span> derived_from = is_base_of_v&lt;Base, Derived&gt; &amp;&amp;<br>                       is_convertible_v&lt;<span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> Derived*, <br>                                        <span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> Base*&gt;;<br></code></pre></td></tr></table></figure><h4 id="2-5-3-convertible-to（可转换为某类）"><a href="#2-5-3-convertible-to（可转换为某类）" class="headerlink" title="2.5.3 convertible_to（可转换为某类）"></a>2.5.3 convertible_to（可转换为某类）</h4><p>除了要求表达式的类型严格相同之外，另一个常见的场景是，只要一个表达式的类型能够通过隐式或显式转换成目标类型即可。语义上要求这两种转换方式的结果应该是相等的，这种情况可以使用<code>convertible_to</code> 来表达。</p><p><code>convertible_to</code> 的实现如下，通过约束合取来表达。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> From, <span class="hljs-keyword">typename</span> To&gt;<br><span class="hljs-keyword">concept</span> convertible_to = is_convertible_v&lt;From, To&gt; &amp;&amp; <span class="hljs-comment">// 隐式类型转换</span><br>                         <span class="hljs-built_in">requires</span>(<span class="hljs-built_in">add_rvalue_reference_t</span>&lt;From&gt;(&amp;f)())<br>                         &#123; <span class="hljs-built_in">static_cast</span>&lt;To&gt;(<span class="hljs-built_in">f</span>()); &#125;;    <span class="hljs-comment">// 显式类型转换</span><br></code></pre></td></tr></table></figure><p>第一个约束要求类型 <code>From</code> 能够通过隐式类型转换成 <code>To</code>，第二个约束根据 requires 表达式要求进行显式类型转换。</p><p>requires 表达式的形参列表中声明了一个无参函数类型，其返回类型为 <code>From&amp;&amp;</code>，通过符号 <code>f</code> 来指代这个函数。在表达式体中使用 <code>static_cast</code> 将函数调用的结果显式类型转换成 <code>To</code>，由于 requires 表达式为不求值环境，所以不会发生真正的函数调用。</p><p>为何需要进一步要求类型能够通过显式转换？什么类型能够通过隐式转换成目标类型但又无法通过显式转换？虽然在实际场景中几乎不可能出现这种类型，但是在 C++ 中，允许用户定义这种“奇怪”的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">To</span> &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> FROM&gt; <span class="hljs-comment">// 删除显式构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">To</span><span class="hljs-params">(FROM)</span> </span>= <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">From</span> &#123; <span class="hljs-comment">// 类型 From 能够隐式转换成 To</span><br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">To</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们构造的这种“奇怪”类型 <code>To</code> 删除了显式类型转换构造函数，而另一个类型 <code>From</code> 拥有类型转换操作符，由于没有使用 <code>explicit</code> 修饰，所以能够隐式地转换成类型 <code>To</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">static_assert</span>( is_convertible_v&lt;From, To&gt;);<br><span class="hljs-built_in">static_assert</span>(!is_convertible_v&lt;From, To&gt;);<br></code></pre></td></tr></table></figure><p>C++ 标准中正是考虑了这种能够通过隐式类型转换而无法通过显式类型转换的奇怪场景，才使用 <code>convertible_to</code> 的概念，这样我们在编写泛型代码时就无须考虑这种奇怪场景，它们将无法通过概念检查。</p><h4 id="2-5-4-算术概念"><a href="#2-5-4-算术概念" class="headerlink" title="2.5.4 算术概念"></a>2.5.4 算术概念</h4><p>在我们初学编程时常常会涉及一些基本的数据类型，这些数据类型被分为整数类和浮点类，整数类包含了 <code>char</code>、<code>short</code>、<code>int</code> 等，进一步可划分成有符号类和无符号类；浮点类包含了 <code>float</code>、<code>double</code> 等。它们统称为算术类型，根据这些概念不难定义出与之对应的 concept。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> integral = is_integral_v&lt;T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> signed_integral = integral&lt;T&gt; &amp;&amp; is_signed_v&lt;T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> unsigned_integral = integral&lt;T&gt; &amp;&amp; !is_signed_v&lt;T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> floating_point = is_floating_v&lt;T&gt;;<br></code></pre></td></tr></table></figure><h4 id="2-5-5-值概念"><a href="#2-5-5-值概念" class="headerlink" title="2.5.5 值概念"></a>2.5.5 值概念</h4><p>在面向值语义编程与泛型编程时，常常会涉及一些相当重要的概念：<code>regular</code>（正则）与 <code>semiregular</code>（半正则）。</p><p><code>regular</code>（正则）的概念指的是一些类型看上去可以像基础数据（如 <code>int</code>）一样，能够进行默认构造、移动构造与赋值、拷贝构造与赋值，并且能够进行判等操作。标准库中的容器设计就使用了这个概念，这样对容器进行的一些操作与对基础数据类型进行的操作没什么区别，都能够以一致的形式编写泛型代码。</p><p><code>semiregular</code> 与 <code>regular</code> 类似，但放松了限制，无须支持判等操作。</p><h4 id="2-5-6-invocable（可调用的）"><a href="#2-5-6-invocable（可调用的）" class="headerlink" title="2.5.6 invocable（可调用的）"></a>2.5.6 invocable（可调用的）</h4><p>除了值和对象之外，还有一些编程元素如函数和函数对象，它们都属于 <code>invocable</code>（可调用）概念。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>...Args&gt;<br><span class="hljs-keyword">concept</span> invocable = <span class="hljs-built_in">requires</span>(F&amp;&amp; f, Args&amp;&amp;...args) &#123;<br>    <span class="hljs-built_in">invoke</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);<br>&#125;;<br></code></pre></td></tr></table></figure><p>若可调用类返回类型为 <code>bool</code>，那么也满足 <code>predicate</code>（谓词）的概念。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Fn, <span class="hljs-keyword">typename</span>..._Args&gt;<br><span class="hljs-keyword">concept</span> predicate = regular_invocable&lt;_Fn, _Args...&gt; &amp;&amp;<br>                    _boolean_testable&lt;<span class="hljs-type">invoke_result_t</span>&lt;_Fn, _Args...&gt;&gt;;<br></code></pre></td></tr></table></figure><p>若一个谓词入参仅接受两个参数，那么也满足 <code>relation</code>（关系）的概念。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">concept</span> relation = predicate&lt;R, T, T&gt; &amp;&amp; predicate&lt;R, U, U&gt; &amp;&amp;<br>                   predicate&lt;R, T, U&gt; &amp;&amp; predicate&lt;R, U, T&gt;;<br></code></pre></td></tr></table></figure><p>通过关系（relation）可以进一步定义等价关系（equivalence_relation）和弱序关系（strict_weak_order），这在 2.3.1 节中介绍过，这里不再赘述。虽然它们从语法定义上一样，但语义不同，正如程序员使用接口时需要关注它们的语义一样，使用概念同样也要关注语义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">concept</span> equivalence_relation = relation&lt;R, T, U&gt;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">concept</span> strict_weak_order = relation&lt;R, T, U&gt;;<br></code></pre></td></tr></table></figure><h3 id="2-6-综合运用之扩展-transform-变换算法"><a href="#2-6-综合运用之扩展-transform-变换算法" class="headerlink" title="2.6 综合运用之扩展 transform 变换算法"></a>2.6 综合运用之扩展 transform 变换算法</h3><p>C++ 标准库中的 <code>transform</code> 算法接受 1 到 2 个输入迭代器、一个输出迭代器与单元或二元函数对象，它在对这 1 到 2 输入迭代器迭代的过程中，将解引用后的值作为单元或二元函数对象的入参，并将二元函数的结果写到输出迭代器上。以下代码实现的功能是将字符串小写转换成大写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-built_in">transform</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), s.<span class="hljs-built_in">begin</span>(), <span class="hljs-comment">// 一个输入迭代器与输出迭代器、单参函数</span><br>          [](<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c) -&gt; <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> &#123; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">toupper</span>(c); &#125;);<br></code></pre></td></tr></table></figure><p>本节的任务是扩展该算法，使其接受任意多个输入迭代器、一个输出迭代器并接受同等输入个数的函数对象，允许输入迭代器的长度不一致，这将以最短的迭代器作为结束。这个算法的名字也应该被命名为 <code>zip_transform</code>，它的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... InputIt, <span class="hljs-keyword">typename</span> Operation, <span class="hljs-keyword">typename</span> OutputIt&gt;<br><span class="hljs-function">OutputIt <span class="hljs-title">zip_transform</span><span class="hljs-params">(OutputIt out, Operation op,</span></span><br><span class="hljs-params"><span class="hljs-function">                       pair&lt;InputIt, InputIt&gt;... inputs)</span></span>;<br></code></pre></td></tr></table></figure><p>这里简单地使用 pair 类将输入迭代器的起始与终止部分打包，考虑可变参数必须作为函数最后的参数，它们也被放到了最后。但该模板函数没有任何约束，用户仅靠模板参数名来人为地遵守语义上的要求。通过使用 <code>&lt;concepts&gt;</code> 标准库中预定义的概念，添加约束如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<br>    std::input_iterator...InputIt, <span class="hljs-comment">// 对 InputIt 进行输入迭代器约束</span><br>    std::invocable&lt;std::<span class="hljs-type">iter_reference_t</span>&lt;InputIt&gt;...&gt; Operation, <span class="hljs-comment">// 对函数对象约束</span><br>    std::output_iterator&lt;std::<span class="hljs-type">invoke_result_t</span>&lt;Operation, <span class="hljs-comment">// 对输出迭代器进行约束</span><br>                                              std::<span class="hljs-type">iter_reference_t</span>&lt;InputIt&gt;...&gt;&gt; OutputIt<br>&gt;<br><span class="hljs-function">OutputIt <span class="hljs-title">zip_transform</span><span class="hljs-params">(OutputIt out, Operation op, pair&lt;InputIt, InputIt&gt;...inputs)</span></span>;<br></code></pre></td></tr></table></figure><p>这要求用户输入的参数必须满足输入迭代器的要求，并且函数对象的参数类型、个数、输入迭代器的解引用类型及个数都能够对应得上，同时还对输出迭代器进行了约束，要求其能够接受函数对象的返回类型。实现部分使用折叠表达式进行代码生成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">OutputIt <span class="hljs-title">zip_transform</span><span class="hljs-params">(OutputIt out, Operation op, </span></span><br><span class="hljs-params"><span class="hljs-function">                       pair&lt;InputIt, InputIt&gt;... inputs)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (((inputs.first != inputs.second) &amp;&amp; ...))<br>        *out++ = <span class="hljs-built_in">op</span>(*inputs.first++...);<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个可能的用例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector v1 &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>std::vector v2 &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br>std::vector v3 &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; v4 <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br><br><span class="hljs-built_in">zip_transform</span>(result.<span class="hljs-built_in">begin</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c) &#123; <span class="hljs-keyword">return</span> a + b + c; &#125;,<br>              <span class="hljs-built_in">make_pair</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>()),<br>              <span class="hljs-built_in">make_pair</span>(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>()),<br>              <span class="hljs-built_in">make_pair</span>(v3.<span class="hljs-built_in">begin</span>(), v3.<span class="hljs-built_in">end</span>())<br>              );<br></code></pre></td></tr></table></figure><h3 id="2-7-注意事项"><a href="#2-7-注意事项" class="headerlink" title="2.7 注意事项"></a>2.7 注意事项</h3><p>如今已经有了很多惯用的手段来表达模板参数的接口，例如 Boost 专门有个 concept check 的库，语言提供了 <code>static_assert</code>、<code>constexpr</code> 函数与值、<code>if constexpr</code>，还有标准库提供的 <code>typetraits</code>，那么 concept 特性存在的必要性是什么？</p><p>这些技巧有些涉及模板的实例化阶段，而不是仅仅去检查模板参数的声明，这或多或少不够理想。此外，这些手段相当低级，有点类似于元编程世界中的汇编代码。但读者不要就此认为这些低级手段就足够用了，这就好比我们自认为只要拥有了 <code>if</code> 和 <code>goto</code> 语句后就不需要 <code>for</code>、<code>while</code> 语句。类似地，只要有了函数指针，虚函数与 <code>lambda</code> 就变得不再那么重要。C++ 不仅仅支持这些低级手段，它还是一门足够抽象的语言，因此：</p><ul><li>concept 并不是专门针对泛型编程的专家才能使用的高级特性。</li><li>concept 不仅仅是 <code>type traits</code>、<code>enable_if</code> 和标签分发等变通方法的语法糖。</li><li>concept 是最基础的语言特性，最好在最初模板特性出现的时候就使用它。</li></ul><p>如果 concept 在 20 世纪 90 年代就已经出现，那么今日的模板与模板库将会简单很多。好在最初的模板特性关键字为 <code>typename</code>：它仅要求模板参数为类型，因此一些老的模板库可以很容易与 concept 特性集成。</p><p>concept 仅对所约束的模板参数声明部分进行检查，而不会去检查函数体中该模板参数是否使用了未被约束的操作，考虑如下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;integral T&gt;<br><span class="hljs-function">T <span class="hljs-title">mod2</span><span class="hljs-params">(T v)</span> </span>&#123; <span class="hljs-keyword">return</span> v % <span class="hljs-number">2</span>; &#125;<br></code></pre></td></tr></table></figure><p>模板函数 <code>mod2</code> 仅检查模板参数 <code>T</code> 是否为整数概念 <code>integral</code>，而这个概念的定义并没有要求模板参数能够使用求余 <code>%</code> 操作，但在函数定义中使用未被约束的操作是允许的。</p><p>这也体现了一个设计层面的问题，是否应该将实现细节暴露给 concept？需要记住的是，实现并不是接口规范，如果有一天你发现一个更高效的实现，理想情况下是通过重构实现，而不是去影响它的接口，这样可以避免破坏用户的代码。若概念设计的要求太宽泛则起不到约束的作用，若设计得太细则难以应对各种变化，因此应该在保证语义一致性的前提下定义与使用 concept。</p><p>如果使用了概念中未被约束的操作，即使通过了约束检查，当该参数不支持这些操作时也会进一步导致模板实例化错误。不根据模板概念去检查模板的定义是一个深思熟虑的决定，而不是一个技术上不可行的问题。</p><p>concept 特性的贡献者们已经分析并尝试过，最终慎重地决定在 concept 的标准化中不包含这个功能，主要原因有以下几点。</p><ul><li>减轻最初设计的复杂度，不想进一步延期标准化，因为延期意味着一些反馈与库的建设将会进一步延后。</li><li>concept 的好处在于模板参数的接口规范化与模板使用之处检查。</li><li>能够在较早阶段发现错误而不是延迟到实例化阶段。</li><li>如果检查模板定义的话，将很难把未受约束的模板与模板库重构成基于 concept 的模板。</li><li>如果检查模板定义的话，很难在不修改 concept 接口的情况下对模板定义部分添加调试辅助、日志、性能打点等代码。</li><li>模板之间的调用会相当困难，一个受约束的模板只能调用另一个受约束的模板，这意味着新的基于 concept 的模板库将无法使用老的库，这是个非常严重的问题，原因在于不同的库是由不同组织开发的，而使用 concept 是一个渐进的过程。</li></ul><p>从上可见 C++ 是一门工程性非常强的语言，所有的特性引入都需要考虑是否破坏了已有代码，老代码能否容易迁移到新特性上，在以上问题未被恰当解决之前是不会去考虑那样做的。concept 曾经考虑通过定义检查将模板的声明与实现分离，而这会导致很多函数的间接调用，并严重影响最终代码的性能。一个可能的解决方案是将模板作为模块（module）特性的一部分，通过半编译形式实现。</p><p>concept 的设计提供了几种语法形式，从简洁到复杂的 requires 子句，因为简单的形式不可避免地限制了它的表达力，而通过复杂的形式表达简单的场景又增加了冗余的噪声。</p><p>在极少会出现两个概念语法一样而语义不同的情况，这就需要程序员手动将语义上的差别转换成语法上的差别：例如通过定义额外的方法或类型成员作为特征以便区分。此外，可以使用 <code>static_assert</code> 显式声明给定类型以满足概念上的要求。</p><p>concept 非常容易定义与使用，这极大改善了模板与泛型编程的代码质量。它就和基础的语言特性（诸如函数、类）一样，需要理解才能高效使用。与未受约束的模板相比，它们没有引入额外的运行时开销。这也符合 C++ 的设计原则：不要强迫程序员去做那些机器能做得更好的事，并且简单的事简单做，以及零成本抽象的哲学。</p><p>concept 解决了模板与泛型编程的很多痛点，它达到了最初所设想的 C++ 模板系统应有的样子，而不是语言特性的扩展。</p><p><em>本文摘自《C++20 高级编程》罗能&#x2F;著</em></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>模板</tag>
      
      <tag>特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Boost 库概览</title>
    <link href="/2023/08/18/boost-library-overview/"/>
    <url>/2023/08/18/boost-library-overview/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/boost-library-overview/boost_logo.png" alt=" "></p><p>Boost 提供免费的同行评审的可移植 C++ 源代码库。</p><p>我们强调与 C++ 标准库配合良好的库。Boost 库旨在具有广泛的用途，并且可在广泛的应用程序中使用。Boost 许可证鼓励 所有用户以最小的限制使用 Boost 库。</p><p>我们的目标是建立“现有实践”并提供参考实现，以便 Boost 库适合最终标准化。从库技术报告(TR1) 中包含的 10 个 Boost 库开始，一直到 2011 年以来 C++ ISO 标准的每个版本，C++ 标准委员会一直依赖 Boost 作为标准 C++ 库补充的宝贵来源。</p><p><strong>作为一个组织的 Boost</strong></p><p>Boost 组织和更广泛的 Boost 社区支持对 C++ 及其开发的库的最佳用途的研究和教育，特别是但不限于 Boost 库中包含的那些内容。</p><p>该组织和社区支持邮件列表和聊天室，为 Boost Libraries 和 C++ 用户提供有关最佳实践和尖端技术的教育。</p><p>本文档基于 Boost 1.83.0</p><h1 id="按类别排序"><a href="#按类别排序" class="headerlink" title="按类别排序"></a>按类别排序</h1><h2 id="字符串和文本处理"><a href="#字符串和文本处理" class="headerlink" title="字符串和文本处理"></a>字符串和文本处理</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/convert/doc/html/index.html">Convert</a>：一个可扩展且可配置的类型转换框架。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/format/">Format</a>：格式化库，提供了一种类型安全机制，用于根据类似 printf 的格式字符串格式化参数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/iostreams/doc/index.html">Iostreams</a>：Boost.IOStreams 提供了一个用于定义流、流缓冲区和 I&#x2F;O 过滤器的框架。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_lexical_cast.html">Lexical Cast</a>：一般文字文本转换，例如 int 表示字符串，反之亦然。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/locale/doc/html/index.html">Locale</a>：为 C++ 提供本地化和 Unicode 处理工具。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/regex/doc/html/index.html">Regex</a>：正则表达式库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/spirit/doc/html/index.html">Spirit</a>：LL 解析器框架，将解析器直接表示为内联 C++ 中的 EBNF 语法。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/spirit/classic/">Spirit Classic</a>：LL 解析器框架，将解析器直接表示为内联 C++ 中的 EBNF 语法。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/spirit/repository/doc/html/index.html">Spirit Repository</a>：Spirit Repository 是一个社区的成果，它为 Qi 解析器和 Karma 生成器收集了不同的可重用组件(原语、指令、语法等)。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/static_string/doc/html/index.html">Static String</a>：固定容量、动态大小的字符串。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/string_algo.html">String Algo</a>：字符串算法库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/tokenizer/doc/index.html">Tokenizer</a>：将字符串或其他字符序列分解为一系列标记。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/wave/">Wave</a>：Boost.Wave 库符合标准，并且高度可配置地实现了强制 C99&#x2F;C++ 预处理器功能，封装在易于使用的迭代器接口后面。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/xpressive.html">Xpressive</a>：可以编写为字符串或表达式模板的正则表达式，并且可以利用上下文无关语法的功能递归地相互引用和自身引用。</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/array.html">Array</a>：与 STL 兼容的容器包装器，用于常量大小的数组。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/bimap/doc/html/index.html">Bimap</a>：C++ 双向映射键值对容器库。 使用 Boost.Bimap，你可以创建关联容器，其两种类型都可以用作键。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/circular_buffer.html">Circular Buffer</a>：符合 STL 的容器也称为环或循环缓冲区。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/container.html">Container</a>：标准库容器和拓展。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/dynamic_bitset/dynamic_bitset.html">Dynamic Bitset</a>：dynamic_bitset 类表示一组二进制位。它通过 operator[] 提供对各个位的值的访问，并提供可应用于内置整数的所有按位运算符，例如 operator&amp; 和 operator&lt;&lt;。该集合中的位数是在运行时通过 dynamic_bitset 构造函数的参数指定的。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/gil/doc/html/index.html">GIL</a>：(C++14) 泛型图像库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/graph/doc/index.html">Graph</a>：BGL 图接口和图组件是泛型的，与标准模板库 (STL) 具有相同的意义。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/graph_parallel/doc/html/index.html">GraphParallel</a>：PBGL 图接口和图组件是泛型的，与标准模板库 (STL) 的意义相同。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/icl/doc/html/index.html">ICL</a>：间隔容器库、间隔集合和映射以及关联值的聚合。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/intrusive.html">Intrusive</a>：侵入式容器和算法。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/json/doc/html/index.html">JSON</a>：基于 C++11 的 JSON 解析、序列化和 DOM。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/multi_array/doc/index.html">Multi-Array</a>：Boost.MultiArray 提供了一个通用的 N 维数组概念定义和该接口的通用实现。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/multi_index/doc/index.html">Multi-Index</a>：The Boost Multi-index Containers Library 提供了一个名为 multi_index_container 的类模板，它支持构建容器，以维护具有不同排序和访问语义的一个或多个索引。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/ptr_container/doc/ptr_container.html">Pointer Container</a>：用于存储堆分配的多态对象以简化面向对象编程的容器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/poly_collection.html">PolyCollection</a>：多态对象的快速容器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/property_map/doc/property_map.html">Property Map</a>：定义将键对象映射到值对象的接口的概念。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/property_map_parallel/">Property Map (Parallel)</a>：Property Map 的并行扩展，可与 Parallel Graph 一起使用。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/property_tree.html">Property Tree</a>：树形数据结构特别适合存储配置数据。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/string_ref.html">String Ref</a>：字符串视图模板。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/unordered/doc/html/unordered.html">Unordered</a>：无序关联容器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/url/doc/html/index.html">URL</a>：C++11 的 URL 解析库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/variant.html">Variant</a>：安全、通用、基于堆栈的可区分联合容器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/variant2/doc/html/variant2.html">Variant2</a>：std::variant 的绝对无值、强有力的保证实现。</li></ul><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/gil/doc/html/index.html">GIL</a>：(C++14) 泛型图像库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/graph/doc/index.html">Graph</a>：BGL 图接口和图组件是泛型的，与标准模板库 (STL) 具有相同的意义。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/graph_parallel/doc/html/index.html">GraphParallel</a>：PBGL 图接口和图组件是泛型的，与标准模板库 (STL) 的意义相同。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/iterator/doc/index.html">Iterator</a>：Boost 迭代器库包含两部分。第一个是扩展 C++ 标准迭代器需求的概念系统。第二个是一个组件框架，用于基于这些扩展的概念构建迭代器，并包括几个有用的迭代器适配器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/utility/utilities/operators.html">Operators</a>：用模板简化了的算术类和迭代器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/tokenizer/doc/index.html">Tokenizer</a>：将字符串或其他字符序列分解为一系列标记。</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/algorithm/doc/html/index.html">Algorithm</a>：一个有用的泛型算法的集合。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/foreach.html">Foreach</a>：在 C++ 中，编写一个在序列上迭代的循环是乏味的。我们既可以使用迭代器，这需要大量的模板，也可以使用 std::for_each() 算法并将循环体移到谓词中，这需要同样多的模板，并迫使我们将逻辑移到远离使用它的地方。相反，其他一些语言，如 Perl，提供了一个专用的“foreach”结构来自动化这个过程。BOOST_FOREACH 就是 C++ 中的这样一个构造。它为我们遍历序列，使我们不必直接处理迭代器或编写谓词。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/geometry/doc/html/index.html">Geometry</a>：Boost.Geometry 库提供几何算法、基元和空间索引。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/gil/doc/html/index.html">GIL</a>：(C++14) 泛型图像库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/graph/doc/index.html">Graph</a>：BGL 图接口和图组件是泛型的，与标准模板库 (STL) 具有相同的意义。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/graph_parallel/doc/html/index.html">GraphParallel</a>：PBGL 图接口和图组件是泛型的，与标准模板库 (STL) 的意义相同。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/histogram/doc/html/index.html">Histogram</a>：快速多维直方图，具有方便的 C++14 接口。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/algorithm/minmax/">Min-Max</a>：同时进行最小&#x2F;最大和最小&#x2F;最大元素计算的标准库扩展。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/polygon/doc/index.htm">Polygon</a>：Voronoi 图构造和布尔&#x2F;裁剪、调整大小&#x2F;偏移等，适用于具有积分坐标的平面多边形。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/qvm/doc/html/index.html">QVM</a>：用于处理四元数向量和矩阵的通用 C++ 库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/range/doc/html/index.html">Range</a>：建立在新式迭代器概念之上的泛型算法的新基础设施。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/sort/doc/html/index.html">Sort</a>：高性能模板化排序函数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/string_algo.html">String Algo</a>：字符串算法库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/index.html">Utility</a>：类不可复制加上 checked_delete()，checked_array_delete()，next()，prior() 函数模板，加上 base-from-member 惯用法。</li></ul><h2 id="函数对象和高阶编程"><a href="#函数对象和高阶编程" class="headerlink" title="函数对象和高阶编程"></a>函数对象和高阶编程</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/bind/doc/html/bind.html">Bind</a>：boost::bind 标准库函数 <code>std::bind1st</code> 和 <code>std::bind2nd</code> 的泛化。它支持任意函数对象、函数、函数指针和成员函数指针，并且能够将任何参数绑定到特定值或将输入参数路由到任意位置。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/container_hash/doc/html/hash.html">Container Hash</a>：与 STL 兼容的哈希函数对象，可以扩展哈希到用户定义的类型。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/function.html">Function</a>：用于延迟调用或回调的函数对象包装器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/functional/">Functional</a>：Boost.Function 库包含一系列类模板，它们是函数对象包装器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/functional/factory/doc/html/index.html">Functional&#x2F;Factory</a>：用于创建动态和静态对象的函数对象模板。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/functional/forward/doc/html/index.html">Functional&#x2F;Forward</a>：允许泛型函数对象接受任意参数的适配器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/functional/overloaded_function/doc/html/index.html">Functional&#x2F;Overloaded Function</a>：将不同的函数重载到单个函数对象中。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/hof/doc/html/doc/index.html">HOF</a>：C++ 的高阶函数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/lambda.html">Lambda</a>：在实际调用地点定义小型匿名函数对象等。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/lambda2/doc/html/lambda2.html">Lambda2</a>：C++14 的 lambda 库.</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/local_function/doc/html/index.html">Local Function</a>：程序在本地，在其他函数中，直接在需要它们的范围内运行。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/bind/doc/html/mem_fn.html">Member Function</a>：函数、对象、指针和成员函数的通用绑定器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/phoenix/doc/html/index.html">Phoenix</a>：在实际调用点定义小的匿名函数对象等。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/core/doc/html/core/ref.html">Ref</a>：用于传递对泛型函数的引用的实用程序库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/index.html#result_of">Result Of</a>：确定函数调用表达式的类型。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/signals2.html">Signals2</a>：托管信号和槽回调实现（线程安全版本 2）。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/index.html">Utility</a>：类不可复制加上 checked_delete()，checked_array_delete()，next()，prior() 函数模板，加上 base-from-member 惯用法。</li></ul><h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/utility/utilities/call_traits.html">Call Traits</a>：定义传递参数的类型。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/concept_check/concept_check.htm">Concept Check</a>：泛型编程工具。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/core/doc/html/core/enable_if.html">Enable If</a>：有选择地包含函数模板重载。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/function_types/doc/html/index.html">Function Types</a>：Boost.FunctionTypes 提供了对函数、函数指针、函数引用和成员类型指针进行分类、分解和综合的功能。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/gil/doc/html/index.html">GIL</a>：(C++14) 泛型图像库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/utility/utilities/in_place_factory.html">In Place Factory, Typed In Place Factory</a>：使用可变参数列表对包含的对象进行通用就地构造。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/utility/utilities/operators.html">Operators</a>：用模板简化了的算术类和迭代器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/property_map/doc/property_map.html">Property Map</a>：定义将键对象映射到值对象的接口的概念。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/property_map_parallel/">Property Map (Parallel)</a>：Property Map 的并行扩展，可与 Parallel Graph 一起使用。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/qvm/doc/html/index.html">QVM</a>：用于处理四元数向量和矩阵的通用 C++ 库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_staticassert.html">Static Assert</a>：静态断言（编译期断言）。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/stl_interfaces.html">Stl_interfaces</a>：用于定义迭代器、视图和容器的 C++14 及更高版本 CRTP 模板。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/tti/doc/html/index.html">TTI</a>：类型特征自省库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/type_traits/doc/html/index.html">Type Traits</a>：类型基本属性模板。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/yap.html">YAP</a>：C++14 及更高版本的表达式模板库。</li></ul><h2 id="模板元编程"><a href="#模板元编程" class="headerlink" title="模板元编程"></a>模板元编程</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/callable_traits/doc/html/index.html">CallableTraits</a>：Boost.FunctionTypes 的精神继承者，Boost.CallableTraits 是一个仅包含头文件的 C++11 库，用于编译时检查和操作所有“可调用”类型。包含对 C++17 特性的额外支持。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/describe/doc/html/describe.html">Describe</a>：一个 C++14 的反射库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/function_types/doc/html/index.html">Function Types</a>：Boost.FunctionTypes 提供了对函数、函数指针、函数引用和成员类型指针进行分类、分解和综合的功能。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/fusion/doc/html/">Fusion</a>：用于处理元组的库，包括各种容器、算法等。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/hana/doc/html/index.html">Hana</a>：现代 C++ 元编程库。它提供高级算法来操作异构序列，允许使用自然语法编写类型级计算，提供内省用户定义类型的工具等等。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/hof/doc/html/doc/index.html">HOF</a>：C++ 的高阶函数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/metaparse.html">Metaparse</a>：一个用于生成编译时解析器的库，解析嵌入式 DSL 代码作为 C++ 编译过程的一部分。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/mp11/doc/html/mp11.html">Mp11</a>：C++11 模板元编程库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/mpl/doc/index.html">MPL</a>：Boost.MPL 是一个通用的、高级的 C++ 模板元编程框架，包含编译时算法、序列和元函数。它提供了一个概念基础和一套广泛的强大而连贯的工具，使在当前语言中使用 C++ 进行显式元编程尽可能容易和愉快。</li><li><a href="https://www.boost.org/doc/libs/master/doc/html/boost_pfr.html">PFR</a>：用户定义类型的基基反射库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/proto.html">Proto</a>：用于特定领域嵌入式语言的表达式模板库和编译器构建工具包。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_staticassert.html">Static Assert</a>：静态断言（编译期断言）。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/tti/doc/html/index.html">TTI</a>：类型特征自省库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/type_traits/doc/html/index.html">Type Traits</a>：类型基本属性模板。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/yap.html">YAP</a>：C++14 及更高版本的表达式模板库。</li></ul><h2 id="预处理元编程"><a href="#预处理元编程" class="headerlink" title="预处理元编程"></a>预处理元编程</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/identity_type/doc/html/index.html">Identity Type</a>：将类型括在圆括号内，以便它们始终可以作为宏参数传递。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/preprocessor/doc/index.html">Preprocessor</a>：预处理器元编程工具，包括重复和递归。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/vmd/doc/html/index.html">VMD</a>：可变参数宏参数库。</li></ul><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_asio.html">Asio</a>：可移植的网络和其他低级 I&#x2F;O，包括套接字、定时器、主机名解析、套接字流、串行端口、文件描述符和 Windows 句柄。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/atomic/doc/html/index.html">Atomic</a>：C++11 风格的 atomic&lt;&gt;。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/beast/doc/html/index.html">Beast</a>：仅使用 C++11 和 Boost.Asio 的可移植的 HTTP、WebSocket 和网络操作。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/compute/doc/html/index.html">Compute</a>：并行&#x2F;GPU计算库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/context/doc/html/index.html">Context</a>：(C++11) 上下文切换库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/coroutine/doc/html/index.html">Coroutine (已弃用)</a>：协程库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/coroutine2/doc/html/index.html">Coroutine2</a>：(C++11) 协程库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/fiber/doc/html/index.html">Fiber</a>：(C++11) 用户态线程库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/interprocess.html">Interprocess</a>：共享内存、内存映射文件、进程共享互斥锁、条件变量、容器和分配器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/lockfree.html">Lockfree</a>：无锁数据结构。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/mpi.html">MPI</a>：消息传递接口库，用于分布式内存并行应用程序编程。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/mysql/doc/html/index.html">MySQL</a>：建立在 Boost.Asio 之上的 MySQL 客户端。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/thread.html">Thread</a>：可移植的 C++ 多线程, C++03, C++11, C++14, C++17。</li></ul><h2 id="数学与数字"><a href="#数学与数字" class="headerlink" title="数学与数字"></a>数学与数字</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/accumulators.html">Accumulators</a>：用于增量计算的框架，以及统计累加器的集合。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/endian/doc/html/endian.html">Endian</a>：用于正确字节排序等的类型和转换函数，无论处理器字节顺序如何。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/geometry/doc/html/index.html">Geometry</a>：Boost.Geometry 库提供几何算法、基元和空间索引。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/histogram/doc/html/index.html">Histogram</a>：快速多维直方图，具有方便的 C++14 接口。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/integer/doc/html/index.html">Integer</a>：组织 boost 整形头文件和类，旨在利用 1999 C 标准中的 <code>&lt;stdint.h&gt;</code> 类型，而不诉诸 1998 C++ 标准中的未定义行为。头文件 <code>&lt;boost/cstdint.hpp&gt;</code> 使标准整数类型在命名空间 boost 中安全可用，而无需在命名空间 std 中放置任何名称。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/math/doc/html/index.html">Math</a>：Boost.Math 包括在数学领域的多项贡献：浮点实用程序，特定宽度浮点类型，数学常数，统计分布，特殊函数，求根和函数最小化，多项式和有理函数，插值，数值积分和微分。许多这些特性都是模板化的，以支持内置和扩展的宽度类型（例如 Boost.Multiprecision）。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/math/doc/html/gcd_lcm.html">Math Common Factor</a>：最大公约数和最小公倍数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/math/doc/html/octonions.html">Math Octonion</a>：八元数。</li></ul><h2 id="正确性和测试"><a href="#正确性和测试" class="headerlink" title="正确性和测试"></a>正确性和测试</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/assert/doc/html/assert.html">Assert</a>：可定制的断言宏。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/concept_check/concept_check.htm">Concept Check</a>：泛型编程工具。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/contract/doc/html/index.html">Contract</a>：C++ 契约编程。所有的契约编程特性都得到了支持：转包、类不变量、后置条件（带有旧的和返回值）、先决条件、对断言失败的可定制操作（终止或抛异常）、可选的编译和检查断言等。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/safe_numerics/doc/html/index.html">Safe Numerics</a>：保证正确的整数算术。</li><li><a href="https://www.boost.org/doc/libs/master/doc/html/stacktrace.html">Stacktrace</a>：收集、存储、复制和打印回溯。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_staticassert.html">Static Assert</a>：静态断言（编译期断言）。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html">Test</a>：支持简单的程序测试、完整的单元测试以及程序执行监控。</li></ul><h2 id="错误处理和恢复"><a href="#错误处理和恢复" class="headerlink" title="错误处理和恢复"></a>错误处理和恢复</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/assert/doc/html/assert.html">Assert</a>：可定制的断言宏。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/exception/doc/boost-exception.html">Exception</a>：Boost Exception 库支持在异常对象中传输任意数据，以及在线程之间传输异常。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/leaf/doc/html/index.html">LEAF</a>：C++11 的轻量级错误处理库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/system/doc/html/system.html">System</a>：可扩展的错误报告。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/throw_exception/doc/html/throw_exception.html">ThrowException</a>：用于从 Boost 库抛出异常的通用基础设施。</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/any.html">Any</a>：用于不同值类型的单值安全、泛型容器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/bimap/doc/html/index.html">Bimap</a>：C++ 双向映射键值对容器库。 使用 Boost.Bimap，你可以创建关联容器，其两种类型都可以用作键。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/utility/utilities/compressed_pair.html">Compressed Pair</a>：空成员优化。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/container.html">Container</a>：标准库容器和拓展。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/fusion/doc/html/">Fusion</a>：用于处理元组的库，包括各种容器、算法等。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/geometry/doc/html/index.html">Geometry</a>：Boost.Geometry 库提供几何算法、基元和空间索引。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/heap.html">Heap</a>：优先级队列数据结构。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/histogram/doc/html/index.html">Histogram</a>：快速多维直方图，具有方便的 C++14 接口。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/icl/doc/html/index.html">ICL</a>：间隔容器库、间隔集合和映射以及关联值的聚合。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/json/doc/html/index.html">JSON</a>：基于 C++11 的 JSON 解析、序列化和 DOM。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/multi_index/doc/index.html">Multi-Index</a>：The Boost Multi-index Containers Library 提供了一个名为 multi_index_container 的类模板，它支持构建容器，以维护具有不同排序和访问语义的一个或多个索引。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/optional/doc/html/index.html">Optional</a>：一个值语义的、类型安全的包装器，用于表示给定类型的’optional’（或’nullable’）对象。可选对象可以包含也可以不包含基础类型的值。</li><li><a href="https://www.boost.org/doc/libs/master/doc/html/boost_pfr.html">PFR</a>：用户定义类型的基基反射库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/ptr_container/doc/ptr_container.html">Pointer Container</a>：用于存储堆分配的多态对象以简化面向对象编程的容器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/polygon/doc/index.htm">Polygon</a>：Voronoi 图构造和布尔&#x2F;裁剪、调整大小&#x2F;偏移等，适用于具有积分坐标的平面多边形。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/property_tree.html">Property Tree</a>：树形数据结构特别适合存储配置数据。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/tuple/doc/html/tuple_users_guide.html">Tuple</a>：简化返回多个值的函数的定义等。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_typeerasure.html">Type Erasure</a>：基于概念的运行时多态性。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/url/doc/html/index.html">URL</a>：C++11 的 URL 解析库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/uuid/doc/index.html">Uuid</a>：通用唯一标识符。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/variant.html">Variant</a>：安全、通用、基于堆栈的可区分联合容器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/variant2/doc/html/variant2.html">Variant2</a>：std::variant 的绝对无值、强有力的保证实现。</li></ul><h2 id="特定领域"><a href="#特定领域" class="headerlink" title="特定领域"></a>特定领域</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/chrono.html">Chrono</a>：有用的时间实用程序。C++11。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/crc.html">CRC</a>：Boost CRC 库提供了两种 CRC（循环冗余码）计算对象的实现和两种 CRC 计算函数的实现。这些实现是基于模板的。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/date_time.html">Date Time</a>：一组基于泛型编程概念的日期时间库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_units.html">Units</a>：零开销维度分析以及单位&#x2F;数量操作和转换。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/uuid/doc/index.html">Uuid</a>：通用唯一标识符。</li></ul><h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/gil/doc/html/index.html">GIL</a>：(C++14) 泛型图像库。</li></ul><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_asio.html">Asio</a>：可移植的网络和其他低级 I&#x2F;O，包括套接字、定时器、主机名解析、套接字流、串行端口、文件描述符和 Windows 句柄。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/assign/doc/index.html">Assign</a>：用常量或生成的数据填充容器从未如此简单。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/beast/doc/html/index.html">Beast</a>：仅使用 C++11 和 Boost.Asio 的可移植的 HTTP、WebSocket 和网络操作。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/endian/doc/html/endian.html">Endian</a>：用于正确字节排序等的类型和转换函数，无论处理器字节顺序如何。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/format/">Format</a>：格式化库，提供了一种类型安全机制，用于根据类似 printf 的格式字符串格式化参数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/io/doc/html/io.html">IO</a>：标准I&#x2F;O库的实用程序。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/iostreams/doc/index.html">Iostreams</a>：Boost.IOStreams 提供了一个用于定义流、流缓冲区和 I&#x2F;O 过滤器的框架。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/json/doc/html/index.html">JSON</a>：基于 C++11 的 JSON 解析、序列化和 DOM。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/mysql/doc/html/index.html">MySQL</a>：建立在 Boost.Asio 之上的 MySQL 客户端。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/program_options.html">Program Options</a>：program_options 库允许程序开发人员通过命令行和配置文件等常规方法从用户处获取程序选项，即（名称，值）对。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/serialization/doc/index.html">Serialization</a>：用于持久性和编组的序列化。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/url/doc/html/index.html">URL</a>：C++11 的 URL 解析库。</li></ul><h2 id="跨语言支持"><a href="#跨语言支持" class="headerlink" title="跨语言支持"></a>跨语言支持</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/python/doc/html/index.html">Python</a>：Boost Python 库是一个用于连接 Python 和 C++ 的框架。它允许您快速、无缝地将 C++ 类函数和对象公开给 Python，反之亦然，无需使用特殊工具 - 只需使用 C++ 编译器。</li></ul><h2 id="语言特性仿真"><a href="#语言特性仿真" class="headerlink" title="语言特性仿真"></a>语言特性仿真</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/compat/doc/html/compat.html">Compat</a>：后续 C++ 标准中添加的标准组件的 C++11 实现。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/describe/doc/html/describe.html">Describe</a>：一个 C++14 的反射库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/exception/doc/boost-exception.html">Exception</a>：Boost Exception 库支持在异常对象中传输任意数据，以及在线程之间传输异常。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/foreach.html">Foreach</a>：在 C++ 中，编写一个在序列上迭代的循环是乏味的。我们既可以使用迭代器，这需要大量的模板，也可以使用 std::for_each() 算法并将循环体移到谓词中，这需要同样多的模板，并迫使我们将逻辑移到远离使用它的地方。相反，其他一些语言，如 Perl，提供了一个专用的“foreach”结构来自动化这个过程。BOOST_FOREACH 就是 C++ 中的这样一个构造。它为我们遍历序列，使我们不必直接处理迭代器或编写谓词。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/move.html">Move</a>：用于 C++03 and C++11 编译器的可移植移动语义。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/outcome/doc/html/index.html">Outcome</a>：部分模拟轻量级异常的确定性故障处理库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/parameter/doc/html/index.html">Parameter</a>：Boost.Parameter 库 - 编写按名称接受参数的函数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/parameter_python/doc/html/index.html">Parameter Python Bindings</a>：Boost.Parameter 的 Python 绑定。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/scope_exit/doc/html/index.html">Scope Exit</a>：在作用域出口处执行任意代码。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/throw_exception/doc/html/throw_exception.html">ThrowException</a>：用于从 Boost 库抛出异常的通用基础设施。</li><li><a href="https://www.boost.org/doc/libs/master/doc/html/boost_typeindex.html">Type Index</a>：运行时&#x2F;编译时可复制的类型信息。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/typeof.html">Typeof</a>：Typeof 运算符模拟。</li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/align.html">Align</a>：内存对齐函数，分配器，特征。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/pool/doc/html/index.html">Pool</a>：内存池管理。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/smart_ptr/doc/html/smart_ptr.html">Smart Ptr</a>：智能指针模板类。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/index.html">Utility</a>：类不可复制加上 checked_delete()，checked_array_delete()，next()，prior() 函数模板，加上 base-from-member 惯用法。</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/spirit/doc/html/index.html">Spirit</a>：LL 解析器框架，将解析器直接表示为内联 C++ 中的 EBNF 语法。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/spirit/classic/">Spirit Classic</a>：LL 解析器框架，将解析器直接表示为内联 C++ 中的 EBNF 语法。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/spirit/repository/doc/html/index.html">Spirit Repository</a>：Spirit Repository 是一个社区的成果，它为 Qi 解析器和 Karma 生成器收集了不同的可重用组件(原语、指令、语法等)。</li></ul><h2 id="模式和习语"><a href="#模式和习语" class="headerlink" title="模式和习语"></a>模式和习语</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/utility/utilities/compressed_pair.html">Compressed Pair</a>：空成员优化。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/flyweight/doc/index.html">Flyweight</a>：用于管理大量高度冗余对象的设计模式。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/outcome/doc/html/index.html">Outcome</a>：部分模拟轻量级异常的确定性故障处理库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/signals2.html">Signals2</a>：托管信号和槽回调实现（线程安全版本 2）。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/index.html">Utility</a>：类不可复制加上 checked_delete()，checked_array_delete()，next()，prior() 函数模板，加上 base-from-member 惯用法。</li></ul><h2 id="编程接口"><a href="#编程接口" class="headerlink" title="编程接口"></a>编程接口</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/compat/doc/html/compat.html">Compat</a>：后续 C++ 标准中添加的标准组件的 C++11 实现。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/function.html">Function</a>：用于延迟调用或回调的函数对象包装器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/outcome/doc/html/index.html">Outcome</a>：部分模拟轻量级异常的确定性故障处理库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/parameter/doc/html/index.html">Parameter</a>：Boost.Parameter 库 - 编写按名称接受参数的函数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/parameter_python/doc/html/index.html">Parameter Python Bindings</a>：Boost.Parameter 的 Python 绑定。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/system/doc/html/system.html">System</a>：可扩展的错误报告。</li></ul><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/msm/doc/HTML/index.html">Meta State Machine</a>：一个非常高性能的库，用于表达UML2有限状态机。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/statechart/doc/index.html">Statechart</a>：Boost.Statechart - C++ 代码实现的易于阅读和维护的可用于任意复杂度的有限状态机。</li></ul><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/chrono.html">Chrono</a>：有用的时间实用程序。C++11。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/context/doc/html/index.html">Context</a>：(C++11) 上下文切换库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/date_time.html">Date Time</a>：一组基于泛型编程概念的日期时间库。</li><li><a href="https://www.boost.org/doc/libs/master/doc/html/boost_dll.html">DLL</a>：用于轻松使用 DLL 和 DSO 的库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/fiber/doc/html/index.html">Fiber</a>：(C++11) 用户态线程库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/filesystem/doc/index.htm">Filesystem</a>：Boost Filesystem 库提供了可移植的工具来查询和操作路径、文件和目录。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/nowide/doc/html/index.html">Nowide</a>：在 Windows 上使用 UTF-8 API 的标准库函数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/process.html">Process</a>：以可移植的方式创建流程的库。</li><li><a href="https://www.boost.org/doc/libs/master/doc/html/stacktrace.html">Stacktrace</a>：收集、存储、复制和打印回溯。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/system/doc/html/system.html">System</a>：可扩展的错误报告。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/thread.html">Thread</a>：可移植的 C++ 多线程, C++03, C++11, C++14, C++17。</li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li><a href="https://www.boost.org/doc/libs/master/doc/html/conversion.html">Conversion</a>：多态转换。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/convert/doc/html/index.html">Convert</a>：一个可扩展且可配置的类型转换框架。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/core/doc/html/index.html">Core</a>：具有最低依赖性的简单核心实用程序的集合。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/endian/doc/html/endian.html">Endian</a>：用于正确字节排序等的类型和转换函数，无论处理器字节顺序如何。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_lexical_cast.html">Lexical Cast</a>：一般文字文本转换，例如 int 表示字符串，反之亦然。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/log/doc/html/index.html">Log</a>：日志库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/numeric/conversion/doc/html/index.html">Numeric Conversion</a>：优化的基于策略的数字转换。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/predef/doc/index.html">Predef</a>：该库从它可以收集的 C、C、Objective C 和 Objective C 预定义宏或通用头文件中定义的信息中定义了一组编译器、体系结构、操作系统、库和其他版本号。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/program_options.html">Program Options</a>：program_options 库允许程序开发人员通过命令行和配置文件等常规方法从用户处获取程序选项，即（名称，值）对。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/core/doc/html/core/swap.html">Swap</a>：增强通用交换功能。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/timer/doc/index.html">Timer</a>：事件计时器、进度计时器和进度显示类。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/tribool.html">Tribool</a>：三状态布尔类型库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/index.html">Utility</a>：类不可复制加上 checked_delete()，checked_array_delete()，next()，prior() 函数模板，加上 base-from-member 惯用法。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/utility/utilities/value_init.html">Value Initialized</a>：基于 David Abrahams 的原始想法，统一语法值初始化的包装器。</li></ul><h2 id="破碎编译器解决方案"><a href="#破碎编译器解决方案" class="headerlink" title="破碎编译器解决方案"></a>破碎编译器解决方案</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/compatibility/">Compatibility</a>：针对不合格标准库的帮助。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/config/doc/html/index.html">Config</a>：帮助 Boost 库开发人员适应编译器特性；不适合库用户。</li></ul><h1 id="按名称排序"><a href="#按名称排序" class="headerlink" title="按名称排序"></a>按名称排序</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/accumulators.html">Accumulators</a>：用于增量计算的框架，以及统计累加器的集合。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/algorithm/doc/html/index.html">Algorithm</a>：一个有用的泛型算法的集合。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/align.html">Align</a>：内存对齐函数，分配器，特征。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/any.html">Any</a>：用于不同值类型的单值安全、泛型容器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/array.html">Array</a>：与 STL 兼容的容器包装器，用于常量大小的数组。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_asio.html">Asio</a>：可移植的网络和其他低级 I&#x2F;O，包括套接字、定时器、主机名解析、套接字流、串行端口、文件描述符和 Windows 句柄。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/assert/doc/html/assert.html">Assert</a>：可定制的断言宏。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/assign/doc/index.html">Assign</a>：用常量或生成的数据填充容器从未如此简单。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/atomic/doc/html/index.html">Atomic</a>：C++11 风格的 atomic&lt;&gt;。</li></ul><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/beast/doc/html/index.html">Beast</a>：仅使用 C++11 和 Boost.Asio 的可移植的 HTTP、WebSocket 和网络操作。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/bimap/doc/html/index.html">Bimap</a>：C++ 双向映射键值对容器库。 使用 Boost.Bimap，你可以创建关联容器，其两种类型都可以用作键。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/bind/doc/html/bind.html">Bind</a>：boost::bind 标准库函数 <code>std::bind1st</code> 和 <code>std::bind2nd</code> 的泛化。它支持任意函数对象、函数、函数指针和成员函数指针，并且能够将任何参数绑定到特定值或将输入参数路由到任意位置。</li></ul><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/utility/utilities/call_traits.html">Call Traits</a>：定义传递参数的类型。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/callable_traits/doc/html/index.html">CallableTraits</a>：Boost.FunctionTypes 的精神继承者，Boost.CallableTraits 是一个仅包含头文件的 C++11 库，用于编译时检查和操作所有“可调用”类型。包含对 C++17 特性的额外支持。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/chrono.html">Chrono</a>：有用的时间实用程序。C++11。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/circular_buffer.html">Circular Buffer</a>：符合 STL 的容器也称为环或循环缓冲区。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/compat/doc/html/compat.html">Compat</a>：后续 C++ 标准中添加的标准组件的 C++11 实现。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/compatibility/">Compatibility</a>：针对不合格标准库的帮助。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/utility/utilities/compressed_pair.html">Compressed Pair</a>：空成员优化。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/compute/doc/html/index.html">Compute</a>：并行&#x2F;GPU计算库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/concept_check/concept_check.htm">Concept Check</a>：泛型编程工具。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/config/doc/html/index.html">Config</a>：帮助 Boost 库开发人员适应编译器特性；不适合库用户。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/container.html">Container</a>：标准库容器和拓展。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/container_hash/doc/html/hash.html">Container Hash</a>：与 STL 兼容的哈希函数对象，可以扩展哈希到用户定义的类型。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/context/doc/html/index.html">Context</a>：(C++11) 上下文切换库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/contract/doc/html/index.html">Contract</a>：C++ 契约编程。所有的契约编程特性都得到了支持：转包、类不变量、后置条件（带有旧的和返回值）、先决条件、对断言失败的可定制操作（终止或抛异常）、可选的编译和检查断言等。</li><li><a href="https://www.boost.org/doc/libs/master/doc/html/conversion.html">Conversion</a>：多态转换。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/convert/doc/html/index.html">Convert</a>：可扩展且可配置的类型转换框架。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/core/doc/html/index.html">Core</a>：具有最低依赖性的简单核心实用程序的集合。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/coroutine/doc/html/index.html">Coroutine (已弃用)</a>：协程库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/coroutine2/doc/html/index.html">Coroutine2</a>：(C++11) 协程库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/crc.html">CRC</a>：Boost CRC 库提供了两种 CRC（循环冗余码）计算对象的实现和两种 CRC 计算函数的实现。这些实现是基于模板的。</li></ul><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/date_time.html">Date Time</a>：一组基于泛型编程概念的日期时间库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/describe/doc/html/describe.html">Describe</a>：一个 C++14 的反射库。</li><li><a href="https://www.boost.org/doc/libs/master/doc/html/boost_dll.html">DLL</a>：用于轻松使用 DLL 和 DSO 的库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/dynamic_bitset/dynamic_bitset.html">Dynamic Bitset</a>：dynamic_bitset 类表示一组二进制位。它通过 operator[] 提供对各个位的值的访问，并提供可应用于内置整数的所有按位运算符，例如 operator&amp; 和 operator&lt;&lt;。该集合中的位数是在运行时通过 dynamic_bitset 构造函数的参数指定的。</li></ul><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/core/doc/html/core/enable_if.html">Enable If</a>：有选择地包含函数模板重载。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/endian/doc/html/endian.html">Endian</a>：用于正确字节排序等的类型和转换函数，无论处理器字节顺序如何。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/exception/doc/boost-exception.html">Exception</a>：Boost Exception 库支持在异常对象中传输任意数据，以及在线程之间传输异常。</li></ul><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/fiber/doc/html/index.html">Fiber</a>：(C++11) 用户态线程库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/filesystem/doc/index.htm">Filesystem</a>：Boost Filesystem 库提供了可移植的工具来查询和操作路径、文件和目录。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/flyweight/doc/index.html">Flyweight</a>：用于管理大量高度冗余对象的设计模式。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/foreach.html">Foreach</a>：在 C++ 中，编写一个在序列上迭代的循环是乏味的。我们既可以使用迭代器，这需要大量的模板，也可以使用 std::for_each() 算法并将循环体移到谓词中，这需要同样多的模板，并迫使我们将逻辑移到远离使用它的地方。相反，其他一些语言，如 Perl，提供了一个专用的“foreach”结构来自动化这个过程。BOOST_FOREACH 就是 C++ 中的这样一个构造。它为我们遍历序列，使我们不必直接处理迭代器或编写谓词。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/format/">Format</a>：格式库提供了一种用于根据类似 printf 的格式字符串格式化参数的类型安全机制。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/function.html">Function</a>：用于延迟调用或回调的函数对象包装器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/function_types/doc/html/index.html">Function Types</a>：Boost.FunctionTypes 提供了对函数、函数指针、函数引用和成员类型指针进行分类、分解和综合的功能。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/functional/">Functional</a>：Boost.Function 库包含一系列类模板，它们是函数对象包装器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/functional/factory/doc/html/index.html">Functional&#x2F;Factory</a>：用于创建动态和静态对象的函数对象模板。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/functional/forward/doc/html/index.html">Functional&#x2F;Forward</a>：允许泛型函数对象接受任意参数的适配器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/functional/overloaded_function/doc/html/index.html">Functional&#x2F;Overloaded Function</a>：将不同的函数重载到单个函数对象中。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/fusion/doc/html/">Fusion</a>：用于处理元组的库，包括各种容器、算法等。</li></ul><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/geometry/doc/html/index.html">Geometry</a>：Boost.Geometry 库提供几何算法、基元和空间索引。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/gil/doc/html/index.html">GIL</a>：(C++14) 泛型图像库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/graph/doc/index.html">Graph</a>：BGL 图接口和图组件是泛型的，与标准模板库 (STL) 具有相同的意义。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/graph_parallel/doc/html/index.html">GraphParallel</a>：PBGL 图接口和图组件是泛型的，与标准模板库 (STL) 的意义相同。</li></ul><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/hana/doc/html/index.html">Hana</a>：现代 C++ 元编程库。它提供高级算法来操作异构序列，允许使用自然语法编写类型级计算，提供内省用户定义类型的工具等等。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/heap.html">Heap</a>：优先级队列数据结构。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/histogram/doc/html/index.html">Histogram</a>：快速多维直方图，具有方便的 C++14 接口。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/hof/doc/html/doc/index.html">HOF</a>：C++ 的高阶函数。</li></ul><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/icl/doc/html/index.html">ICL</a>：间隔容器库、间隔集合和映射以及关联值的聚合。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/identity_type/doc/html/index.html">Identity Type</a>：将类型括在圆括号内，以便它们始终可以作为宏参数传递。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/utility/utilities/in_place_factory.html">In Place Factory, Typed In Place Factory</a>：使用可变参数列表对包含的对象进行通用就地构造。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/integer/doc/html/index.html">Integer</a>：组织 boost 整形头文件和类，旨在利用 1999 C 标准中的 <code>&lt;stdint.h&gt;</code> 类型，而不诉诸 1998 C++ 标准中的未定义行为。头文件 <code>&lt;boost/cstdint.hpp&gt;</code> 使标准整数类型在命名空间 boost 中安全可用，而无需在命名空间 std 中放置任何名称。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/interprocess.html">Interprocess</a>：共享内存、内存映射文件、进程共享互斥锁、条件变量、容器和分配器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/numeric/interval/doc/interval.htm">Interval</a>：将常用的算术函数扩展到数学区间。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/intrusive.html">Intrusive</a>：侵入式容器和算法。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/io/doc/html/io.html">IO</a>：标准I&#x2F;O库的实用程序。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/iostreams/doc/index.html">Iostreams</a>：Boost.IOStreams 提供了一个定义流、流缓冲区和 I&#x2F;O 过滤器的框架。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/iterator/doc/index.html">Iterator</a>：Boost 迭代器库包含两部分。第一个是扩展 C++ 标准迭代器需求的概念系统。第二个是一个组件框架，用于基于这些扩展的概念构建迭代器，并包括几个有用的迭代器适配器。</li></ul><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/json/doc/html/index.html">JSON</a>：基于 C++11 的 JSON 解析、序列化和 DOM。</li></ul><h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/lambda.html">Lambda</a>：在实际调用地点定义小型匿名函数对象等。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/lambda2/doc/html/lambda2.html">Lambda2</a>：C++14 的 lambda 库.</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/leaf/doc/html/index.html">LEAF</a>：C++11 的轻量级错误处理库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_lexical_cast.html">Lexical Cast</a>：一般文字文本转换，例如将 int 表示为字符串，或相反。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/local_function/doc/html/index.html">Local Function</a>：程序在本地，在其他函数中，直接在需要它们的范围内运行。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/locale/doc/html/index.html">Locale</a>：为 C++ 提供本地化和 Unicode 处理工具。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/lockfree.html">Lockfree</a>：无锁数据结构。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/log/doc/html/index.html">Log</a>：日志库。</li></ul><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/math/doc/html/index.html">Math</a>：Boost.Math 包括在数学领域的多项贡献：浮点实用程序，特定宽度浮点类型，数学常数，统计分布，特殊函数，求根和函数最小化，多项式和有理函数，插值，数值积分和微分。许多这些特性都是模板化的，以支持内置和扩展的宽度类型（例如 Boost.Multiprecision）。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/math/doc/html/gcd_lcm.html">Math Common Factor</a>：最大公约数和最小公倍数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/math/doc/html/octonions.html">Math Octonion</a>：八元数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/math/doc/html/quaternions.html">Math Quaternion</a>：四元数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/math/doc/html/special.html">Math&#x2F;Special Functions</a>：多种可供选择的数学特殊函数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/math/doc/html/dist.html">Math&#x2F;Statistical Distributions</a>：多种单变量统计分布和对其进行运算的函数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/bind/doc/html/mem_fn.html">Member Function</a>：函数、对象、指针和成员函数的通用绑定器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/msm/doc/HTML/index.html">Meta State Machine</a>：一个非常高性能的库，用于表达UML2有限状态机。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/metaparse.html">Metaparse</a>：一个用于生成编译时解析器的库，解析嵌入式 DSL 代码作为 C++ 编译过程的一部分。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/algorithm/minmax/">Min-Max</a>：同时进行最小&#x2F;最大和最小&#x2F;最大元素计算的标准库扩展。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/move.html">Move</a>：用于 C++03 and C++11 编译器的可移植移动语义。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/mp11/doc/html/mp11.html">Mp11</a>：C++11 模板元编程库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/mpi.html">MPI</a>：消息传递接口库，用于分布式内存并行应用程序编程。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/mpl/doc/index.html">MPL</a>：Boost.MPL 是一个通用的、高级的 C++ 模板元编程框架，包含编译时算法、序列和元函数。它提供了一个概念基础和一套广泛的强大而连贯的工具，使在当前语言中使用 C++ 进行显式元编程尽可能容易和愉快。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/multi_array/doc/index.html">Multi-Array</a>：Boost.MultiArray 提供了一个通用的 N 维数组概念定义和该接口的通用实现。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/multi_index/doc/index.html">Multi-Index</a>：The Boost Multi-index Containers Library 提供了一个名为 multi_index_container 的类模板，它支持构建容器，以维护具有不同排序和访问语义的一个或多个索引。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/multiprecision/doc/html/index.html">Multiprecision</a>：浮点、整数和有理数算术的扩展精度算术类型。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/mysql/doc/html/index.html">MySQL</a>：建立在 Boost.Asio 之上的 MySQL 客户端。</li></ul><h2 id="N"><a href="#N" class="headerlink" title="N"></a>N</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/nowide/doc/html/index.html">Nowide</a>：在 Windows 上使用 UTF-8 API 的标准库函数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/numeric/conversion/doc/html/index.html">Numeric Conversion</a>：优化的基于策略的数字转换。</li></ul><h2 id="O"><a href="#O" class="headerlink" title="O"></a>O</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/numeric/odeint/doc/html/index.html">Odeint</a>：解常微分方程。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/utility/utilities/operators.html">Operators</a>：用模板简化了的算术类和迭代器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/optional/doc/html/index.html">Optional</a>：一个值语义的、类型安全的包装器，用于表示给定类型的’optional’（或’nullable’）对象。可选对象可以包含也可以不包含基础类型的值。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/outcome/doc/html/index.html">Outcome</a>：部分模拟轻量级异常的确定性故障处理库。</li></ul><h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/parameter/doc/html/index.html">Parameter</a>：Boost.Parameter 库 - 编写按名称接受参数的函数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/parameter_python/doc/html/index.html">Parameter Python Bindings</a>：Boost.Parameter 的 Python 绑定。</li><li><a href="https://www.boost.org/doc/libs/master/doc/html/boost_pfr.html">PFR</a>：用户定义类型的基基反射库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/phoenix/doc/html/index.html">Phoenix</a>：在实际调用点定义小的匿名函数对象等。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/ptr_container/doc/ptr_container.html">Pointer Container</a>：用于存储堆分配的多态对象以简化面向对象编程的容器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/poly_collection.html">PolyCollection</a>：多态对象的快速容器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/polygon/doc/index.htm">Polygon</a>：Voronoi 图构造和布尔&#x2F;裁剪、调整大小&#x2F;偏移等，适用于具有积分坐标的平面多边形。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/pool/doc/html/index.html">Pool</a>：内存池管理。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/predef/doc/index.html">Predef</a>：该库从它可以收集的 C、C、Objective C 和 Objective C 预定义宏或通用头文件中定义的信息中定义了一组编译器、体系结构、操作系统、库和其他版本号。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/preprocessor/doc/index.html">Preprocessor</a>：预处理器元编程工具，包括重复和递归。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/process.html">Process</a>：以可移植的方式创建流程的库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/program_options.html">Program Options</a>：program_options 库允许程序开发人员通过命令行和配置文件等常规方法从用户处获取程序选项，即（名称，值）对。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/property_map/doc/property_map.html">Property Map</a>：定义将键对象映射到值对象的接口的概念。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/property_map_parallel/">Property Map (Parallel)</a>：Property Map 的并行扩展，可与 Parallel Graph 一起使用。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/property_tree.html">Property Tree</a>：树形数据结构特别适合存储配置数据。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/proto.html">Proto</a>：用于特定领域嵌入式语言的表达式模板库和编译器构建工具包。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/python/doc/html/index.html">Python</a>：Boost Python 库是一个用于连接 Python 和 C++ 的框架。它允许您快速、无缝地将 C++ 类函数和对象公开给 Python，反之亦然，无需使用特殊工具 - 只需使用 C++ 编译器。</li></ul><h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/qvm/doc/html/index.html">QVM</a>：用于处理四元数向量和矩阵的通用 C++ 库。</li></ul><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_random.html">Random</a>：一个完整的随机数生成系统。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/range/doc/html/index.html">Range</a>：建立在新式迭代器概念之上的泛型算法的新基础设施。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/ratio.html">Ratio</a>：编译时有理算术。C++11。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/rational/">Rational</a>：有理数类。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/core/doc/html/core/ref.html">Ref</a>：用于传递对泛型函数的引用的实用程序库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/regex/doc/html/index.html">Regex</a>：正则表达式库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/index.html#result_of">Result Of</a>：确定函数调用表达式的类型。</li></ul><h2 id="S"><a href="#S" class="headerlink" title="S"></a>S</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/safe_numerics/doc/html/index.html">Safe Numerics</a>：保证正确的整数算术。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/scope_exit/doc/html/index.html">Scope Exit</a>：在作用域出口处执行任意代码。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/serialization/doc/index.html">Serialization</a>：用于持久性和编组的序列化。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/signals2.html">Signals2</a>：托管信号和槽回调实现（线程安全版本 2）。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/smart_ptr/doc/html/smart_ptr.html">Smart Ptr</a>：智能指针模板类。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/sort/doc/html/index.html">Sort</a>：高性能模板化排序函数。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/spirit/doc/html/index.html">Spirit</a>：LL 解析器框架，将解析器直接表示为内联 C++ 中的 EBNF 语法。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/spirit/classic/">Spirit Classic</a>：LL 解析器框架，将解析器直接表示为内联 C++ 中的 EBNF 语法。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/spirit/repository/doc/html/index.html">Spirit Repository</a>：Spirit 存储库是一个社区的成果，为 Qi 解析器和 Karma 生成器收集不同的可重用组件（原语、指令、语法等）。</li><li><a href="https://www.boost.org/doc/libs/master/doc/html/stacktrace.html">Stacktrace</a>：收集、存储、复制和打印回溯。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/statechart/doc/index.html">Statechart</a>：Boost.Statechart - C++ 代码实现的易于阅读和维护的可用于任意复杂度的有限状态机。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_staticassert.html">Static Assert</a>：静态断言（编译期断言）。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/static_string/doc/html/index.html">Static String</a>：固定容量、动态大小的字符串。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/stl_interfaces.html">Stl_interfaces</a>：用于定义迭代器、视图和容器的 C++14 及更高版本 CRTP 模板。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/string_algo.html">String Algo</a>：字符串算法库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/string_ref.html">String Ref</a>：字符串视图模板。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/core/doc/html/core/swap.html">Swap</a>：增强通用交换功能。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/system/doc/html/system.html">System</a>：可扩展的错误报告。</li></ul><h2 id="T"><a href="#T" class="headerlink" title="T"></a>T</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html">Test</a>：支持简单的程序测试、完整的单元测试以及程序执行监控。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/thread.html">Thread</a>：可移植的 C++ 多线程, C++03, C++11, C++14, C++17。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/throw_exception/doc/html/throw_exception.html">ThrowException</a>：用于从 Boost 库抛出异常的通用基础设施。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/timer/doc/index.html">Timer</a>：事件计时器、进度计时器和进度显示类。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/tokenizer/doc/index.html">Tokenizer</a>：将字符串或其他字符序列分解为一系列标记。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/tribool.html">Tribool</a>：三状态布尔类型库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/tti/doc/html/index.html">TTI</a>：类型特征自省库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/tuple/doc/html/tuple_users_guide.html">Tuple</a>：简化返回多个值的函数的定义等。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_typeerasure.html">Type Erasure</a>：基于概念的运行时多态性。</li><li><a href="https://www.boost.org/doc/libs/master/doc/html/boost_typeindex.html">Type Index</a>：运行时&#x2F;编译时可复制的类型信息。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/type_traits/doc/html/index.html">Type Traits</a>：类型基本属性模板。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/typeof.html">Typeof</a>：Typeof 运算符模拟。</li></ul><h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/numeric/ublas/doc/index.html">uBLAS</a>：uBLAS 提供张量、矩阵和向量类以及基本线性代数例程。支持多种密集、压缩和稀疏存储方案。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_units.html">Units</a>：零开销维度分析以及单位&#x2F;数量操作和转换。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/unordered/doc/html/unordered.html">Unordered</a>：无序关联容器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/url/doc/html/index.html">URL</a>：C++11 的 URL 解析库。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/index.html">Utility</a>：类不可复制加上 checked_delete()，checked_array_delete()，next()，prior() 函数模板，加上 base-from-member 惯用法。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/uuid/doc/index.html">Uuid</a>：通用唯一标识符。</li></ul><h2 id="V"><a href="#V" class="headerlink" title="V"></a>V</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/utility/doc/html/utility/utilities/value_init.html">Value Initialized</a>：基于 David Abrahams 的原始想法，统一语法值初始化的包装器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/variant.html">Variant</a>：安全、通用、基于堆栈的可区分联合容器。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/variant2/doc/html/variant2.html">Variant2</a>：std::variant 的绝对无值、强有力的保证实现。</li><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/vmd/doc/html/index.html">VMD</a>：可变参数宏参数库。</li></ul><h2 id="W"><a href="#W" class="headerlink" title="W"></a>W</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/libs/wave/">Wave</a>：Boost.Wave 库符合标准，是强制性 C99&#x2F;C++ 预处理器功能的高度可配置实现，封装在易于使用的迭代器接口后面。</li></ul><h2 id="X"><a href="#X" class="headerlink" title="X"></a>X</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/xpressive.html">Xpressive</a>：可以编写为字符串或表达式模板的正则表达式，并且可以利用上下文无关语法的功能递归地相互引用和自身引用。</li></ul><h2 id="Y"><a href="#Y" class="headerlink" title="Y"></a>Y</h2><ul><li><a href="https://www.boost.org/doc/libs/1_83_0/doc/html/yap.html">YAP</a>：C++14 及更高版本的表达式模板库。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Boost</tag>
      
      <tag>第三方库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Range-v3 库官方文档</title>
    <link href="/2023/08/15/range-library-guide/"/>
    <url>/2023/08/15/range-library-guide/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++14&#x2F;17&#x2F;20 的范围库。此代码是 C++20 中范围支持的基础。</p><p><strong>开发状态</strong></p><p>这些代码相当稳定，经过充分测试，适合随意使用，尽管目前缺乏文档。不做出任何有关支持或长期稳定性的承诺。该代码将不断发展，而不考虑向后兼容性。</p><p>一个需要注意的例外是在 range::cpp20 命名空间中找到的任何内容。这些组件很少改变或者（最好）永远不会改变。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>该库仅包含头文件。您可以从 github 上的 range-v3 存储库获取源代码。要使用 Range-v3 进行编译，只需 #include 您想要的各个标头。</p><p>该发行版实际上包含三个独立的仅头文件库：</p><ul><li><strong>include&#x2F;concepts&#x2F;…</strong> 包含概念可移植性预处理器 (CPP)，它是一组用于定义和使用概念检查的宏，无论您的编译器是否恰好支持 C++20 概念语言功能。</li><li><strong>include&#x2F;meta&#x2F;…</strong> 包含元库，它是一组元编程实用程序，用于在编译时处理类型和类型列表。</li><li><strong>include&#x2F;range&#x2F;…</strong> 包含 Range-v3 库，如下所述。</li></ul><p>Range-v3 库的物理结构按功能组划分在目录中：</p><ul><li><strong>include&#x2F;range&#x2F;v3&#x2F;actions&#x2F;…</strong> 包含操作或可组合组件，它们在容器上急切地操作并返回变异容器以进行进一步操作。</li><li><strong>include&#x2F;range&#x2F;v3&#x2F;algorithms&#x2F;…</strong> 除了熟悉的采用迭代器的重载之外，还包含所有具有接受范围重载的 STL 算法。</li><li><strong>include&#x2F;range&#x2F;v3&#x2F;functional&#x2F;…</strong> 包含许多函数式程序员熟悉的常用组件。</li><li><strong>include&#x2F;range&#x2F;v3&#x2F;iterator&#x2F;…</strong> 包含许多有用的迭代器以及与迭代器相关的概念和实用程序的定义。</li><li><strong>include&#x2F;range&#x2F;v3&#x2F;numeric&#x2F;…</strong> 包含与标准<code>&lt;numeric&gt;</code>标头中的算法相对应的数值算法。</li><li><strong>include&#x2F;range&#x2F;v3&#x2F;range&#x2F;…</strong> 包含与范围相关的实用程序，例如开始、结束和大小、范围特征和概念以及容器的转换。</li><li><strong>include&#x2F;range&#x2F;v3&#x2F;utility&#x2F;…</strong> 包含各种可重用代码。</li><li><strong>include&#x2F;range&#x2F;v3&#x2F;view&#x2F;…</strong> 包含视图或可组合组件，它们在范围上延迟操作，并且本身返回可以使用附加视图适配器进行操作的范围。</li></ul><h3 id="许可"><a href="#许可" class="headerlink" title="许可"></a>许可</h3><p>这个项目中的大部分源代码都是我的，并且都在 Boost Software License 下。 部分内容取自 Alex Stepanov 的 Elements of Programming、Howard Hinnant 的 libc 以及 SGI STL。 请参阅随附的许可证文件和 CREDITS 文件以获取许可和确认。</p><h3 id="支持的编译器"><a href="#支持的编译器" class="headerlink" title="支持的编译器"></a>支持的编译器</h3><p>已知该代码可在以下编译器上运行：</p><ul><li>clang 5.0</li><li>GCC 6.5</li><li>Clang&#x2F;LLVM 6 (or later) on Windows</li><li>MSVC VS2019, with &#x2F;permissive- and either &#x2F;std:c++latest, &#x2F;std:c++20, or &#x2F;std:c++17</li></ul><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>Range-v3 是一个通用库，它通过使用范围的工具来增强现有的标准库。 范围可以粗略地认为是一对迭代器，尽管它们不需要以这种方式实现。 将开始&#x2F;结束迭代器捆绑到单个对象中会带来几个好处：方便、可组合性和正确性。</p><p><strong>方便</strong><br>将单个范围对象传递给算法比单独的开始&#x2F;结束迭代器更方便。对比：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v&#123;<span class="hljs-comment">/*...*/</span>&#125;;<br>std::<span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><p>与</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v&#123;<span class="hljs-comment">/*...*/</span>&#125;;<br>ranges::<span class="hljs-built_in">sort</span>(v);<br></code></pre></td></tr></table></figure><p>Range-v3 包含所有标准算法的完整实现，并具有基于范围的重载，以方便使用。</p><p><strong>可组合</strong><br>拥有单个范围对象允许操作的管道。 在管道中，范围以某种方式进行延迟适应或急切突变，结果立即可用于进一步适应或突变。 延迟适应由视图处理，急切突变由操作处理。</p><p>例如，下面使用视图通过谓词过滤容器，并使用函数转换结果范围。请注意，底层数据是常量，不会因视图而改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-type">const</span> vi&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ranges;<br><span class="hljs-keyword">auto</span> rng = vi | views::<span class="hljs-built_in">remove_if</span>([](<span class="hljs-type">int</span> i) &#123; <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>; &#125;)<br>              | views::<span class="hljs-built_in">transform</span>([](<span class="hljs-type">int</span> i) &#123; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">to_string</span>(i); &#125;);<br><span class="hljs-comment">// rng == &#123;&quot;2&quot;,&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;10&quot;&#125;;</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，rng 只是存储对基础数据以及过滤器和转换函数的引用。在迭代 rng 之前不会完成任何工作。</p><p>相比之下，动作热切地完成它们的工作，但它们也构成了。考虑下面的代码，它将一些数据读入向量，对其进行排序，并使其唯一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">extern</span> std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">read_data</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ranges;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; vi = <span class="hljs-built_in">read_data</span>() | actions::sort | actions::unique;<br></code></pre></td></tr></table></figure><p>与视图不同，管道中的每个步骤（actions::sort 和 actions::unique）都通过操作按值接受容器，就地改变它，然后返回它。</p><p><strong>正确性</strong><br>无论您使用视图还是操作，您都是以纯函数式、声明式的方式操作数据。您很少需要为迭代器烦恼，尽管如果您需要它们，它们就在幕后。</p><p>通过以声明性和功能性方式而不是命令性地操作，我们减少了对公开状态操作以及分支和循环的需求。这会减少程序可以处于的状态数量，从而减少错误数量。</p><p>简而言之，如果您能找到一种方法将您的解决方案表达为数据上的函数转换的组合，则可以通过构造使您的代码正确。</p><h3 id="视图-Views"><a href="#视图-Views" class="headerlink" title="视图(Views)"></a>视图(Views)</h3><p>如上所述，范围相对于迭代器的一大优点是它们的可组合性。它们允许一种函数式编程，其中通过一系列组合器传递数据来操纵数据。此外，组合器可以是惰性的，仅在请求答案时才工作，并且是纯函数式的，不会改变原始数据。这使得你更容易推理你的代码。</p><p>视图是一种轻量级包装器，它以某种自定义方式呈现底层元素序列的视图，而无需对其进行更改或复制。视图的创建和复制成本低廉，并且具有非拥有引用语义。以下是一些使用视图的示例：</p><p>使用谓词过滤容器并对其进行转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-type">const</span> vi&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ranges;<br><span class="hljs-keyword">auto</span> rng = vi | views::<span class="hljs-built_in">remove_if</span>([](<span class="hljs-type">int</span> i)&#123;<span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>;&#125;)<br>              | views::<span class="hljs-built_in">transform</span>([](<span class="hljs-type">int</span> i)&#123;<span class="hljs-keyword">return</span> std::<span class="hljs-built_in">to_string</span>(i);&#125;);<br><span class="hljs-comment">// rng == &#123;&quot;2&quot;,&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;10&quot;&#125;;</span><br></code></pre></td></tr></table></figure><p>生成从 1 开始的无限整数列表，对它们求平方，取前 10 个，并对它们求和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ranges;<br><span class="hljs-type">int</span> sum = <span class="hljs-built_in">accumulate</span>(views::<span class="hljs-built_in">ints</span>(<span class="hljs-number">1</span>)<br>                   | views::<span class="hljs-built_in">transform</span>([](<span class="hljs-type">int</span> i)&#123;<span class="hljs-keyword">return</span> i*i;&#125;)<br>                   | views::<span class="hljs-built_in">take</span>(<span class="hljs-number">10</span>), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>使用范围推导式动态生成一个序列，并用它初始化一个向量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ranges;<br><span class="hljs-keyword">auto</span> vi = views::for_each(views::<span class="hljs-built_in">ints</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>), [](<span class="hljs-type">int</span> i) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">yield_from</span>(views::<span class="hljs-built_in">repeat_n</span>(i, i));<br>    &#125;)<br>  | <span class="hljs-built_in">to</span>&lt;std::vector&gt;();<br><span class="hljs-comment">// vi == &#123;1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,...&#125;</span><br></code></pre></td></tr></table></figure><h3 id="视图的常量性"><a href="#视图的常量性" class="headerlink" title="视图的常量性"></a>视图的常量性</h3><p>从逻辑上讲，视图是迭代器的工厂，但实际上视图通常被实现为状态机，状态存储在视图对象本身中（以保持迭代器较小），并在视图迭代时发生变化。因为视图包含可变状态，所以许多视图缺少 const 限定的begin()&#x2F;end()。当提供 begin()&#x2F;end() 的 const 版本时，它们是真正的 const；也就是说，线程安全。</p><p>由于视图呈现了与容器相同的接口，因此很容易认为它们在常量性方面的行为与容器相似。事实并非如此。它们在常量性方面的行为类似于迭代器和指针。</p><p>视图的常量性与基础数据的常量性无关。 非常量视图可以引用本身是常量的元素，反之亦然。 这类似于指针； int* const 是指向可变 int 的 const 指针，int const* 是指向 const int 的非常量指针。</p><p>尽可能使用非常量视图。如果您需要线程安全，请在线程中使用视图副本；不要共享。</p><h3 id="视图的有效性"><a href="#视图的有效性" class="headerlink" title="视图的有效性"></a>视图的有效性</h3><p>对基础范围进行的任何使其迭代器或标记无效的操作也将使引用该范围任何部分的任何视图无效。 此外，当范围的底层元素发生变化时，某些视图（例如，views::filter）会失效。 最好在任何可能改变底层范围的操作之后重新创建视图。</p><h3 id="视图列表"><a href="#视图列表" class="headerlink" title="视图列表"></a>视图列表</h3><p>下面是 Range-v3 提供的惰性范围组合器或视图的列表，以及关于如何使用每个组合器的简介。</p><ul><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1addressof__fn.html"><code>views::addressof</code></a><br>给定左值引用的源范围，返回一个新视图，该视图是每个左值引用的 <code>std::addressof</code> 的结果。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1adjacent__filter__fn.html"><code>views::adjacent_filter</code></a><br>对于源范围中的每对相邻元素，计算指定的二元谓词。如果谓词计算结果为 false，则从结果范围中删除该对的第二个元素；否则，它被包括在内。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1adjacent__remove__if__fn.html"><code>views::adjacent_remove_if</code></a><br>对于源范围中的每对相邻元素，计算指定的二元谓词。 如果谓词计算结果为 true，则从结果范围中删除该对的第一个元素； 否则，它被包括在内。 始终包含源范围中的最后一个元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1all__fn.html"><code>views::all</code></a><br>返回包含源中所有元素的范围。对于将容器转换为范围很有用。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1any__view.html"><code>any_view&lt;T&gt;(rng)</code></a><br>值类型为 T 的元素的类型擦除范围；可以使用此值类型存储任何范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1c__str__fn.html"><code>views::c_str</code></a><br>将 \0 终止的 C 字符串（例如来自 const char*）视为范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1cache1__fn.html"><code>views::cache1</code></a><br>缓存视图中的最新元素，以便多次取消引用视图的迭代器不会导致任何重新计算。 例如，这在包括 view::filter 和 view::transform 组合的适配器管道中非常有用。 views::cache1 始终是单通道。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1cartesian__product__fn.html"><code>views::cartesian_product</code></a><br>枚举 n 个范围的 n 元笛卡尔积，即生成所有 n 元组 (e1, e2, … , en)，其中 e1 是第一个范围的元素，e2 是第二个范围的元素，依此类推。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1chunk__fn.html"><code>views::chunk</code></a><br>给定源范围和整数 N，生成一系列连续范围，其中每个内部范围都有 N 个连续元素。最终范围的元素可能少于 N 个。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1common__fn.html"><code>views::common</code></a><br>将源范围转换为公共范围，其中结束的类型与开始的类型相同。对于调用 std:: 命名空间中的算法很有用。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1concat__fn.html"><code>views::concat</code></a><br>给定 N 个源范围，生成一个由所有源范围串联而成的结果范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1const__fn.html"><code>views::const_</code></a><br>呈现源范围的常量视图。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1counted__fn.html"><code>views::counted</code></a><br>给定一个迭代器 it 和一个计数 n，创建一个从 it 开始并包含接下来的 n 个元素的范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1cycle__fn.html"><code>views::cycle</code></a><br>返回无限重复源范围的范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1delimit__fn.html"><code>views::delimit</code></a><br>给定源范围和值，返回一个新范围，该范围在源末尾或该值第一次出现时结束（以先到者为准）。 或者，可以使用迭代器和值调用  views::delimit，在这种情况下，它返回一个从指定位置开始到该值第一次出现为止的范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1drop__fn.html"><code>views::drop</code></a><br>给定源范围和整数计数，返回一个由源范围中除第一个 count 元素之外的所有元素组成的范围，如果元素较少，则返回空范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1drop__last__fn.html"><code>views::drop_last</code></a><br>给定一个源范围和一个整数计数，返回一个由源范围中除最后一个 count 元素之外的所有元素组成的范围，如果元素较少，则返回一个空范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1drop__exactly__fn.html"><code>views::drop_exactly</code></a><br>给定源范围和整数计数，返回一个由源范围中除第一个计数元素之外的所有元素组成的范围。源范围必须至少包含那么多元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1drop__while__fn.html"><code>views::drop_while</code></a><br>从范围前面删除满足一元谓词的元素。</li><li><a href="https://ericniebler.github.io/range-v3/group__list.html#gae64f0978e680ad1a96438c0756b4644d"><code>views::empty</code></a><br>使用给定值类型创建一个空范围。</li><li><a href="https://ericniebler.github.io/range-v3/group__group-iterator.html#gadbd40e512efd99a7fe289b5753d2be4e"><code>views::enumerate</code></a><br>将范围的每个元素与其索引配对。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1filter__fn.html"><code>views::filter</code></a><br>给定源范围和一元谓词，过滤满足谓词的元素。 （对于 Boost.Range 的用户来说，这就像过滤器适配器。）</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1for__each__fn.html"><code>views::for_each</code></a><br>延迟地将一元函数应用于返回另一个范围（可能为空）的源范围中的每个元素，从而展平结果。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1generate__fn.html"><code>views::generate</code></a><br>给定一个零函数，返回一个无限范围，其元素是用该函数生成的。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1generate__n__fn.html"><code>views::generate_n</code></a><br>给定一个空函数和一个计数，返回一个范围，通过调用该函数生成所需数量的元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1chunk__by__fn.html"><code>views::chunk_by</code></a><br>给定一个源范围和一个二元谓词，返回一个范围范围，其中每个范围包含源范围中的连续元素，并且满足以下条件：对于该范围中除第一个元素之外的每个元素，当该元素和前一个元素传递给二元谓词时，结果为 true。 本质上，views::chunk_by 将连续元素与二元谓词分组在一起。</li><li><a href="https://ericniebler.github.io/range-v3/"><code>views::indirect</code></a><br>给定可读值的源范围（例如指针或迭代器），返回一个新视图，该视图是取消引用每个值的结果。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1intersperse__fn.html"><code>views::intersperse</code></a><br>给定源范围和值，返回一个新范围，其中值插入到源中的连续元素之间。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1ints__fn.html"><code>views::ints</code></a><br>生成一系列单调递增的整数。 当不带参数使用时，它会生成准无限范围 [0,1,2,3…]。 也可以用下界或用下界和上限（不包括）来调用它。 Closed_ints 提供了包含版本。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1iota__fn.html"><code>views::iota</code></a><br>views::ints 的泛化，生成任何可递增类型的单调递增值序列。 当使用单个参数指定时，结果是从指定值开始的无限范围。 对于两个参数，假定这些值表示半开范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1join__fn.html"><code>views::join</code></a><br>给定一系列范围，将它们连接成扁平的元素序列。或者，您可以指定要在每个源范围之间插入的值或范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1keys__fn.html"><code>views::keys</code></a><br>给定一系列对（如 std::map），返回一个仅包含该对的第一个元素的新范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1linear__distribute__fn.html"><code>views::linear_distribute</code></a><br>在闭区间 [from, to] 中线性分布 n 个值（始终包含端点）。如果 from &#x3D;&#x3D; to，则返回 n 次 to，如果 n &#x3D;&#x3D; 1，则返回 to。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1move__fn.html"><code>views::move</code></a><br>给定源范围，返回一个新范围，其中每个元素已转换为右值引用。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1partial__sum__fn.html"><code>views::partial_sum</code></a><br>给定一个范围和一个二元函数，返回一个新范围，其中第 N 个元素是将函数应用于源范围中的第 N 个元素和结果范围中的第 (N-1) 个元素的结果。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1remove__fn.html"><code>views::remove</code></a><br>给定源范围和值，过滤掉那些不等于值的元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1remove__if__fn.html"><code>views::remove_if</code></a><br>给定源范围和一元谓词，过滤掉那些不满足谓词的元素。 （对于 Boost.Range 的用户来说，这就像谓词被否定的过滤器适配器。）</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1repeat__fn.html"><code>views::repeat</code></a><br>给定一个值，创建一个无限重复该值的范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1repeat__n__fn.html"><code>views::repeat_n</code></a><br>给定一个值和一个计数，创建一个范围，该范围是该值重复的 count 次。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1replace__fn.html"><code>views::replace</code></a><br>给定源范围、源值和目标值，创建一个新范围，其中所有等于源值的元素都将替换为目标值。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1replace__fn.html"><code>views::replace</code></a><br>给定源范围、源值和目标值，创建一个新范围，其中所有等于源值的元素都将替换为目标值。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1replace__if__fn.html"><code>views::replace_if</code></a><br>给定源范围、一元谓词和目标值，创建一个新范围，其中满足谓词的所有元素都将替换为目标值。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1reverse__fn.html"><code>views::reverse</code></a><br>创建一个以相反顺序遍历源范围的新范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1sample__fn.html"><code>views::sample</code></a><br>返回长度范围  size(range) 的随机样本。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1slice__fn.html"><code>views::slice</code></a><br>为源范围指定下限（包含）和上限（不包含），创建一个以指定偏移量开始和结束的新范围。 开始和结束都可以是相对于前面的整数，或者使用“end-2”语法相对于结尾的整数。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1sliding__fn.html"><code>views::sliding</code></a><br>给定范围和计数 n，在基础范围的前 n 个元素上放置一个窗口。 返回该窗口的内容作为调整范围的第一个元素，然后将窗口一次向前滑动一个元素，直到到达基础范围的末尾。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1split__fn.html"><code>views::split</code></a><br>给定源范围和分隔符说明符，使用分隔符说明符将源范围拆分为一系列范围以查找边界。 分隔符说明符可以是一个元素或一系列元素。 与分隔符匹配的元素将从结果范围中排除。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1split__when__fn.html"><code>views::split_when</code></a><br>给定源范围和分隔符说明符，使用分隔符说明符将源范围拆分为一系列范围以查找边界。 分隔符说明符可以是谓词或函数。 谓词应采用范围引用类型的单个参数，并当且仅当该元素是分隔符的一部分时返回 true。 该函数应该接受一个迭代器和哨兵，指示当前位置和源范围的结尾，如果当前位置是边界，则返回 std::make_pair(true, iterator_past_the_delimiter) ； 否则 std::make_pair(false,ignored_iterator_value)。 与分隔符匹配的元素将从结果范围中排除。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1stride__fn.html"><code>views::stride</code></a><br>给定源范围和整数步长值，返回由第 N 个元素组成的范围（从第一个元素开始）。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1tail__fn.html"><code>views::tail</code></a><br>给定源范围，返回不带第一个元素的新范围。该范围必须至少包含一个元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1take__fn.html"><code>views::take</code></a><br>给定源范围和整数计数，返回由源范围中的第一个 count 元素组成的范围，如果元素较少，则返回完整范围。 （views::take 的结果不是 sized_range。）</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1take__exactly__fn.html"><code>views::take_exactly</code></a><br>给定源范围和整数计数，返回由源范围中的第一个计数元素组成的范围。源范围必须至少包含那么多元素。 （views::take_exactly 的结果是一个 sized_range。）</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1take__last__fn.html"><code>views::take_last</code></a><br>给定源范围和整数计数，返回由源范围中最后计数元素组成的范围。源范围必须是 sized_range。如果源范围没有至少 count 个元素，则返回完整范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1take__while__fn.html"><code>views::take_while</code></a><br>给定源范围和一元谓词，返回一个由前面满足谓词的元素组成的新范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1tokenize__fn.html"><code>views::tokenize</code></a><br>给定源范围和可选的子匹配说明符和 std::regex_constants::match_flag_type，返回 std::regex_token_iterator 以逐步遍历源范围的正则表达式子匹配。 子匹配说明符可以是普通 int、std::vector<int> 或 std::initializer_list<int>。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1transform__fn.html"><code>views::transform</code></a><br>给定源范围和一元函数，返回一个新范围，其中每个结果元素是将一元函数应用于源元素的结果。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1trim__fn.html"><code>views::trim</code></a><br>给定源双向范围和一元谓词，返回一个新范围，不包含满足谓词的前后元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1unbounded__fn.html"><code>views::unbounded</code></a><br>给定一个迭代器，返回从该位置开始的无限范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1unique__fn.html"><code>views::unique</code></a><br>给定一个范围，返回一个新范围，其中除了第一个之外比较相等的所有连续元素都已被过滤掉。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1values__fn.html"><code>views::values</code></a><br>给定一个对的范围（如 std::map），返回一个仅包含该对的第二个元素的新范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1zip__fn.html"><code>views::zip</code></a><br>给定 N 个范围，返回一个新范围，其中第 M 个元素是对所有 N 个范围的第 M 个元素调用 make_tuple 的结果。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1views_1_1zip__with__fn.html"><code>views::zip_with</code></a><br>给定 N 个范围和一个 N 元函数，返回一个新范围，其中第 M 个元素是对所有 N 个范围的第 M 个元素调用该函数的结果。</li></ul><h3 id="动作-Actions"><a href="#动作-Actions" class="headerlink" title="动作(Actions)"></a>动作(Actions)</h3><h4 id="动作列表"><a href="#动作列表" class="headerlink" title="动作列表"></a>动作列表</h4><p>下面是 Range-v3 提供的立即范围组合器或动作的列表，以及关于如何使用每个组合器的简介。</p><ul><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1drop__fn.html"><code>actions::drop</code></a><br>删除源范围的前 N 个元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1drop__while__fn.html"><code>actions::drop_while</code></a><br>删除源范围中满足一元谓词的第一个元素。</li><li>actions::erase<br>删除源子范围（范围版本）中的所有元素或位置之后的所有元素。</li><li>actions::insert<br>将范围内的所有元素插入源中的位置。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1join__fn.html"><code>actions::join</code></a><br>展平一系列范围。</li><li>actions::push_back<br>将元素附加到源的尾部。</li><li>actions::push_front<br>将元素附加到源头之前。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1remove__if__fn.html"><code>actions::remove_if</code></a><br>从源中删除满足谓词的所有元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1remove__fn.html"><code>actions::remove</code></a><br>从源中删除所有等于 value 的元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1reverse__fn.html"><code>actions::reverse</code></a><br>反转容器中的所有元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1shuffle__fn.html"><code>actions::shuffle</code></a><br>随机排列源范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1slice__fn.html"><code>actions::slice</code></a><br>从源中删除不属于子范围的所有元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1sort__fn.html"><code>actions::sort</code></a><br>对源范围进行排序（不稳定）。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1split__fn.html"><code>actions::split</code></a><br>使用分隔符（值、值序列、谓词或返回对&lt;bool, N&gt; 的二元函数）将范围拆分为一系列子范围。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1stable__sort__fn.html"><code>actions::stable_sort</code></a><br>对源范围进行排序（稳定）。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1stride__fn.html"><code>actions::stride</code></a><br>删除位置与步幅不匹配的所有元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1take__fn.html"><code>actions::take</code></a><br>保留范围的前 N 个元素，删除其余元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1take__while__fn.html"><code>actions::take_while</code></a><br>保留满足谓词的第一个元素，删除其余元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1transform__fn.html"><code>actions::transform</code></a><br>用一元函数的结果替换源的元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1unique__fn.html"><code>actions::unique</code></a><br>删除源中比较相等的相邻元素。如果源已排序，则删除所有重复元素。</li><li><a href="https://ericniebler.github.io/range-v3/structranges_1_1actions_1_1unstable__remove__if__fn.html"><code>actions::unstable_remove_if</code></a><br>更快（每个元素删除具有恒定的时间复杂度），remove_if 的无序版本。需要双向容器。</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="使用-view-facade-创建一个用户视图"><a href="#使用-view-facade-创建一个用户视图" class="headerlink" title="使用 view_facade 创建一个用户视图"></a>使用 view_facade 创建一个用户视图</h4><h4 id="使用-view-adaptor-创建一个用户视图"><a href="#使用-view-adaptor-创建一个用户视图" class="headerlink" title="使用 view_adaptor 创建一个用户视图"></a>使用 view_adaptor 创建一个用户视图</h4><p><strong>view_adaptor 的细节</strong></p><h5 id="使用-basic-iterator-创建一个用户迭代器"><a href="#使用-basic-iterator-创建一个用户迭代器" class="headerlink" title="使用 basic_iterator 创建一个用户迭代器"></a>使用 basic_iterator 创建一个用户迭代器</h5><h3 id="基于概念的检查"><a href="#基于概念的检查" class="headerlink" title="基于概念的检查"></a>基于概念的检查</h3><h3 id="Range-v3-及其未来"><a href="#Range-v3-及其未来" class="headerlink" title="Range-v3 及其未来"></a>Range-v3 及其未来</h3>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>函数式编程</tag>
      
      <tag>Range-v3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Eigen 库官方文档</title>
    <link href="/2023/08/14/eigen-library-guide/"/>
    <url>/2023/08/14/eigen-library-guide/</url>
    
    <content type="html"><![CDATA[<p>Eigen 是一个用于线性代数的 C++ 模板库：它包含矩阵、向量、数值求解器以及相关算法。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p><strong>Eigen 用途广泛。</strong></p><ul><li>它支持任意大小的矩阵，从小型固定大小矩阵到任意大小的大型稠密矩阵，甚至是稀疏矩阵。</li><li>它支持所有的标准数字类型，包括<code>std::complex</code>，整型以及很容易拓展到用户数字类型。</li><li>它支持各种矩阵分解操作和几何学特征。</li><li>它的非官方支持模块提供了许多特殊的功能，例如像非线性优化、矩阵函数、多项式求解以及快速傅里叶变换等。</li></ul></li><li><p><strong>Eigen 是快速的。</strong></p><ul><li>表达式模板允许智能地删除临时变量，并在适当的时候启用惰性求值。</li><li>对 SSE 2&#x2F;3&#x2F;4、AVX、AVX2、FMA、AVX512、ARM NEON（32 位和 64 位）、PowerPC AltiVec&#x2F;VSX（32 位和 64 位）、ZVector (s390x&#x2F;zEC13) SIMD 指令集执行显式的向量化，并且从 3.4 MIPS MSA 开始，能够优雅地回退到非矢量化代码。</li><li>对大小固定的矩阵做了充分优化：避免了动态内存分配，并且在允许的情况下进行循环展开。</li><li>对于大型矩阵，特别注意缓存友好性。</li></ul></li><li><p><strong>Eigen 是可靠的。</strong></p><ul><li>算法经过精心挑选以确保可靠性。可靠性权衡都有明确的记录，并且可以进行极其安全的分解。</li><li>Eigen 使用其自己的测试套件（超过 500 个可执行文件）、标准 BLAS 测试套件和部分 LAPACK 测试套件进行了全面测试。</li></ul></li><li><p><strong>Eigen 是优雅的。</strong></p><ul><li>得益于表达式模板，Eigen 的 API 非常干净且富有表现力，对 C++ 程序员来说会感觉很自然。</li><li>基于 Eigen 实现算法感觉就像是在复制伪代码。</li></ul></li><li><p><strong>Eigen 有很好的编译器支持，</strong>我们在许多编译器上运行了我们的测试套件，以保证可靠性并解决任何编译器错误。Eigen 在3.4 版本之前使用是 C++03 标准，并保持合理的编译时间。3.4 之后的版本将是 C++14。</p></li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul><li>Eigen 3 文档：包括入门指南，长篇教程，快速参考以及关于从 Eigen 2 移植到 Eigen 3 的页面。</li><li>Eigen 开发分支文档。</li><li>Eigen 2 文档（旧）：包括 Eigen2 教程。</li><li>常见问题。</li><li>演讲和会谈。</li></ul><h2 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h2><p>这是一个关于如何开始使用 Eigen 的简短指南。编写它有两个目的，一是为那些想要尽快进行代码<br>的人提供一个关于 Eigen 库的简单介绍；除此之外，也可以将此页作为整个教程的第一部分进行阅读，完整教程将解释该库的更多细节，详见矩阵类页面。</p><h3 id="如何“安装”Eigen？"><a href="#如何“安装”Eigen？" class="headerlink" title="如何“安装”Eigen？"></a>如何“安装”Eigen？</h3><p>只需要下载并提取 Eigen 源码便可使用 Eigen（下载链接见这里）。Eigen 子目录下的头文件是使用 Eigen 编译程序所需要的唯一文件。这些头文件在所有平台下都是一样的。使用 CMake 或安装任何东西都是非必须的。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Eigen</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell 趣学指南</title>
    <link href="/2023/08/13/haskell-primer/"/>
    <url>/2023/08/13/haskell-primer/</url>
    
    <content type="html"><![CDATA[<p>这是一本讲解 Haskell 这门函数式编程语言的入门指南，语言通俗易懂，插图生动幽默，示例短小清晰，结构安排合理。书中从 Haskell 的基础知识讲起，涵盖了所有的基本概念和语法，内容设计基本语法、递归、类型和类型类、函子、applicative 函子、monad、zipper 及所有 Haskell 重要特性和强大功能。</p><p>本书适合对函数式编程及 Haskell 语言感兴趣的开发人员阅读。</p><span id="more"></span><p><a href="https://www.haskell.org/">Haskell 官网</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>在 Windows 上安装 Haskell 环境</li></ul><p>在 PowerShell 会话中运行以下命令（作为非管理员用户）：</p><p>配置国内镜像源</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">env:BOOTSTRAP_HASKELL_YAML = <span class="hljs-string">&#x27;https://mirrors.ustc.edu.cn/ghcup/ghcup-metadata/ghcup-0.0.6.yaml&#x27;</span><br></code></pre></td></tr></table></figure><p>安装</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-built_in">Set-ExecutionPolicy</span> Bypass <span class="hljs-literal">-Scope</span> <span class="hljs-keyword">Process</span> <span class="hljs-literal">-Force</span>;[<span class="hljs-type">System.Net.ServicePointManager</span>]::SecurityProtocol = [<span class="hljs-type">System.Net.ServicePointManager</span>]::SecurityProtocol <span class="hljs-operator">-bor</span> <span class="hljs-number">3072</span>;<span class="hljs-built_in">Invoke-Command</span> <span class="hljs-literal">-ScriptBlock</span> ([<span class="hljs-type">ScriptBlock</span>]::Create((<span class="hljs-built_in">Invoke-WebRequest</span> https://mirrors.ustc.edu.cn/ghcup/sh/bootstrap<span class="hljs-literal">-haskell</span>.ps1 <span class="hljs-literal">-UseBasicParsing</span>))) <span class="hljs-literal">-ArgumentList</span> <span class="hljs-variable">$true</span><br></code></pre></td></tr></table></figure><ul><li>为 VSCode 安装 Haskell 插件：<code>Haskell</code>、<code>Haskell Syntax Highlighting</code></li></ul><h2 id="第-1-章-各就各位，预备！"><a href="#第-1-章-各就各位，预备！" class="headerlink" title="第 1 章 各就各位，预备！"></a>第 1 章 各就各位，预备！</h2><p>安装成功 Haskell 开发环境后，打开终端，输入 ghci，看到如下欢迎信息：</p><p><code>GHCi,version 8.10.7: https://www.haskell.org/ghc/  :? for help</code></p><p>说明安装成功。</p><div class="note note-info">            <p>GHCi 的默认命令提示符为 <code>Prelude&gt;</code>，配置其为 <code>ghci&gt;</code>:</p><ol><li>临时方法，输入<code>:set prompt &quot;ghci&gt;&quot;</code>，缺点：每次都要输入一遍</li><li>永久方法，在 home 目录下创建一个 <code>.ghci</code> 文件，内容为 <code>:set prompt &quot;ghci&gt;&quot;</code></li></ol>          </div><p>简单使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">-- 简单算术运算</span><br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">2 + 15</span><br>17<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">49 * 100</span><br>4900<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">1892 - 1472</span><br>420<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">5 / 2</span><br>2.5<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">(50 * 100) - 4999</span><br>1<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">50 * 100 - 4999</span><br>1<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">50 * (100 - 4999)</span><br>-244950<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">-- 逻辑运算</span><br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">True &amp;&amp; False</span><br>False<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">True &amp;&amp; True</span><br>True<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">False || True</span><br>True<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">not False</span><br>True<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">not (True &amp;&amp; True)</span><br>False<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">-- 判等</span><br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">5 == 5</span><br>True<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">1 == 0</span><br>False<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">5 /= 5</span><br>False<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">5 /= 4</span><br>True<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash"><span class="hljs-string">&quot;hello&quot;</span> == <span class="hljs-string">&quot;hello&quot;</span></span><br>True<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">-- 同一个表达式中不能混用不同类型</span><br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">5 + <span class="hljs-string">&quot;llama&quot;</span></span><br><br>&lt;interactive&gt;:88:1: error:<br>    ? No instance for (Num [Char]) arising from a use of ‘+’<br>    ? In the expression: 5 + &quot;llama&quot;<br>      In an equation for ‘it’: it = 5 + &quot;llama&quot;<br></code></pre></td></tr></table></figure><h3 id="1-1-调用函数"><a href="#1-1-调用函数" class="headerlink" title="1.1 调用函数"></a>1.1 调用函数</h3><p><code>*</code>是一个函数，它可以将两个数相乘。这种函数被称为<code>中缀函数</code>。<br>其他的大部分函数，属于<code>前缀函数</code>。在 Haskell 中调用前缀函数时，先是函数名和一个空格，后跟参数列表（也由空格分隔）。</p><p>举例：<code>succ</code>函数可以取得参数的后继，前提是它要有明确的后继。<br><code>ghci&gt; succ 8</code><br><code>9</code></p><p>min、max 函数：<br><code>ghci&gt; min 9 10</code><br><code>ghci&gt; min 3.4 3.2</code><br><code>ghci&gt; max 100 101</code></p><p>将前缀形式转成中缀形式：用反引号（`）将函数括起来，就能以中缀形式调用。<br>例如：<code>div 92 10</code> 等效于 <code>92 `div` 10</code></p><h3 id="1-2-小朋友的第一个函数"><a href="#1-2-小朋友的第一个函数" class="headerlink" title="1.2 小朋友的第一个函数"></a>1.2 小朋友的第一个函数</h3><p>函数的声明与它的调用形式大体相同，都是先函数名，后跟空格分隔的参数表。不过后面多了一个等号（&#x3D;），并且后面的代码定义了函数的行为。<br><code>doubleMe x = x + x</code></p><p>将它保存为<code>baby.hs</code>或者任意名字，然后转至文件所在目录，打开 CHCi，执行<code>:l baby</code>装载它。随后就可以使用它了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">:l baby</span><br>[1 of 1] Compiling Main             ( baby.hs,interpreted )<br>Ok,one module loaded.<br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">doubleMe 9</span><br>18   <br><span class="hljs-meta prompt_">ghci&gt;</span><span class="language-bash">doubleMe 8.3</span> <br>16.6 <br></code></pre></td></tr></table></figure><p>定义几个不同的函数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-comment">-- 两个参数的函数</span><br><span class="hljs-title">doubleUs</span> x y = x * <span class="hljs-number">2</span> + y * <span class="hljs-number">2</span><br><br><span class="hljs-comment">-- if 后必须跟 else</span><br><span class="hljs-title">doubleSmallNumber</span> x = <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">then</span> x <span class="hljs-keyword">else</span> x * <span class="hljs-number">2</span><br><br><span class="hljs-comment">-- 通常使用单引号来区分这是某函数的严格求值（与惰性求值相对）版本，</span><br><span class="hljs-comment">-- 或者是一个稍经修改但差别不大的函数。</span><br><span class="hljs-title">doubleSmallNumber&#x27;</span> x = (<span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">then</span> x <span class="hljs-keyword">else</span> x * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span><br><br><span class="hljs-comment">-- 无参函数，注意：函数不能以大写字母开头</span><br><span class="hljs-comment">-- 没有参数的函数通常被称作定义或者名字，在函数定义之后我们就再也不能修改它的内容。</span><br><span class="hljs-title">connanO&#x27;Brien</span> = <span class="hljs-string">&quot;It&#x27;s a-me,Connan O&#x27;Brien!&quot;</span><br></code></pre></td></tr></table></figure><h3 id="1-3-列表"><a href="#1-3-列表" class="headerlink" title="1.3 列表"></a>1.3 列表</h3><p>在 Haskell 中，列表是一种单类型的数据结构，可以用来存储多个类型相同的元素。</p><p>用 let 关键字定义一个列表常量：<br><code>let lostNumbers = [4,8,15,16,23,42]</code></p><h4 id="拼接列表"><a href="#拼接列表" class="headerlink" title="拼接列表"></a>拼接列表</h4><p>方式一：<code>++</code>运算符，两个操作数必须都为列表<br><code>[1,2,3,4] ++ [9,10,11,12] -&gt; [1,2,3,4,9,10,11,12]</code>、</p><p>方式二：<code>:</code>运算符（被称为 Cons 运算符），仅将一个元素插入到列表的头部<br><code>&#39;A&#39;:&quot; SMALL CAT&quot; -&gt; &quot;A SMALL CAT&quot;</code></p><h4 id="访问列表中的元素"><a href="#访问列表中的元素" class="headerlink" title="访问列表中的元素"></a>访问列表中的元素</h4><p>使用<code>!!</code>运算符，下标从 0 开始：<br><code>&quot;Steve Buscemi&quot; !! 6 -&gt; &#39;B&#39;</code><br><code>[9.4,33.2,96.2,11.2,23.25] !! 1 -&gt; 33.2</code></p><h4 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h4><p><code>let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]</code><br><code>b ++ [[1,1,1,1]]</code><br><code>[6,6,6] : b</code><br><code>b !! 2</code></p><p>列表中的列表可以是不同长度的，但类型必须相同。</p><h4 id="比较列表"><a href="#比较列表" class="headerlink" title="比较列表"></a>比较列表</h4><p>两个列表的大小以第一个不相等的元素的大小为准。</p><p><code>[3,2,1] &gt; [2,1,0] -&gt; True</code><br><code>[3,2,1] &gt; [2,10,100] -&gt; True</code><br><code>[3,4,2] &lt; [3,4,3] -&gt; True</code><br><code>[3,4,2] &gt; [2,4] -&gt; True</code></p><h4 id="更多列表操作"><a href="#更多列表操作" class="headerlink" title="更多列表操作"></a>更多列表操作</h4><ul><li><code>head</code>函数返回一个列表的头部：<br><code>head [5,4,3,2,1] -&gt; 5</code>  </li><li><code>tail</code>函数返回一个列表的尾部，也就是列表除去头部之后的部分：<br><code>tail [5,4,3,2,1] -&gt; [4,3,2,1]</code>  </li><li><code>last</code>函数返回一个列表的最后一个元素：<br><code>last [5,4,3,2,1] -&gt; 1</code>  </li><li><code>init</code>函数返回一个列表除去最后一个元素的部分：<br><code>init [5,4,3,2,1] -&gt; [5,4,3,2]</code>  </li><li><code>length</code>函数7返回一个列表的长度：<br><code>length [5,4,3,2,1] -&gt; 5</code>  </li><li><code>null</code>函数检查一个列表是否为空：<br><code>null [1,2,3] -&gt; False; null [] -&gt; True</code>  </li><li><code>reverse</code>函数将一个列表反转：<br><code>reverse [5,4,3,2,1] -&gt; [1,2,3,4,5]</code>  </li><li><code>take</code>函数取一个数字和一个列表作为参数，返回列表中指定的前几个元素：<br><code>take 3 [5,4,3,2,1] -&gt; [5,4,3]</code><br><code>take 5 [1,2] -&gt; [1,2]</code><br><code>take 0 [6,6,6] -&gt; []</code>  </li><li><code>drop</code>函数删除一个列表中指定的前几个元素：<br><code>drop 3 [8,4,2,1,5,6] -&gt; [1,5,6]</code><br><code>drop 0 [1,2,3,4] -&gt; [1,2,3,4]</code><br><code>drop 100 [1,2,3,4] -&gt; []</code>  </li><li><code>maximum</code>函数返回一个列表的最大元素：<br><code>maximum [1,9,2,3,4] -&gt; 9</code></li><li><code>minimum</code>函数返回一个列表的最小元素：<br><code>minimum [1,9,2,3,4] -&gt; 1</code></li><li><code>sum</code>函数返回一个列表中所有元素的和：<br><code>sum [5,2,1,6,3,2,5,7] -&gt; 31</code></li><li><code>product</code>函数返回一个列表中所有元素的积：<br><code>product [6,2,1,2] -&gt; 24</code></li><li><code>elem</code>函数可以用来判断一个元素是否包含于一个列表，通常以中缀形式调用它：<br><code>4  `elem` [3,4,5,6] -&gt; True</code><br><code>10 `elem` [3,4,5,6] -&gt; False</code></li></ul><h3 id="1-4-得州区间"><a href="#1-4-得州区间" class="headerlink" title="1.4 得州区间"></a>1.4 得州区间</h3><p>区间是构造列表的方法之一，而且其值必须是可枚举的，或者说，是可以排序的。例如，要得到包含 1~20 中的所有自然数的列表，只要录入<code>[1..20]</code>即可，这与录入<code>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</code>完全等价。</p><p><code>[&#39;a&#39;..&#39;z&#39;] -&gt; &quot;abcdefghijklmnopqrstuvwxyz&quot;</code><br><code>[&#39;K&#39;..&#39;Z&#39;] -&gt; &quot;KLMNOPQRSTUVWXYZ&quot;</code></p><ul><li>区间很聪明，允许你告诉它一个步长。例如：<br>要得到 1 到 20 之间的偶数：<code>[2,4..20]</code><br>要得到 1 到 20 之间 3 的倍数：<code>[3,6..20]</code><br>要得到 20 到 1 之间的列表：<code>[20,19..1]</code>  </li><li>无限列表的使用：  <ul><li>生成前 24 个 13 的倍数：<br><code>take 24 [13,26..]</code>  </li><li><code>cycle</code>函数接收一个列表作为参数并返回一个无限列表：<br><code>take 10 (cycle [1,2,3]) -&gt; [1,2,3,1,2,3,1,2,3,1]</code><br><code>take 12 (cycle &quot;LOL&quot;) -&gt; &quot;LOL LOL LOL &quot;</code></li><li><code>repeat</code>函数接收一个值作为参数，并返回一个仅包含该值的无限列表：<br><code>take 10 (repeat 5) -&gt; [5,5,5,5,5,5,5,5,5,5]</code></li><li>用<code>replicate</code>函数直接得到包含相同元素的列表：<br><code>replicate 3 10 -&gt; [10,10,10]</code></li></ul></li></ul><p>在区间上使用浮点数要格外小心：<br><code>[0.1, 0.3 .. 1] -&gt; [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]</code></p><h3 id="1-5-我是列表推导式"><a href="#1-5-我是列表推导式" class="headerlink" title="1.5 我是列表推导式"></a>1.5 我是列表推导式</h3><p><code>列表推导式（list comprehension）</code>是一种过滤、转换或者组合列表的方法。类似于数学中的<code>集合推导式（set comprehension）</code>，通过它可以从既有的集合中按照规则产生一个新的集合。因此，前 10 个偶数的集合可以写为 {$2·x\ |\ x \in N,\ x \leq 10$}。</p><p>在 Haskell 中可以利用列表推导式实现上述表达式：<code>[x*2 | x &lt;- [1..10]]</code>。上述代码通过<code>[x &lt;- [1..10]]</code>取了<code>[1..10]</code>这个列表中的每一项元素，<code>x</code>即<code>[1..10]</code>中的每一项元素的值，也就是说，<code>x</code>即<code>[1..10]</code>中的每一项元素的<strong>绑定</strong>。竖线（|）前面的部分指列表推导式的输出，表示所取的值与计算结果的映射关系。</p><p>一些其他例子：<br>取 1 的 10 中，乘以 2 后大于等于 12 的元素：<br><code>[x*2 | x &lt;- [1..10], x*2 &gt;= 12]</code></p><p>取 50 到 100 中所有除以 7 的余数为 3 的元素：<br><code>[x | x &lt;- [50..100], x`mod`7 == 3]</code></p><p>一个列表推导式，使列表中所有大于 10 的奇数变为 “BANG”，小于 10 的奇数变为 “BOOM”，其他则统统扔掉：<br><code>boomBangs xs = [ if x &lt; 10 then &quot;BOOM!&quot; else &quot;BANG!&quot; | x &lt;- xs, odd x ]</code><br><code>boomBangs [7..13] -&gt; [&quot;BOOM!&quot;,&quot;BOOM!&quot;,&quot;BANG!&quot;,&quot;BANG!&quot;]</code></p><p>谓词可以有多项，如：取 10 ~ 20 之间所有不等于 13、15 或 19 的数：<br><code>[x | x &lt;- [10..20], x /= 13, x /= 15, x /= 19]</code></p><p>从多个列表中去元素也是可以的：<br><code>[x+y | x &lt;- [1,2,3], y &lt;- [10,100,1000]] -&gt; [11,101,1001,12,102,1002,13,103,1003]</code><br><code>[x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]] -&gt; [16,20,22,40,50,55,80,100,110]</code><br><code>[x*y | x &lt;- [2,5,10], y &lt;- [8,10,11], x*y &gt; 50] -&gt; [55,80,100,110]</code></p><p>一个包含一组名词和形容词的列表推导式，也许写诗用得到：<br><code>let nouns = [&quot;hobo&quot;,&quot;frog&quot;,&quot;pope&quot;]</code><br><code>let adjectives = [&quot;lazy&quot;,&quot;grouchy&quot;,&quot;scheming&quot;]</code><br><code>[adjective ++ &quot; &quot; ++ noun | adjective &lt;- adjectives, noun &lt;- nouns]</code></p><p>用列表推导式实现自己的<code>length</code>函数：<br><code>length&#39; xs = sum [1 | _ &lt;- xs]</code></p><p>字符串也是列表，完全可以使用列表推导式来处理字符串：<br>一个去除字符串中所有非大写字母的函数：<br><code>removeNonUppercase st = [c | c &lt;- st, c `elem` [&#39;A&#39;..&#39;Z&#39;]]</code></p><p>对于列表的列表可以通过嵌套的列表推导式处理：<br>假设有一个包含许多数值的列表的列表，在不拆开它的前提下除去其中的所有奇数：<br><code>let xxs = [[1,2,3],[4,5,6],[7,8,9]]</code><br><code>[[x | x &lt;- xs, even x] | xs &lt;- xxs]</code></p><h3 id="1-6-元组"><a href="#1-6-元组" class="headerlink" title="1.6 元组"></a>1.6 元组</h3><p><strong>元组（tuple）</strong>允许我们将多个异构的值组合为一个单一的值。元组的长度固定，将元素存入元组的同时，必须明确元素的数目。<br>元组由括号括起，其中的项由逗号隔开。<br><code>(1, 3)</code><br><code>(3, &#39;a&#39;, &quot;hello&quot;)</code><br><code>(50, 50.4, &quot;hello&quot;, &#39;b&#39;)</code></p><h4 id="1-6-1-使用元组"><a href="#1-6-1-使用元组" class="headerlink" title="1.6.1 使用元组"></a>1.6.1 使用元组</h4><p>只有两个元组的元素数量的类型完全一样，才是相同的类型。<br>长度为 2 的元组称为<code>pair</code>，也作序对；长度为 3 的元组称为<code>tripe</code>，也作三元组。</p><h4 id="1-6-2-使用序对"><a href="#1-6-2-使用序对" class="headerlink" title="1.6.2 使用序对"></a>1.6.2 使用序对</h4><ul><li><code>fst</code>函数取一个序对作为参数，返回其首项：<code>fst (8,11) -&gt; 8</code>。</li><li><code>snd</code>函数取一个序对作为参数，返回其尾项：<code>snd (8,11) -&gt; 11</code>。</li></ul><p><code>zip</code>函数取两个列表作为参数，然后将它们交叉配对，形成一组序对。如：  </p><p>  <code>zip [1,2,3,4,5] [5,5,5,5,5] -&gt; [(1,5),(2,5),(3,5),(4,5),(5,5)]</code>  </p><p>  <code>zip [1..5] [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;] -&gt;</code><br>  <code>[(1,&quot;one&quot;),(2,&quot;two&quot;),(3,&quot;three&quot;),(4,&quot;four&quot;),(5,&quot;five&quot;)]</code>  </p><p>如果要组合的两个列表长度不相等，会在较短的列表结束为止。<br>由于 Haskell 是惰性的，可以使用<code>zip</code>组合有限和无限的列表：<br><code>zip [1..] [&quot;apple&quot;,&quot;orange&quot;,&quot;cherry&quot;,&quot;mango&quot;]</code></p><h4 id="1-6-3-找直角三角形"><a href="#1-6-3-找直角三角形" class="headerlink" title="1.6.3 找直角三角形"></a>1.6.3 找直角三角形</h4><p>使用 Haskell 来找出所有满足下列条件的直角三角形：</p><ul><li>三边长度皆为整数；</li><li>三边长度皆小于等于 10；</li><li>周长（三边之和）为 24 的直角三角形。</li></ul><p>假设 c 为斜边，a、b 为直角边：</p><p><code>let rightTriangles&#39; = [(a,b,c) | c &lt;- [1..10], a &lt;- [1..c], b &lt;- [1..a], a^2 + b^2 == c^2, a+b+c == 24]</code><br><code>rightTriangles&#39; -&gt; [(8,6,10)]</code></p><h2 id="第-2-章-相信类型"><a href="#第-2-章-相信类型" class="headerlink" title="第 2 章 相信类型"></a>第 2 章 相信类型</h2><p>在 Haskell 中，每个表达式都会在编译时得到明确的类型，从而提高代码的安全性。Haskell 中一切皆类型，因此编译器在编译时可以得到较多的信息来检查错误。Haskell 支持<strong>类型推导</strong>。</p><h3 id="2-1-显式类型声明"><a href="#2-1-显式类型声明" class="headerlink" title="2.1 显式类型声明"></a>2.1 显式类型声明</h3><p>在 GHCi 中，通过 :t 命令，后跟任何合法的表达式，即可得到该表达式的类型。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">ghci</span>&gt;:t <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-string">&#x27;a&#x27;</span> :: <span class="hljs-type">Char</span><br><span class="hljs-title">ghci</span>&gt;:t <span class="hljs-type">True</span><br><span class="hljs-type">True</span> :: <span class="hljs-type">Bool</span><br><span class="hljs-title">ghci</span>&gt;:t <span class="hljs-string">&quot;HELLO!&quot;</span><br><span class="hljs-string">&quot;HELLO!&quot;</span> :: [<span class="hljs-type">Char</span>]<br><span class="hljs-title">ghci</span>&gt;:t (<span class="hljs-type">True</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>(<span class="hljs-type">True</span>, <span class="hljs-string">&#x27;a&#x27;</span>) :: (<span class="hljs-type">Bool</span>, <span class="hljs-type">Char</span>)<br><span class="hljs-title">ghci</span>&gt;:t <span class="hljs-number">4</span> == <span class="hljs-number">5</span><br><span class="hljs-number">4</span> == <span class="hljs-number">5</span> :: <span class="hljs-type">Bool</span><br></code></pre></td></tr></table></figure><p>:: 读作“它的类型为”。凡是明确的类型，其首字母必须为大写。</p><p>同样，函数也有类型。编写函数时，可以给它一个显式的类型声明。例如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">removeNonUppercase</span> :: [<span class="hljs-type">Char</span>] -&gt; [<span class="hljs-type">Char</span>]<br><span class="hljs-title">removeNonUppercase</span> st = [c | c &lt;- st, c `elem` [<span class="hljs-string">&#x27;A&#x27;</span>..<span class="hljs-string">&#x27;Z&#x27;</span>]]<br></code></pre></td></tr></table></figure><p>这里 removeNonUppercase 的类型为 [Char] -&gt; [Char]，意为它取一个字符串作为参数，返回另一个字符串。</p><h3 id="2-2-Haskell-的常见类型"><a href="#2-2-Haskell-的常见类型" class="headerlink" title="2.2 Haskell 的常见类型"></a>2.2 Haskell 的常见类型</h3><ul><li>Int：整数，有界。</li><li>Integer：整数，无界。</li><li>Float：单精度浮点数。</li><li>Double：双精度浮点数。</li><li>Bool：布尔值。</li><li>Char：Unicode 字符。</li><li>元组。</li></ul><h3 id="2-3-类型变量"><a href="#2-3-类型变量" class="headerlink" title="2.3 类型变量"></a>2.3 类型变量</h3><p>有时让一些元素处理多种类型将更加合理。比如 head 函数，它可以取一个列表作为参数，返回这个列表头部的元素。head 函数的类型是 <code>head :: [a] -&gt; a</code>。这里的 a 是一个类型变量（type variable），因此，a 可以是任何类型。</p><p>通过类型变量，我们可以在类型安全（type safe）的前提下，轻而易举地编写能够处理多种类型的函数。这一点与其他语言中的泛型（generic）很相似，但在 Haskell 中要更为强大，更容易写出通用的函数。</p><p>使用了类型变量的函数被称为<strong>多态函数（polymorphic function）</strong>。</p><h3 id="2-4-类型类入门"><a href="#2-4-类型类入门" class="headerlink" title="2.4 类型类入门"></a>2.4 类型类入门</h3><p>类型类（typeclass）是定义行为的接口。如果一个类型是某类型类的实例（instance），那它必须实现了该类型类所描述的行为。</p><p>具体来讲，类型类是一组函数的集合，如果将某类型实现为某类型类的实例，那就需要为这一类型提供这些函数的相应实现。</p><p>例如：&#x3D;&#x3D; 运算符的类型签名为 <code>(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool</code>。&#x3D;&gt; 符合的左侧叫做<strong>类型约束（type constraint）</strong>。我们可以这样读这段类型声明：“相等性函数取两个相同类型的值作为参数并返回一个布尔值，而这两个参数的类型同为 Eq 类型类的实例”。</p><blockquote><p><strong>注意</strong> 千万不要将 Haskell 的类型类与面向对象语言中的类（Class）的概念混淆。</p></blockquote><ul><li>Eq 类型类：用于可判断相等性的类型，要求它的实例必须实现 &#x3D;&#x3D; 和 &#x2F;&#x3D; 两个函数。</li><li>Ord 类型类：用于可比较大小的类型，包含了所有标准比较函数，如 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 等。</li><li>Show 类型类：实例为可以表示为字符串的类型，目前为止提到的除函数以外的所有类型都是 Show 的实例。show 函数可以取 Show 的实例类型作为参数，并将其转换为字符串。</li><li>Read 类型类：与 Show 相反的类型类。目前为止提到的所有类型都是 Read 的实例。read 函数可以取一个字符串作为参数并转换为 Read 的某个实例的类型。</li><li>Enum 类型类：其实例类型都是具有连续顺序的——它们的值都是可以枚举的。我们可以在区间中使用这些类型，每个值都有相应的后继（successer）和前驱（predecesor），分别可以通过 succ 函数和 pred 函数得到。</li><li>Bounded 类型类：实例类型都有一个上界和下界，分别可以通过 maxBound 和 minBound 两个函数获取到。</li><li>Num 类型类：表示数值的类型类，它的实例类型都具有数的特征。只有已经属于 Show 与 Eq 的实例类型，才可以成为 Num 类型类的实例。</li><li>Floating 类型类：仅包含 Float 和 Double 两种浮点类型，用于存储浮点数。</li><li>Integeral 类型类：仅包含整数，其实例类型有 Int 和 Integer。</li></ul><p>由于类型类定义的是一个抽象的接口，一个类型可以作为多个类型类的实例，一个类型类也可以含有多个类型作为实例。有时，一个类型必须在成为某类型类的实例之后，才能成为另一个类型类的实例。</p><h2 id="第-3-章-函数的语法"><a href="#第-3-章-函数的语法" class="headerlink" title="第 3 章 函数的语法"></a>第 3 章 函数的语法</h2><h2 id="第-4-章-你好，递归"><a href="#第-4-章-你好，递归" class="headerlink" title="第 4 章 你好，递归"></a>第 4 章 你好，递归</h2><h2 id="第-5-章-高阶函数"><a href="#第-5-章-高阶函数" class="headerlink" title="第 5 章 高阶函数"></a>第 5 章 高阶函数</h2><h2 id="第-6-章-模块"><a href="#第-6-章-模块" class="headerlink" title="第 6 章 模块"></a>第 6 章 模块</h2><h2 id="第-7-章-构建我们自己的类型和类型类"><a href="#第-7-章-构建我们自己的类型和类型类" class="headerlink" title="第 7 章 构建我们自己的类型和类型类"></a>第 7 章 构建我们自己的类型和类型类</h2><h2 id="第-8-章-输入与输出"><a href="#第-8-章-输入与输出" class="headerlink" title="第 8 章 输入与输出"></a>第 8 章 输入与输出</h2><h2 id="第-9-章-更多的输入与输出操作"><a href="#第-9-章-更多的输入与输出操作" class="headerlink" title="第 9 章 更多的输入与输出操作"></a>第 9 章 更多的输入与输出操作</h2><h2 id="第-10-章-函数式地解决问题"><a href="#第-10-章-函数式地解决问题" class="headerlink" title="第 10 章 函数式地解决问题"></a>第 10 章 函数式地解决问题</h2><h2 id="第-11-章-applicative-函子"><a href="#第-11-章-applicative-函子" class="headerlink" title="第 11 章 applicative 函子"></a>第 11 章 applicative 函子</h2><h2 id="第-12-章-Monoid"><a href="#第-12-章-Monoid" class="headerlink" title="第 12 章 Monoid"></a>第 12 章 Monoid</h2><h2 id="第-13-章-更多-monad-的例子"><a href="#第-13-章-更多-monad-的例子" class="headerlink" title="第 13 章 更多 monad 的例子"></a>第 13 章 更多 monad 的例子</h2><h2 id="第-14-章-再多一些-monad"><a href="#第-14-章-再多一些-monad" class="headerlink" title="第 14 章 再多一些 monad"></a>第 14 章 再多一些 monad</h2><h2 id="第-15-章-zipper"><a href="#第-15-章-zipper" class="headerlink" title="第 15 章 zipper"></a>第 15 章 zipper</h2>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Haskell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Haskell</tag>
      
      <tag>函数式编程</tag>
      
      <tag>入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现代诗观止</title>
    <link href="/2023/08/12/modern-poems/"/>
    <url>/2023/08/12/modern-poems/</url>
    
    <content type="html"><![CDATA[<p>现代诗也叫“白话诗”，最早可追源到清末，是诗歌的一种，与古典诗歌相比而言，虽都为感于物而作，但一般不拘格式和韵律。现代诗形式自由，意涵丰富，意象经营重于修辞运用，完全突破了古诗“温柔敦厚，哀而不怨”的特点，更加强调自由开放和直率陈述与进行“可感与不可感之间”的沟通。中国代表人物：徐志摩、北岛、顾城、海子等。</p><span id="more"></span><h2 id="祖国，或以梦为马"><a href="#祖国，或以梦为马" class="headerlink" title="祖国，或以梦为马"></a>祖国，或以梦为马</h2><p><em>【作者】海子</em><br><img src="/images/modern-poems/poem_00.png" alt=" "></p><p>我要做远方的忠诚的儿子<br>和物质的短暂情人<br>和所有以梦为马的诗人一样<br>我不得不和烈士和小丑走在同一道路上  </p><p>万人都要将火熄灭 我一人独将此火高高举起<br>此火为大 开花落英于神圣的祖国<br>和所有以梦为马的诗人一样<br>我借此火得度一生的茫茫黑夜  </p><p>此火为大 祖国的语言和乱石投筑的梁山城寨<br>以梦为上的敦煌——那七月也会寒冷的骨骼<br>如雪白的柴和坚硬的条条白雪 横放在众神之山<br>和所有以梦为马的诗人一样<br>我投入此火 这三者是囚禁我的灯盏 吐出光辉  </p><p>万人都要从我刀口走过 去建筑祖国的语言<br>我甘愿一切从头开始<br>和所有以梦为马的诗人一样<br>我也愿将牢底坐穿  </p><p>众神创造物中只有我最易朽 带着不可抗拒的 死亡的速度<br>只有粮食是我珍爱 我将她紧紧抱住 抱住她 在故乡生儿育女<br>和所有以梦为马的诗人一样<br>我也愿将自己埋葬在四周高高的山上 守望平静的家园  </p><p>面对大河我无限惭愧<br>我年华虚度 空有一身疲倦<br>和所有以梦为马的诗人一样<br>岁月易逝 一滴不剩 水滴中有一匹马儿一命 归天  </p><p>千年后如若我再生于祖国的河岸<br>千年后我再次拥有中国的稻田 和周天子的雪山 天马踢踏<br>和所有以梦为马的诗人一样<br>我选择永恒的事业  </p><p>我的事业 就是要成为太阳的一生<br>他从古至今——“日”——他无比辉煌无比光明<br>和所有以梦为马的诗人一样<br>最后我被黄昏的众神抬入不朽的太阳  </p><p>太阳是我的名字<br>太阳是我的一生<br>太阳的山顶埋葬 诗歌的尸体——千年王国和我<br>骑着五千年凤凰和名字叫”马”的龙——我必将失败<br>但诗歌本身以太阳必将胜利  </p><p><em>朗读欣赏：<a href="https://www.bilibili.com/video/BV1iJ411d7EZ/?spm_id_from=333.337.search-card.all.click&vd_source=a9b85e50b9cb84d4ab3fd25bb58e1893">诗朗诵《祖国，或以梦为马》作者：海子</a></em></p><h2 id="我用什么才能留住你"><a href="#我用什么才能留住你" class="headerlink" title="我用什么才能留住你"></a>我用什么才能留住你</h2><p><em>【作者】博尔赫斯（阿根廷）</em><br><img src="/images/modern-poems/poem_01.png" alt=" "></p><p>我用什么才能留住你？<br>我给你瘦落的街道、绝望的落日、荒郊的月亮。<br>我给你一个久久地望着孤月的人的悲哀。  </p><p>我给你我已死去的祖辈，<br>后人们用大理石祭奠的先魂，<br>我父亲的父亲，阵亡于布宜诺斯艾利斯的边境，<br>两颗子弹射穿了他的胸膛，死的时候蓄着胡子，<br>尸体被士兵们用牛皮裹起；<br>我母亲的祖父——那年才二十四岁——<br>在秘鲁率领三百人冲锋，如今都成了消失的马背上的亡魂。  </p><p>我给你我的书中所能蕴含的一切悟力，<br>以及我生活中所能有的男子气概和幽默。<br>我给你一个从未有过信仰的人的忠诚。<br>我给你我设法保全的我自己的核心——<br>不营字造句，不和梦交易，不被时间、欢乐和逆境触动的核心。  </p><p>我给你早在你出生前多年的一个傍晚看到的一朵黄玫瑰的记忆。<br>我给你关于你生命的诠释，关于你自己的理论，你的真实而惊人的存在。<br>我给你我的寂寞、我的黑暗、我心的饥渴；<br>我试图用困惑、危险、失败来打动你。  </p><h2 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h2><p><em>【作者】北岛</em><br><img src="/images/modern-poems/poem_02.png" alt=" "></p><p>卑鄙是卑鄙者的通行证，高尚是高尚者的墓志铭。<br>看吧，在那镀金的天空中，飘满了死者弯曲的倒影。<br>冰川纪过去了，为什么到处都是冰凌？<br>好望角发现了，为什么死海里千帆相竞？  </p><p>我来到这个世界上，只带着纸、绳索和身影，<br>为了在审判之前，宣读那些被判决了的声音：<br>告诉你吧，世界，我——不——相——信！<br>纵使你脚下有一千名挑战者，那就把我算做第一千零一名。<br>我不相信天是蓝的，我不相信雷的回声；<br>我不相信梦是假的，我不相信死无报应。  </p><p>如果海洋注定要决堤，就让所有的苦水都注入我心中；<br>如果陆地注定要上升，就让人类重新选择生存的峰顶。<br>新的转机和闪闪的星斗，正在缀满没有遮拦的天空，<br>那是五千年的象形文字，那是未来人们凝视的眼睛。  </p><h2 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h2><p><em>【作者】海子</em><br><img src="/images/modern-poems/poem_03.png" alt=" "></p><p>目击众神死亡的草原上野花一片<br>远在远方的风比远方更远<br>我的琴声呜咽 泪水全无<br>我把这远方的远归还草原<br>一个叫木头 一个叫马尾<br>我的琴声呜咽 泪水全无<br>远方只有在死亡中凝聚野花一片<br>明月如镜高悬草原映照千年岁月<br>我的琴声呜咽 泪水全无<br>只身打马过草原</p><p><em>演唱版：<a href="https://www.bilibili.com/video/BV1M54y1P7qX/?spm_id_from=333.788.recommend_more_video.2&vd_source=a9b85e50b9cb84d4ab3fd25bb58e1893">周云蓬经典歌曲《九月》</a></em><br><audio controls><br>    <source src="/images/modern-poems/September.mp3" type="audio/mpeg"><br></audio></p><h2 id="生活的邀请函（节选）"><a href="#生活的邀请函（节选）" class="headerlink" title="生活的邀请函（节选）"></a>生活的邀请函（节选）</h2><p><em>【作者】奥里亚·蒙顿·德里默（加拿大）</em><br><img src="/images/modern-poems/poem_04.png" alt=" "></p><p>我不在乎你如何谋生，只想知道你有何渴望，是否敢追逐心中的梦想。<br>我不关心你年方几何，只想知道面对爱情和梦想，你是否会无所保留，像个傻瓜般投入得透彻。</p><p>生命的背叛，在你心口上划开缺口，热情逐日消减，恐惧笼罩心田。<br>我想知道，你能否和伤痛共处，用不着掩饰，或刻意忘却，更别把它封堵。<br>我想知道，你能否和快乐共舞，翩翩起舞，无拘无束，从嘴唇，到指尖，到脚趾头都把热情倾注。</p><p>这一刻，忘记谨小慎微，现实残酷，忘记生命的束缚。</p><p>我想知道，你能否从每天平淡的点滴中发现美丽，能否从生命的迹象中寻找到自己生命的意义。<br>我想知道，你能否坦然面对失败，——你的或者我的，即使失败，也能屹立湖畔，对着一轮银色满月呼喊：“我可以！”<br>我想知道，当悲伤和绝望整夜踯躅，当疲倦袭来，伤口痛彻入骨，你能否再次爬起来，为生活付出。</p><p>我不关心你认识何人，为什么在此处。<br>我想知道，生命之火熊熊燃烧时，你是否敢和我一起，站在火焰中央，凛然不怵。</p><p>我不关心你在哪里受什么教育，我想知道，当一切都背弃了你，是什么将你支撑着前行。<br>我想知道，你是否经受得住孤独，空虚时，你是否真正热爱独处。</p><p><em>朗读欣赏：<a href="https://www.bilibili.com/video/BV1Di4y1G74j/?spm_id_from=333.788&vd_source=a9b85e50b9cb84d4ab3fd25bb58e1893">诗朗诵《生活的邀请函》作者：奥雷阿【加拿大】</a></em></p><h2 id="未选择的路"><a href="#未选择的路" class="headerlink" title="未选择的路"></a>未选择的路</h2><p><em>【作者】罗伯特·弗罗斯特（美国）【译者】顾子欣</em><br><img src="/images/modern-poems/poem_05.png" alt=" "></p><p>黄色的树林里分出两条路，<br>可惜我不能同时去涉足，<br>我在那路口久久伫立，<br>我向着一条路极目望去，<br>直到它消失在丛林深处。</p><p>但我却选了另外一条路，<br>它荒草萋萋，十分幽寂，<br>显得更诱人、更美丽；<br>虽然在这两条小路上，<br>都很少留下旅人的足迹；</p><p>虽然那天清晨落叶满地，<br>两条路都未经脚印污染。<br>呵，留下一条路等改日再见！<br>但我知道路径延绵无尽头，<br>恐怕我难以再回返。</p><p>也许多少年后在某个地方，<br>我将轻声叹息把往事回顾：<br>一片树林里分出两条路，<br>而我选了人迹更少的一条，<br>从此决定了我一生的道路。</p><p><em>朗读欣赏：<a href="https://www.bilibili.com/video/BV1Kd4y1M7jj/?spm_id_from=333.337.search-card.all.click&vd_source=a9b85e50b9cb84d4ab3fd25bb58e1893">诗歌：《未选择的路》（罗伯特•弗罗斯特）诵读文子</a></em></p><h2 id="致一枚钱币"><a href="#致一枚钱币" class="headerlink" title="致一枚钱币"></a>致一枚钱币</h2><p><em>【作者】博尔赫斯（阿根廷）【译者】王永年</em><br><img src="/images/modern-poems/poem_06.png" alt=" "></p><p>我从蒙得维的亚起航的那晚风大浪急。<br>转过塞罗山时，<br>我在最高一层甲板上扔出一枚钱币，<br>寒光一闪，在浊水中淹没，<br>时间和黑暗卷走了发光的物体。<br>我感到自己干了一件不可挽回的事，<br>在地球的历史上增添了两串<br>不断的、平行的、几乎无限的东西：<br>一是忧虑、爱和变迁组成的我的命运，<br>另一是那个金属圆片，<br>被水带到无底深渊<br>或者遥远的海洋，在那里<br>撒克逊人和维金人的遗骸仍受到侵蚀。<br>我梦中或不眠的每一时刻<br>总是同不知名的钱币的另一时刻印证。<br>有时候我感到后悔，<br>有时候我感到妒忌，<br>妒忌你像我们一样，<br>处于时间和它的迷宫中间而不自知。</p><h2 id="没有人是一座孤岛"><a href="#没有人是一座孤岛" class="headerlink" title="没有人是一座孤岛"></a>没有人是一座孤岛</h2><p><em>【作者】约翰·多恩（英国）</em><br><img src="/images/modern-poems/poem_07.png" alt=" "></p><p>没有人是一座孤岛<br>可以自全<br>每个人都是大陆的一片<br>整体的一部分<br>如果海水冲掉一块<br>欧洲就减小<br>如同一个山岬失掉一角<br>如同你的朋友或者你自己的领地失掉一块<br>任何人的死亡都是我的损失<br>因为我是人类的一员<br>因此<br>不要问丧钟为谁而鸣<br>它就为你而鸣</p><h2 id="在山的那边"><a href="#在山的那边" class="headerlink" title="在山的那边"></a>在山的那边</h2><p><em>【作者】王家新</em><br><img src="/images/modern-poems/poem_08.png" alt=" "></p><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>小时候，我常伏在窗口痴想<br>——山那边是什么呢？<br>妈妈给我说过：海<br>哦，山那边是海吗？<br>于是，怀着一种隐秘的想望<br>有一天我终于爬上了那个山顶<br>可是，我却几乎是哭着回来了<br>——在山的那边，依然是山<br>山那边的山啊，铁青着脸<br>给我的幻想打了一个零分！<br>妈妈，那个海呢？</p><h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>在山的那边，是海！<br>是用信念凝成的海<br>今天啊，我竟没想到<br>一颗从小飘来的种子<br>却在我的心中扎下了深根<br>是的，我曾一次又一次的失望过<br>当我爬上那一座座诱惑着我的山顶<br>但我又一次次鼓起信心向前走去<br>因为我听到海依然在远方为我喧腾<br>——那雪白的海潮啊，夜夜奔来<br>一次次浸湿了我枯干的心灵……<br>在山的那边，是海吗？<br>是的！<br>人们啊，请相信——<br>在不停地翻过无数座山后<br>在一次次地战胜失望之后<br>你终会攀上这样一座山顶<br>而在这座山的那边，就是海呀<br>是一个全新的世界<br>在一瞬间照亮你的眼睛……</p><h2 id="相信未来"><a href="#相信未来" class="headerlink" title="相信未来"></a>相信未来</h2><p><em>【作者】食指</em><br><img src="/images/modern-poems/poem_09.png" alt=" "></p><p>当蜘蛛网无情地查封了我的炉台，<br>当灰烬的余烟叹息着贫困的悲哀，<br>我依然固执地铺平失望的灰烬，<br>用美丽的雪花写下：相信未来。</p><p>当我的紫葡萄化为深秋的露水，<br>当我的鲜花依偎在别人的情怀，<br>我依然固执地用凝霜的枯藤，<br>在凄凉的大地上写下：相信未来。</p><p>我要用手指那涌向天边的排浪，<br>我要用手掌那托起太阳的大海，<br>摇曳着曙光那支温暖漂亮的笔杆，<br>用孩子的笔体写下：相信未来。</p><p>我之所以坚定地相信未来，<br>是我相信未来人们的眼睛——<br>她有拨开历史风尘的睫毛，<br>她有看透岁月篇章的瞳孔。</p><p>不管人们对于我们腐烂的皮肉，<br>那些迷途的惆怅，失败的苦痛，<br>是寄予感动的热泪，深切的同情，<br>还是给以轻蔑的微笑，辛辣的嘲讽。</p><p>我坚信人们对于我们的脊骨，<br>那无数次地探索、迷途、失败和成功，<br>一定会给予热情、客观、公正的评定，<br>是的，我焦急地等待着他们的评定。</p><p>朋友，坚定地相信未来吧，<br>相信不屈不挠的努力，<br>相信战胜死亡的年轻，<br>相信未来，热爱生命。</p><h2 id="我想和你虚度时光"><a href="#我想和你虚度时光" class="headerlink" title="我想和你虚度时光"></a>我想和你虚度时光</h2><p><em>【作者】李元胜</em><br><img src="/images/modern-poems/poem_10.png" alt=" "></p><p>我想和你虚度时光，比如低头看鱼<br>比如把茶杯留在桌子上，离开<br>浪费它们好看的阴影<br>我还想连落日一起浪费，比如散步<br>一直消磨到星光满天<br>我还要浪费风起的时候<br>坐在走廊发呆，直到你眼中乌云<br>全部被吹到窗外</p><p>我已经虚度了世界，它经过我<br>疲倦，又像从未被爱过<br>但是明天我还要这样，虚度<br>满目的花草，生活应该像它们一样美好<br>一样无意义，像被虚度的电影<br>那些绝望的爱和赴死<br>为我们带来短暂的沉默</p><p>我想和你互相浪费<br>一起虚度短的沉默，长的无意义<br>一起消磨精致而苍老的宇宙<br>比如靠在栏杆上，低头看水的镜子<br>直到所有被虚度的事物<br>我们身后，长出薄薄的翅膀</p><h2 id="活在这珍贵的人世间"><a href="#活在这珍贵的人世间" class="headerlink" title="活在这珍贵的人世间"></a>活在这珍贵的人世间</h2><p><em>【作者】海子</em><br><img src="/images/modern-poems/poem_11.png" alt=" "></p><p>活在这珍贵的人间<br>太阳强烈<br>水波温柔<br>一层层白云覆盖着<br>我踩在青草上<br>感到自己是彻底干净的黑土块</p><p>活在这珍贵的人间<br>泥土高溅<br>扑打面颊</p><p>活在这珍贵的人间<br>人类和植物一样幸福<br>爱情和雨水一样幸福</p><h2 id="在哈尔盖仰望星空"><a href="#在哈尔盖仰望星空" class="headerlink" title="在哈尔盖仰望星空"></a>在哈尔盖仰望星空</h2><p><em>【作者】西川</em><br><img src="/images/modern-poems/poem_12.png" alt=" "></p><p>有一种神秘你无法驾驭<br>你只能充当旁观者的角色<br>听凭那神秘的力量<br>从遥远的地方发出信号<br>射出光来，穿透你的心<br>像今夜，在哈尔盖<br>在这个远离城市的荒凉的<br>地方，在这青藏高原上的<br>一个蚕豆般大小的火车站旁<br>我抬起头来眺望星空<br>这时河汉无声，鸟翼稀薄<br>青草向群星疯狂地生长<br>马群忘记了飞翔<br>风吹着空旷的夜也吹着我<br>风吹着未来也吹着过去<br>我成为某个人，某间<br>点着油灯的陋室<br>而这陋室冰凉的屋顶<br>被群星的亿万只脚踩成祭坛<br>我像一个领取圣餐的孩子<br>放大了胆子，但屏住呼吸</p><h2 id="门前"><a href="#门前" class="headerlink" title="门前"></a>门前</h2><p><em>【作者】顾城</em><br><img src="/images/modern-poems/poem_13.png" alt=" "></p><p>我多么希望，有一个门口<br>早晨，阳光照在草上<br>我们站着<br>扶着自己的门扇<br>门很低，但太阳是明亮的<br>草在结它的种子<br>风在摇它的叶子<br>我们站着，不说话<br>就十分美好<br>有门，不用开开<br>是我们的，就十分美好<br>早晨，黑夜还要流浪<br>我们把六弦琴交给他<br>我们不走了</p><p>我们需要土地<br>需要永不毁灭的土地<br>我们要乘着它<br>度过一生<br>土地是粗糙的，有时狭隘<br>然而，它有历史<br>有一份天空，一份月亮<br>一份露水和早晨</p><p>我们爱土地<br>我们站着<br>用木鞋挖着泥土<br>门也晒热了<br>我们轻轻靠着，十分美好<br>墙后的草<br>不会再长大了<br>它只用指尖，触了触阳光</p><h2 id="我喜欢你是寂静的"><a href="#我喜欢你是寂静的" class="headerlink" title="我喜欢你是寂静的"></a>我喜欢你是寂静的</h2><p><em>【作者】巴勃鲁·聂鲁达（智利）【译者】李宗荣</em><br><img src="/images/modern-poems/poem_14.png" alt=" "></p><p>我喜欢你是寂静的，仿佛你消失了一样，<br>你从远处聆听我，我的声音却无法触及你。<br>好像你的双眼已经飞离去，<br>如同一个吻，封缄了你的嘴。</p><p>如同所有的事物充满了我的灵魂，<br>你从所有的事物中浮现，充满了我的灵魂。<br>你像我的灵魂，一只梦的蝴蝶，<br>你如同忧郁这个词。</p><p>我喜欢你是寂静的，好像你已远去。<br>你听起来像在悲叹，一只如鸽悲鸣的蝴蝶。<br>你从远处听见我，我的声音无法触及你：<br>让我在你的沉默中安静无声。</p><p>并且让我借你的沉默与你说话，<br>你的沉默明亮如灯，简单如指环，<br>你就像黑夜，拥有寂寞与群星。<br>你的沉默就是星星的沉默，遥远而明亮。</p><p>我喜欢你是寂静的，仿佛你消失了一样，<br>遥远而且哀伤，仿佛你已经死了。<br>彼时，一个字，一个微笑，已经足够。<br>而我会觉得幸福，因那不是真的而觉得幸福。</p><h2 id="面朝大海，春暖花开"><a href="#面朝大海，春暖花开" class="headerlink" title="面朝大海，春暖花开"></a>面朝大海，春暖花开</h2><p><em>【作者】海子</em><br><img src="/images/modern-poems/poem_15.png" alt=" "></p><p>从明天起，做一个幸福的人<br>喂马、劈柴，周游世界<br>从明天起，关心粮食和蔬菜<br>我有一所房子，面朝大海，春暖花开</p><p>从明天起，和每一个亲人通信<br>告诉他们我的幸福<br>那幸福的闪电告诉我的<br>我将告诉每一个人<br>给每一条河每一座山取一个温暖的名字</p><p>陌生人，我也为你祝福<br>愿你有一个灿烂的前程<br>愿你有情人终成眷属<br>愿你在尘世获得幸福<br>我只愿面朝大海，春暖花开</p>]]></content>
    
    
    <categories>
      
      <category>文艺</category>
      
      <category>诗歌</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摘抄</tag>
      
      <tag>现代</tag>
      
      <tag>多样</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>思维与亲密</title>
    <link href="/2023/08/11/chicago-university-graduation-speech/"/>
    <url>/2023/08/11/chicago-university-graduation-speech/</url>
    
    <content type="html"><![CDATA[<p align="center">    <iframe    src="/images/chicago-university-graduation-speech/video.mp4"    scrolling="no"    border="0"    frameborder="no"    framespacing="0"    allowfullscreen="true"    width="640"    height="360">    </iframe></p><p>面对这个纷繁复杂的社会，哈佛耶鲁、斯坦福式的毕业鸡汤已无用武之地；万金油的主题：遵从你的心声，做真实的自己，追逐自己的激情，未来无限可能云云，也稍逊风骨；更不用说自媒体上充斥的喧嚣与躁动。此时再看全美第一“修道院高校”芝加哥大学这篇毕业演讲，不仅是一股教育界的清流，更是一种芝大人心灵深处的回响。</p><span id="more"></span><p><img src="/images/chicago-university-graduation-speech/top.png" alt=" "></p><blockquote><p>大卫·布鲁克斯（David Brooks）毕业于芝加哥大学历史系，系《纽约时报》专栏作家，美国知名公共知识分子。2017 年毕业典礼，芝加哥大学第一次邀请非本校教职员工做毕业致辞，布鲁克斯接受邀请，演讲颇具芝大风。他回忆当年芝大的学习生活，探讨芝大给予自己与未能给予自己的精神财富，集中体现了全美“第一修道院”内的精神世界。我在芝大现场聆听了演讲，印象深刻，最终独家翻译制作。如果你是芝大人或向往芝大生活，欢迎分享转载。</p></blockquote><h1 id="2017-芝加哥大学毕业演讲"><a href="#2017-芝加哥大学毕业演讲" class="headerlink" title="2017 芝加哥大学毕业演讲"></a>2017 芝加哥大学毕业演讲</h1><p><em>大卫·布鲁克斯</em></p><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>I was so honored to be invited to be the inaugural Class Day Speaker. But obviously since I’m a graduate of the University of Chicago, I couldn’t just accept the invitation I had to overanalyze it.</p><p>很荣幸能受邀来作毕业典礼演讲。但我是芝加哥大学毕业的，我不能简单地接受邀请，我还要过度分析一下这次邀请。</p><p>My first thought was that since this is Chicago it couldn’t just be class day; maybe it was class conflict day with special appearances by Marx and Engels and Race, Class and Gender day with Betty Friedan T-Shirts.</p><p>我首先想到的是，既然这是芝大，所以这肯定不是简单的开放日；也许这应该是阶级斗争开放日，有打扮成马克思和恩格斯的人出没，或者有穿着贝蒂·弗里丹的T-恤，庆祝种族、阶级、性别自由的学生。</p><p>Then I began wondering why the University of Chicago class is asking me of all people to be a speaker at this big event. I remembered the major addresses of my own time here and how intellectually rigorous they were.</p><p>然后我又开始想，为什么芝大偏偏请我来这个重要的场合当致辞嘉宾。我还记得我上学那时候的致辞嘉宾，他们个个严谨治学、富有洞见。</p><p>I remembered that Freshman year a noted philosopher gave an uplifting Aims of Education Address called “Death, Despair, Desolation and the Futility of Human Existence.”</p><p>我记得新生入学年，一位有名的哲学家发表了振奋人心的《教育宗旨》演讲，题为：“死亡、绝望、孤独以及人类存在的虚无”。</p><p>Then senior year at commencement our speaker was a noted biologist. I found myself tremendously inspired by his uplifting talk, “The Sixteen Qualities of Nucleic Acid.”</p><p>然后到了高年级的毕业典礼上，致辞嘉宾是位知名的生物学家。我发觉自己被他激情四射的演讲深深打动：《核酸的十六个特性》。</p><p>Eventually I realized that I am being invited because Chicago is trying to be like a normal school with a celebrity commencement speaker. But of course they couldn’t go for a big time celebrity right off the bat. Chicago is a place where you lose your virginity slowly.</p><p>最终我意识到，我之所以受邀，是因为芝大想努力地表现出，它是所“正常”的学校，有名人来做毕业典礼致辞嘉宾。当然，校方不能一下子就请一个大牌的明星。毕竟，在芝加哥就连失去自己的第一次都要很晚才实现。</p><p>For the first class day speaker, they wanted someone on TV, but only on PBS. Then, after everybody is acclimated to the outside speaker thing, they could go ahead and invite someone big.</p><p>因此，选开放日致辞嘉宾时，他们希望是在电视能看到的人，但是仅限PBS电台。当所有人都习惯了致辞嘉宾来自外界时，校方就可以请点大人物了。</p><p>That’s when the truth came to me. I am University of Chicago’s gateway drug to Stephen Colbert. You, the class of 2017 will have to suffer through me so that future classes can enjoy Matt Damon. That’s what I call living for something larger than self.</p><p>我就是这么领悟到了玄机。我呢，是芝大请来的“入门级”的扣扣熊（注：美国知名脱口秀主持人Stephen Colbert，被粉丝称为扣叔，扣扣熊等，以毒辣幽默的评论而为人称道。诱导性毒品可以是酒精、大麻等等，被认为是毒品的入门级。）。你们 2017 级的毕业生呢，要先过我这一关，然后才能在将来享受马特·达蒙（注：美国著名演员，代表组作《谍影重重》、《拯救大兵瑞恩》、《火星救援》等）。我管这叫做为了更大的目标而活着。</p><p>When I realized what was going on, I confess I was tempted to do what you millennials are always doing. I decided I would feel triggered and unsafe and lead a campaign to get myself disinvited. All the historical traumas of being a lower-middle range celebrity came down on me and I retreated to my safe space, which is under the bar at Jimmy’s.</p><p>当我意识到我为什么受邀时，我其实差点儿没忍住做了你们千禧年一代爱做的事。我得觉得自己受到高能预警，没有安全感，要发起一场运动，抵制这次自己的受邀。之前作为一名中低端名人的种种伤痛记忆都向我袭来，我退回了自己的安全区，就是吉米酒吧那里。（注：千禧年一代指在 1981-2000 年出生的人）</p><p>But since none of you did your generational duty and got me blocked from this gig, I’ve decided to go ahead.</p><p>但既然你们没有履行你们这一代的义务，像之前那样抵制致辞嘉宾，我决定继续说下去。</p><p>Since Chicago is new to this game I should note that there are certain traditions involved in these kinds of occasions.</p><p>既然芝加哥大学对于“正常”的毕业致辞还不熟悉，我需要指出在这种场合下一般有的传统元素。</p><p>At occasions like this major universities ask a person who has achieved a fantastic career success to give you a speech telling you that career success is not important.</p><p>像今天这个场合，知名大学会请一位功成名就知名人士来给你们致辞，告诉你们，成功并不重要。</p><p>At occasions like this major universities often ask billionaires to give speeches telling you how much you can learn from failure. From this you can take away the lesson that failure seems really great if you happen to be Steve Jobs or J.K. Rowling.</p><p>像今天这样，知名大学常常会邀请亿万富翁来致辞，告诉你们能从失败中学到什么。从这种讲话中将领略到失败是多么了不起的事情，当然，你得恰好是乔布斯或者 J.K.罗琳才行。</p><p>Then we speakers are supposed to give you a few minutes of completely garbage advice: Listen to your inner voice. Be true to yourself. Follow your passion. Your future is limitless.</p><p>然后我们这种嘉宾就该有模有样得给你们一些烂大街的建议：遵从你的心声呀，做真实的自己呀。追逐自己的激情呀，你的未来无限可能呀之类的。</p><p>First, my generation gives you a mountain of debt; then we give you career-derailing guidelines that will prevent you from ever paying it off.</p><p>事实上，我们这一代人让你欠下一屁股债（即美国国债），然后给你一些绝对会搞砸事业的建议，让你以后连债务都还不清。</p><p>That’s why when I’m asked to speak at these things I always try to tell graduates is that since you haven’t graduated from college before you may not know the etiquette. When you get your degree, it’s always nice to tip President Zimmer 10 or 20 bucks just to show he did a good job. It’s also nice to slip the class day speaker a few bills—maybe two or three thousand. Five thousand for the economy majors.</p><p>正因如此，轮到我讲这些的时候，我总是试着向毕业生传达，由于你们之前没有经历过大学毕业这事，可能就不知道这里面的套路。当你接过毕业证书时，最好打赏校长齐默 10 到 20 美元，等于是为他的工作点个赞。当然最好也能给开放日致辞嘉宾塞些钱——塞个两三千美元什么的。经济系的就给五千吧。</p><p>On these occasions I also always try to inspire students by telling them about the glittering possibilities in front of them. Within just a few short years many you will be sleeping on your parent’s couches while working for a completely dysfunctional NGO. Others of you will have soul crushing jobs as corporate consultants, working on power points presentations past midnight at the Topeka Comfort Inn.</p><p>在这种场合，我通常会试着鼓励一下学子，告诉他们未来一些闪光般的机遇。过不了几年，你们中就会有不少人躺在父母的沙发上呼呼大睡，平时也就是去些办不下去的非政府组织里打打酱油。还有一些会被企业咨询一类的工作磨掉心智，天天为了 PPT 在 Topeka Comfort Inn 熬到半夜。（注：Topeka Comfort Inn 是那种几十美金一晚的廉价旅店，名字里面带“舒适”，略讽刺）</p><p>I’m here to help you navigate these exciting possibilities. I’m here to help you take advantage of the skills you learned at the University of Chicago. You learned how to dominate classroom discussion after having done none of the reading. You learned how to stare at professors with looks of complete rapt attention even though secretly you were completely asleep.</p><p>我今天来就是给你们说说该怎么应对这类鸡冻人心的未来。我过来是帮你利用好在芝大学到的技能。你学会了在不做任何阅读的情况下，依然在课堂讨论中称霸一方。你学会了假装全神贯注地盯着台上的教授，实际上你早已昏昏欲睡。</p><p>I’m here to urge (you to) lives of public service, working on Capitol Hill for  congressmen, while bringing the nation’s top leaders coffee and sexual tension. I’m here to urge you to serve the world’s poorest people in ways that will look really good on your resume, like organizing an anti-malarial bed net drives while rocking Jimmy Choos at Goldman Sachs. I’m here because, as someone who now teaches at Yale, you should have some sense of what it would have been like if you’d been accepted there.</p><p>你们要尽早从政为民，去国会山给众议员工作，给政界高层人物端个咖啡、带来性焦虑。（注：讽刺办公室性骚扰以及指控性骚扰带来的冲突）去帮助那些穷困潦倒之人，让自己的简历看起来漂亮。比如组织个反疟疾蚊帐推广运动什么的，同时自己拎着吉米·周的包包在高盛晃悠。我今天来是因为，由于我现在在耶鲁教书，所以你应该能大概知道如果你去那儿的话，你感受到的氛围是怎样的。</p><p>But ultimately, I’m not here to give you some standard speech. This is Chicago. This is the only time in my life that I will get to address the graduating class at my own school, at the place that formed me down to my bones.</p><p>但话说回来，我来这儿不是为了熬一锅程式化的鸡汤。这里是芝加哥。这是我人生中唯一一次能给我的母校毕业生致辞的机会。芝大给我打上了深深的烙印。</p><p>I confess I didn’t enjoy every day I spent here. I majored in History and Celibacy. I learned how to walk through campus while awkwardly averting my eyes from anybody I might know. But like all of you, I was changed fundamentally in this place.</p><p>说实话，我当时并非每天都很开心。我主修历史也主修禁欲。我学会了如何在穿过校园的同时又假装没看到任何一个我可能认识的人。但和你们一样，芝大彻底改变了我。</p><p>The older I get the more I become aware of how it shaped me. I’m 34 years out of college and I feel more influenced by the University of Chicago today than I did on the day I graduated.</p><p>随着年岁的增长，我越发体会到芝大对我的影响。我毕业都 34 年了，可我感觉如今芝大对我的影响甚至比我毕业时还明显。</p><p>So today I’d really like to talk to you about two things: The things Chicago gave me, which I’ve carried through life, and the things Chicago failed to give me, which I had to learn on my own.</p><p>所以今天我想给你们讲两点：芝大教给我让我受用至今的东西，以及它没有教给我从而我必须自己学习的东西。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>When I think back on my time here I remember certain moments of great intensity. There was one very odd moment during my first year when I was reading a book called The Death of Tragedy by Nietzsche in a carrel on the A level of the Regenstein.</p><p>回想我在芝大念书的时候，我记得有那么几次，我受到了头晕目眩的冲击。我大一时有一次就很奇怪，我在读一本书，书名是《悲剧的死亡》（此处有梗），尼采写的，在芝大雷根斯坦图书馆 A 层。</p><p>I don’t know what it was: the driving semi insane power of Nietzsche thought, the overwrought and intoxicating nature of his prose, but somehow while reading that book reality seemed to slip its bounds. I lost all sense of where I was or who I was or how time was passing or whether it was passing at all. Hours flew by and I was just buried inside that book.</p><p>我也说不上怎么回事。尼采思想的那种近乎癫狂的驱动力，还有他那仿佛魔力一般能引起情绪起伏的散文。总之，读那本书的时候，虚实之间的界限模糊了。我全然分不清我在哪儿，我是谁，感受不到时间的流逝，觉得时间完全静止。几个小时过去了，我仿佛钻到那本书里。</p><p>I was not so much reading it; I was immersed in the torrent of its prose and the fury of its ideas. I was just a sort of dissolved, lifted out of myself, transported, subsumed, and some sort of trance or a state of awed reverence or under a spell cast by a semi crazy long dead mind.</p><p>我感觉自己不是在读它，而是被裹在那散文的激流中，猛烈的思想冲刷着我。感觉自己仿佛在溶解，灵魂出了窍，前往别处，被吸收了。朦朦胧胧的，敬仰之情油然而生，好似被一位早就死了的半疯之人施了魔咒。</p><p>There I was in a shabby carol on the basement level of the ugliest building on God’s green earth, and I was experiencing something close to transcendence. And when I awoke from that state I looked around startled and blinking, shocked to be re-entering the 20th century, and real life.</p><p>当时在地下室，在那栋世界上最丑的楼里，我体验了一把超验的感觉。当我回过神的时候，我懵懵地看着四周，挤弄着眼睛，不敢相信自己还能回到 20 世纪，回到现实。</p><p>I never really became a Neitzsche fan, but it was exciting to know that the ideas of some dead genius, could transport me and give me a glimmer of a higher realm. There were other intensities during my time here. There was intense arguing with all my friends about bullshitty subjects at the dining hall hour upon hour. There were intense pseudointellectual debates with graduate students at Jimmys; There was the intensity of serious movie going at Doc Films; and most of all there was a certain intensity in class.</p><p>我从未成为尼采真正的粉丝，但振奋人心的是，我知道这些逝去的天才依然能带我一把，去领略一下那更高的殿堂。我在芝大还体会过其他张力十足的时刻。我和朋友们激烈地争论过一些乱七八糟的话题，在食堂里唧唧呱呱几个小时。我和毕业生们装作知识分子一样在吉米酒吧那里争论过。这种时刻还出现在 Doc 影院放映着严肃电影时。当然，最激烈的还得算在课堂上。</p><p>In those days it was pure Great Books for the first two years, and our professors didn’t just teach them, they proselytized them. Some of the old German refugees from World War II were still around then, and they held the belief, with a religious fervor, that the magic keys to the kingdom were in these books. The mysteries of life and how to live well were there for the seizing for those who read well and thought deeply.</p><p>那时候，头两年都是存粹地读一些伟大的书籍。而我们的那些教授们不仅仅是教这些书，而是在试图让学生皈依。老师中有一些德国的难民，二战中幸存后依然活着，他们怀着宗教般的热烈，相信通往极乐世界的魔法钥匙就在这些书中。生命的神秘以及美好生活的神性，就在这些书里，等着那些热爱阅读、思考深邃的人来发现。</p><p>There was a legendary professor named Karl Weintraub teaching Western Civ then. Years later, when he was nearing death he wrote to my classmate Carol Quillen about his experience teaching these books.</p><p>当时有位堪称传奇的教授，叫卡尔·温特莱布（注：美国历史学家，自 1954 年起在芝大任教，同时指导社会理论、文化历史等人文学科方面的研究）教西方文明史。好多年后，他快去世之前，写信给我的同学卡罗·奎林，讲述他教这些书的体验：</p><p>Teaching Western Civ, Weintraub wrote, “seems to confront me all too often with moments when I feel like screaming suddenly: ‘Oh, God, my dear student, why CANNOT you see that this matter is a real, real matter, often a matter of the very being, for the person, for the historical men and women you are looking at — or are supposed to be looking at!”</p><p>温特莱布写道：“教授西方文明史似乎经常把我推到想要尖叫的地步：”噢，天哪，这位同学，你怎么就不明白，这个问题真的，真的很重要，事关一个人之所是，这些你正在学习的历史人物，或者说你应该要去学习的历史人物。</p><p>I hear the student’s answers and statements that sound like mere words, mere verbal formulations to me, but that do not have the sense of pain or joy or accomplishment or worry about them that they ought to have if they were TRULY informed by the live problems and situations of the human beings back there for whom these matters were real.</p><p>我所听到的学生们的答案也好，陈述也好，只是纯粹的词句、空有语言的架子。没有他们该有的心痛、喜悦、成就感和担忧，如果他们打心底意识到这些人类所面对过的问题和境遇如何与生死休戚相关的话，就能真切地感受当时这些问题的重要。</p><p>The way these disembodied words come forth can make me cry, and the failure of the speaker to probe for the open wounds and such behind the text makes me increasingly furious. “If I do not come to feel any of the love which Pericles feels for his city, how can I understand the Funeral Oration? If I cannot fathom anything of the power of the drive derived from thinking that he has a special mission, what can I understand of Socrates? …</p><p>这些学生们抽象的讨论，常常催我泪下。而谈论它的人要是没能去探寻这些历史伤痕以及文字背后之事的话，就会让我非常愤怒。”如果我未能体会到伯利克利（注：雅典黄金时期（希波战争至伯罗奔尼撒战争）具有重要影响的领导人。他在希波战争后的废墟中重建雅典，扶植文化艺术，现存的很多古希腊建筑都是在他的时代所建）对他所在之城的爱，我又怎能理解那篇《葬礼演说辞》？如果我没有去探究苏格拉底坚信自己身负特殊使命的精神之源，我又如何理解他呢？</p><p>How can one grasp anything about the problem of the Galatian community without sensing in one’s bones the problem of worrying about God’s acceptance? “Sometimes when I have spent an hour or more, pouring all my enthusiasm and sensitivities into an effort to tell these stories in the fullness in which I see and experience them, I feel drained and exhausted. I think it works on the student, but I do not really know.”</p><p>如果一个人压根不担心上帝接不接受你这一问题，又怎么能理解加拉太人面临的处境呢？有时候，我花上一个多小时，拿出我全部的热情和细腻向学生全面地讲述我所体会到的一切，我感到自己被抽空了，精疲力竭。我觉得这对学生有用，但我并不确定。</p><p>It is a tragedy of teaching that sometimes the professors pour more into the class than the students are able to receive. But in truth that intense teaching is more like planting. Those teachers like Weintraub were inserting seeds that would burst forth years or decades later when the realities of adult life called them forth. I hated Edmund Burke when I read him here but years later he exploded in my mind and has become one of the great guides of my life. I was blandly indifferent to Augustine when I encountered him, it was only later that I understood the power of his loves and his wrestling with his own soul, and the need to be careful about what you love, because you become what you love.</p><p><strong>教学的一个悲剧就是，有时候教授们在课堂上倾注的远多于学生能吸收的。但实际上，这种高强度的教学更像是在树人。像温特莱布这样的老师，是在播种，等到几年甚至几十年后，成年生活中的种种现实会浇灌这些种子，令其茁壮生长。我在芝大读埃德蒙·伯克时，我很反感他。但多年后，他又重回我的脑海，并成为了我生活中的一位重要向导。我初读奥古斯汀时，提不起什么兴致，直到后来我才理解了他那爱与灵魂挣扎之中蕴含的力量，明白了要谨慎得对待我之所爱，因为它会成为我之所是。</strong></p><p>Chicago gave me glimpses of the mountain ranges of human existences. It gave me a set of longings, higher longings than any I had had. In the first place, I longed to know how to see. Seeing reality seems like a straightforward thing. You just look out and see the world. But anybody who is around politics or many other arenas knows how many people see the world with a distorting mirror, how many see only what they want to see, or what they can see by the filtering light of their depression, fear, insecurity or narcissism.</p><p><strong>芝大让我领略了人类文明的崇山峻岭。它点燃了我内心的诸多渴望，我从未有过的更高层次的渴望。首先，我渴望看见。看见现实似乎是再明显不过的一件事，只需要睁开眼，就能看到这个世界。但是关切政治讨论以及其他领域的人都清楚，有太多人带着扭曲的视角看世界，有太多人只想看到他们想看到的，或者，只能看到由他们压抑、恐惧、不安全或是自恋的滤镜处理过的世界。</strong></p><p>Sometimes I think the whole disaster of the Trump presidency is because of a breakdown of intellectual virtue. A break down in America’s ability to face evidence clearly, to pay due respect to the concrete contours of reality. These intellectual virtues may seem elitist, but once a country tolerates dishonesty, incuriosity and intellectual laziness, then everything else falls apart.</p><p>有时候我觉得，特朗普当选总统的噩梦，正反映了求知美德崩坏的现实。美国人实事求是的能力崩坏了，没有给事实的清晰轮廓以足够尊重。这些求知的美德或许显得有些精英主义，但一旦一个国家开始容忍欺瞒、无知、懒于探索，那就必将礼崩乐坏。</p><p>John Ruskin once wrote, “The more I think of it I find this conclusion more impressed upon me— that the greatest thing a human soul ever does is to see something, and tell what is saw in a plain way. Hundreds of people can talk for one who can think, but thousands can think for one who can see.” At Chicago, I encountered so many writers who could see so purely and carefully –Shakespeare, Hume, Socrates and George Eliot, George Orwell and Hannah Arendt. I met so many professors and students who could weigh evidence and who didn’t tolerate intellectual shabbiness. It aroused in me a desire to have that virtue—the ability to see clearly and face unpleasant facts.</p><p><strong>约翰·拉斯金曾写到：“我越是深入地思考，我就越倾向于得出这个结论——人类所能做的最了不起之事就是，看到了什么，便如实地说出来。千百人口说不如一人思索，千万人思索不如一人见过。”在芝大，我邂逅许许多多目光澄澈又细腻的作家：莎士比亚、休谟、苏格拉底、乔治·艾略特、乔治·奥威尔还有汉娜·阿伦特。我见过许许多多注重实证、不容马虎求知的教授和学生。这让我也渴望具备此种品质——懂得观看之道，直面不快的现实。</strong></p><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p>Then there was the second yearning which is the yearning to be wise. I really couldn’t tell you then what wisdom consists of, and I still can’t give you a concrete definition. But we all know wisdom when we see it. There is a deep humanity, gentleness, and stability to a wise person. That person can perceive, with love and generosity, the foibles of another heart. That person can grasp the nub of any situation, see around corners and has developed an intuitive awareness of what will go together and what will never go together.</p><p><strong>第二种渴望，就是对智慧的渴望。我无法告诉你智慧由什么构成，也说不上智慧的准确定义。但我们见到智慧时，我们都会认出它来。根植于心的人性、风度和稳重就体现在智者的身上。他能透过爱与包容去审视别人的缺陷；他能直指任何问题的核心；环顾四野，便可洞见凝聚之力与不可强求之事。</strong></p><p>That wisdom, I imagine, comes from paying deep and loving attention to the people around you. It comes from many hours of solitary reflection. It comes from reading of the greats. It comes from getting out of your own century, thinking outside of your assumptions and embarking on a great lifelong journey toward understanding. That sort of humane wisdom was admired here. We wouldn’t have told each other this, because it would be too pretentious, but all those bullshitty dinner table conversations  and bar stool conversations about the great ideas were attempts to put together the building blocks of that kind of wisdom. They were attempts to put ourselves together so we could be of use. They were attempts to imitate penetrating insight of Hume, the smile of Voltaire, and the gentle guidance of a dozen professors whose names you may know or may not know, some living Nathan Tarcov, Josef Stern; some of my old professors who are now dead.</p><p><strong>在我看来，要具备这种智慧，我们需真情实意地关怀身边的人，需要时常在独处中自我反省，需要阅读伟大的作品；需要我们跳出所置身的时代，跳出自己现有的成见，动身踏上求取理解的终身之旅。芝大推崇这种闪耀人性光芒的智慧。我们用不着奔走相告，因为那样太过刻意。但我经历的那些食堂扯谈和酒吧论战，都是在尝试将这种智慧的零件组装在一起。我们试着塑造我们自己，从而成为有用之人。我们试着像休谟那样富有洞见，像伏尔泰那样微笑、像许许多多的教授那样诲尔谆谆，你们也许知道或不知道的名字，在世的有内森·塔可夫、约瑟夫·斯坦恩，还有的老教授，已别离人世。</strong></p><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><p>Third, Chicago gave me a yearning for ideals. It is sometimes said that we humans seek happiness. We seek the fulfillment of our desires. But of course that’s not true. Peace and happiness is great for a while but after a bit it gets boring. “What our human emotions seem to require,” William James once wrote, “is the sight of struggle going on. The moment the fruits are being merely eaten things become ignoble. Sweat and effort, human nature strained to the uttermost and on the rack, yet getting through it alive, and then turning back on its success to pursue another more rare and arduous journey—this is the sort of thing that inspires us.”</p><p><strong>第三，芝大给了我对理想的渴望。有时候人们说，人生的目的在于寻求幸福。我们寻求自身欲望的满足。当然，这不是事实。平静和幸福只是短暂的美好，很快人们就开始无聊了。“人类情感似乎需要的是”，威廉·詹姆士曾写道：“能一直看到挣扎的景象。果实被吞下的那一刻，满足感就顿显卑劣。汗水与努力，人性承受极限之压，痛苦不堪，然而度过了这一劫，又拒绝享受成功，转而踏上更为人迹罕至的艰苦之旅——正是这种事情激励着我们。”</strong></p><p>James summed it up pretty well. Human existence is the same eternal thing: Some man or womans’ pains in pursuit of some exalted ideal.</p><p>詹姆士总结得很好，人类的存在有着一个永恒的主题：每个人的痛苦铺就了追逐至高理想的路。</p><p>I recently saw the movie “Hidden Figures,” about some African American women who served the cause of space exploration and racial justice. Those women weren’t exactly happy in that movie, in the story told by the movie，but there was a spiritual intensity serving their two great ideals. That’s what we want in all of our lives. Intense struggling for the good.</p><p>我最近看了电影《隐藏人物》，讲得是一些非裔的美国女性投身于太空探索和种族正义的事业。这些女性在电影中并不快乐，故事中看不出来她们的快乐。但是，有一股精神张力一直推着她们追逐这两个伟大的理想。那正是我们所有人生命中想要的。对美好事物极力地争取。</p><p>If nothing else, Chicago presented us with high ideals in profusion: the patriotism of Pericles, the commitment of Fermi, the American dream of Alexander Hamilton. I surely wasn’t smart enough to come up with my own philosophy or set my own ideals. But I could try on different ideals passed down to us from our betters, and I could see which ones seemed to fit, and I could join that parade.</p><p><strong>芝大至少给我们呈现了泉涌般高尚的理想：伯里克利的爱国情操，费密的专注，亚历山大·汉密尔顿的美国梦。我当然还没有智慧到可以发明一套属于我自己的哲学，或是创立属于我自己的理想，但我可以尝试这些贤者传递给我们的理想，看看我认同哪些，然后我参与到传承它的队伍中去。</strong></p><p>They say that life here is about the life of the mind, but that is an injustice. The mind and the soul are not so easily separated. These yearnings that I have described transplanted me here–to see the world clearly, to be wise, to pursue ideals—these weren’t really the yearnings of the mind. They were yearnings from deeper, from the part of us that can only be called the soul.</p><p>他们认为，这儿的学院生活就是心智生活，但这话有失偏颇。心智和灵魂不是那么容易分开的。我刚刚讲过的这些渴望，想要看清这个世界，想要变得智慧，想要追求理想，这些不算是精神追求。他们源自更深层的地方，我们将其称之为灵魂。</p><p>We don’t talk about this much in our secular culture, but there is a part of us that doesn’t care about Facebook likes, or annual income or even how popular you are. This is the part of us that yearns for permanent things, for beauty, truth, justice, transcendence and home. This is the part of us that is morally valuable, that each of us worthy of dignity and respect. The poet Rilke had an education like ours. He wrote, “I am learning to see. I don’t know why it is, but everything penetrates more deeply into me and does not stop at the place where until now it always used to finish. I have an inner self of which I was ignorant. Everything goes thither now. What happens there I do not know.”</p><p>我们在俗世中并不怎么谈论灵魂，但我们在一些时候也会不关心脸书上有没有人点赞，不关心年收入，甚至不在乎自己红不红。这种时候，我们就是在追求永恒之物。追求美、真理、正义、超验和家园。这正是我们身上道德价值的体现，是我们每个人应受尊重、享有尊严之所在。诗人里尔克曾有过类似的体会。他写道：我学着看见。我不知为何如此，但此刻，一切都向我深处渗透，一切都不再停留在它们之前停下的地方。我体内还有一个我，我不知道的我。一切都到了未知的领地，那里发生的事我并不知晓。</p><p>I’ll never be as deep as Rilke, but I was deeper when I left Chicago than when I arrived. More important, I graduated from the University of Chicago with a little sense of my soul and its yearnings.</p><p>我无法像里尔克那样深刻，但我离开芝大时，我比来芝大时更深刻了。更重要的是，我从芝大毕业时，朦胧地感知到了我的灵魂和渴望。</p><p>There was a lot of longing going on then. And there still a lot that goes on today. Two Saturdays ago my wife Anne and I got together with the philosophy professor Candace Vogler in Cobb Hall and led a seminar under the sponsorship of the Hyde Park Institute. It was a beautiful spring day and we all spent it inside, talking about character and spiritual growth, about Aquinas and Beethoven and Victor Frankl. We took a lunch break and set to going out to enjoy the sun. Some of the students had their sandwiches inside and had an internal debate among themselves about the immateriality of the soul. Only in Chicago. And I saw that day this place is still wonderfully itself. I felt some of that old intensity of purpose.</p><p>那时我怀着诸多渴望，今天也是如此。两周前，我的太太和我还有哲学教授 Candace Vogler 在考伯大楼里主持了一场研讨会，由海德公园研究所赞助。那是个明媚的春日，我们都在室内，谈论品格和精神成长，讨论阿奎奈（注：意大利神学家）、贝多芬、维克多·弗兰克尔（注：著名犹太裔心理学家，他是二战集中营幸存者）。我们中午吃午饭时，出去沐浴了一会阳光。有的学生在室内吃着三明治，他们内部进行了一场辩论，关于灵魂的非物质性。芝大独有的景象。那天我觉得，这里仍然是个神奇的地方，我感觉到了那种旧时的强烈使命。</p><p>There is still the same honest and unironic hunger for wisdom. There is still the willingness to put your ideas out there and argue and listen. There is still that ardent searching for truth and the willingness to be silly in pursuit of it.</p><p><strong>仍然可见的是那种诚肯端正的求知若渴，仍然可见的是人们愿意亮出观点，然后辩论和倾听。仍然可见的是求真的热情，以及不耻下问的精神。</strong></p><p>Chicago gives you a taste for mountaineering, for climbing up toward the summits of human existence.</p><p><strong>芝大让你向往攀登高峰，朝着人类存在的顶峰不断攀登。</strong></p><p>Afterwards, you’re never quite content living in the flatlands, living solely in the stuff that gets written about on twitter, or even in the newspapers or talked about on reality TV. Many years ago a man named Robert Maynard Hutchins bet this institutions future on one proposition: that if you put the big ideas in front of a bunch of 20-year-olds you can change their life forever. I can tell you, it worked for me. It completely worked for me.</p><p><strong>经此一役，你就再也不会满足于停留在平地上，再也不会满足于只是刷刷推特，甚至不会满足于看看报纸或是真人秀节目。</strong>多年前，一位名叫罗伯特·梅纳德·哈钦斯（注：美国教育家，曾任芝大校长）的人将芝大未来的希望押注于这一点：若能把伟大的理念摆在一帮 20 来岁的年轻人眼前，则会改变他们的一生。我可以告诉大家，这一理念在我身上是奏效的，芝大完全改变了我。</p><p>And this change that happens in those of us who went here is a very practical change.</p><p>这种改变，对于那些求学于此的人，也是务实可见的改变。</p><h2 id="05"><a href="#05" class="headerlink" title="05"></a>05</h2><p>We have a Telos Crisis in this country. Many people do not have a clear sense of their goals and their own purpose. They don’t know what they are shooting for, or what fundamental convictions should guide their behavior. They’ve been trained in hyper-specialized research universities that tell them how to do things but don’t ask them to think about why they should do them; that don’t give them a forum to ask the questions, What is my own best life? What am I called to do? Why am I here?</p><p>目前在这个国家，我们正经历着关于终极意义的危机。许多人对自己的目标和目的没有清晰的认识。他们不知道他们在追逐什么，或者遵从什么样的根本信念行事。他们在各自细分的专业领域接受大学的科研训练，学校教他们怎么做事，却不教他们思考为何要做。大学也没有为他们提供发问的论坛，去问我应该如何生活？我的使命是什么？我为什么要来这里？</p><p>From college they enter the world we all live in, which is a busy world. The flow of a thousand emails, the tasks of setting up a career and family. These things distract from the great questions of purpose and meaning.</p><p>从大学里走出，他们就进入了真实的世界，一个忙忙碌碌的世界。成千上万的电邮要回，马不停蹄地规划事业、组建家庭。种种此般皆让人无法聚焦于关乎生命意义与目的的问题。</p><p>I find that many people haven’t even been given a moral vocabulary to help think these things through.</p><p>我看到很多人就连这些思考德性话题的词汇都不具备。</p><p>They haven’t been surrounded with a functioning moral ecology and a set of ideal to guide and orient them.</p><p>他们并没有处在一个良好的道德生态之中，也甚少接触那些能引导指点他们的理念。</p><p>And this produces a great emotional fragility. Our friend Nietzsche said that he who has a why to live for can endure any how. But if you don’t know what your purpose is then the first failure or setback can totally throw you into crisis and total collapse.</p><p>这就造成了一种巨大的情感脆弱。我们的朋友尼采曾说过，若知为何而生，遂可纳受一切。但倘若你不知道自己的使命，那即使是第一次失败或挫折就能置你于危机之中，让你彻底崩溃。</p><p>I see this among my former students, and I see it over and over again in people in their mid-twenties. The young person without a conscious purpose graduates and hopes by piling success upon success he can fill the void within. He becomes what the writer Matias Dalsgaard calls: The Insecure Overachiever: “Such a person, “ Dalsgaard writes, “must have no stable or solid foundation to build upon, and yet nonetheless tries to build his way out of his problem. It is an impossible situation. You can’t compensate for having a foundation made of quicksand by building a new story on top of it. But this person takes no notice and hopes that the problem down in the foundations won’t be found out if only the construction work keeps going.”</p><p>我在我教过的学生身上看到过这种缺失，二十几岁的年轻人身上也屡见不鲜。没有明确目标的年轻人毕业了，指望用一次次堆砌成功来填补内心的空洞。他们成了 Matias Dalsgaard 所谓的“焦虑的佼佼者”。（注：Matias是麦肯锡前雇员，指出在初入职场的年轻人身上特别明显地存在一种焦虑状态，后来他在书详述了这种焦虑状态的五个特点）Dalsgaard 写道：“这种人一定没有稳固的处事根基，但依然试图让自己从所遇的问题中解脱出来。这等于陷自己于不可能之境。你无法通过建造新的楼层，来弥补像流沙一般的地基。但这种人会继续无视这点，一心希望只要修建工作继续下去，地基的问题就不会被发现。”</p><p>But of course the reckoning always comes. It produces the crisis, the depression, the sadness. David Foster Wallace noticed it back in 1996: “It’s more like a stomach level sadness,” He wrote, “I see it in myself and my friends in different ways. It manifests itself in a kind of lostness.</p><p>但凡事终有报。危机感来临，压抑感和沮丧接踵而至。大卫·福斯特·华莱士（注：美国知名作家，其畅销巨著 Infinite Jest 被《时代》杂志列为 1923 年至 2005 年间最伟大的百部小说之一）在 1996 年注意到了这点，他写道：“这种悲伤深入直觉。我在自己身上、朋友身上都以不同的方式看见过。它表现出一种若有所失。”</p><p>“This is a generation that has an inheritance of absolutely nothing as far as meaningful moral values goes,” He wrote, “You can see the fruits of the Telos Crisis in the rising suicide rates, the rising drug addiction rates. You can see the social distrust. You can see the isolation and the lives of people who are adrift.</p><p>“从意义性与道德观念方面来看，这是继承了虚无的一代人。终极意义危机的恶果体现在不断攀升的自杀率上，体现在不断增加的毒品成瘾上，你看到社会信任缺失，不少人过着离群索居，漂泊无依的生活。”</p><p>The fact that you went to Chicago means you’ll always have an orientation that is slightly different than the mainstream culture, slightly countercultural. You’ll have a harder time being shallow. You may not know your life’s purpose or your calling, but you know that that mountain world exists and you can explore it, and that the answers can be found up there in the Museum of Beautiful Things, and that knowledge itself will be a source of great comfort and stability.</p><p><strong>你到芝大来，就意味着你一定会受到一种指引，它与主流文化略有不同，稍微逆流而行。肤浅地过活，反而变得不易。你可能并不知道生命的意义或是你的使命，但是你知道崇山峻岭就在那里等着你去探索，人生的诸多答案就在那座美好之物的博览馆里，知识会给你莫大的安慰，让你变得冷静沉稳。</strong></p><p>Life at the university of Chicago is not always filled with day to day happiness. But it gives you glimpses of cosmic happiness, glimpses of understanding the long story all involved in. And if you have cosmic joy, because you know this story is ultimately about something meaningful, holy and good, you can bear the day to day miseries a lot better. So that is the good side of what I got here and what I hope you got here. Let me finish by speaking very briefly about what the University of Chicago did not give to me, and where it failed me.</p><p>在芝大的生活并非流淌着日常幸福。但它会让你瞥见更大我的幸福，瞥见人类漫长求索之旅的宏图。如果你体会到了这种大我的欢愉，因为你知道它最终关切的是生命的意义，神圣与美妙，那你自然能更好地承受日常的痛苦。这些就是芝大赐予我的美好，也是我期望大家也能从这儿获取的。最后我想简单说一下芝大没能教给我的东西，芝大辜负我的地方。</p><h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><p>Now here I speak provisionally, because I’m going to start talking about the school as it was in the 1980s, and a lot of the problems may have been fixed by now.</p><p>我得声明我说的这些都是陈年往事，因为我下面谈到的是芝大上世纪八十年代的情况。很多问题现在可能都不是问题了。</p><p>It is traditional for alumni to say that the college was better in their own day. As both an alum and a trustee I can tell you that’s nonsense here I’m here to tell you that Chicago is way better now than it was when I was here, and way better than it has ever been.</p><p>校友们大多会说旧时的校园有旧时的好。身为芝大的校友和校董之一，我觉得这种说法是无稽之谈。事实上，现在的芝大远远好过我求学时的芝大，也远远好过以往任何时候的芝大。</p><p>But in my era, and maybe today, Chicago did not prepare its students for intimacy. As I’ve grown older I’ve come to see that the capacity for intimacy is one of the more crucial talents for a fulfilling life.</p><p>但我上学那会儿，可能今天依然如此，芝大并未教会学生如何建立亲密的人际关系。<strong>随着我年岁渐长，我开始意识到，构建亲密关系的能力是促成圆满人生的重要本领之一。</strong></p><p>That’s because the primary challenges of life are not knowledge challenges, they are motivational challenges. It’s not only knowing what is good, but being completely and passionately devoted and loving what is good.</p><p><strong>这是因为，人生面对的首要挑战不是知识的挑战，而是动力的挑战。人生在于不仅要知道何为益事，还要带着爱与热血全身心投入其中。</strong></p><p>It’s about passionately loving your spouse and family in a way that brings out their loveliness. It’s about loving your vocation with fierce dedication. It’s about loving your community with a serving heart. It’s about loving your philosophy or your God with a humble fervor.</p><p><strong>人生在于热烈地爱着你的配偶和家人，以至于焕发出他们内心的爱。人生在于坚定地热爱自己的事业，在于服务自己所爱的社区，在于以虔诚赤子之心爱着自己奉行的哲学或上帝。</strong></p><p>A fulfilled life is moving from open options to sweet compulsions. It’s about saying no to a thousand things so you can say a few big yeses to the things you are deeply bound to. It’s about loving things so much that you’re willing to chain yourself down to them. The things you chain yourself to are the things that set you free.</p><p><strong>圆满的人生是从开放式选择走向甜蜜献身的过程，是你千万次的拒绝只为去做几次你深深牵挂之事，是你愿意为把自己和所爱之事绑在一起。你虽把自己绑在它们身上，可它们却会给你自由。</strong></p><p>And it’s not only loving Platonically. It’s actually and intimately living out the day to day realities of your fierce love. It’s intimately sharing the same bathroom or getting up every day and writing on the same damn laptop.</p><p><strong>这种爱不只是柏拉图式的理想之爱，而是将内心的热爱真正地融入到日常生活的点滴之中。与朋友们共享浴室，同起同睡，在共享的电脑上写写画画。</strong></p><p>It’s about mastering all the phases of intimacy: being open to the first enticing glance. Having the energy to really learn about those people, like those people on a first date who learn how much they have in common with each other and treat these things as amazing miracles: “”You don’t like foigras? Neither do I! We should get married!”</p><p><strong>它在于把握亲密关系的每个阶段：对第一个媚眼回以示意。真正地花精力了解那些人，就像是第一次约会的人那样，发现彼此之间的有诸多的共同点，会认为这是惊人的巧合：“你不喜欢肥鹅肝么？我也是！不如我们结婚吧！”</strong></p><p>It’s about having the courage to engage in the reciprocal cycle of ever greater vulnerability. It’s about enduring faithfully when there is some crisis and you’re not sure you believe in this relationship, this career or this institution. It’s about forgiveness for the betrayals committed against you and asking forgiveness when you have let down your friends or your profession or your spouse. When you make an intimate connection—to a spouse, a friend, a profession or a community or faith—you are as Leon Wieseltier puts is, “consenting to be truly known, which is an ominous prospect.” And so one needs the skills of intimacy to live well in such close proximity. One needs the skills of intimacy to achieve the kind of fusion that leads to real joy—when a couple become one loving entity, when you and your vocation have merged into a single identity, when your love for your God or your philosophy is a complete surrender.</p><p><strong>它在于勇于直面循环往复的脆弱感。在于遭遇危机后依然坚守，即便自己不确定是否还相信份关系、这份事业或这个机构。在于宽恕对你的背叛，当你辜负朋友、工作失误或是伤了配偶的心时，能请求谅解。当你与配偶、朋友、职业、社区或信仰建立密切联系时，你就像里昂·维斯提耶所说，“愿意被他人真正地了解，虽然前路危机四伏。”所以人们需要学会建立亲密关系，实现相处之道。人们需要学会建立亲密关系，彼此相依，体悟人生真趣——一对夫妇要成为爱的化身，你和你的事业要合为一体，你应完全献身于自己所信奉的哲学或上帝。</strong></p><p>What I’m describing here are emotional arts. They are not natural but have to be acquired by repeated vulnerability, commitment and experience.</p><p><strong>我在这里谈的是情感的艺术，我们并非天生就懂得它，需要反复经历脆弱不堪、矢志不渝、人情历练后才能掌握它。</strong></p><h2 id="07"><a href="#07" class="headerlink" title="07"></a>07</h2><p>When I was here at Chicago, we students by and large did not excel at intimacy. We were artful dodgers, with a superb ability to slip out of situations at moments when deep heart to heart connection might come. We were in the business at age 20 or 21 of trying to make a good impression, so of course we weren’t going to show the unattractive sides of ourselves, which is an absolute prerequisite of intimacy.</p><p><strong>我在芝大念书时，我们身为学生总体上都不太善于建立亲密关系。我们非常善于逃避，尤其是回避那些心有灵犀般羁绊或将到来的场合。我们当时正忙着在二十岁出头时一鸣惊人，自然不想展示自己平庸无奇的一面，可这正是建立亲密关系的绝对前提。</strong></p><p>We were busy with our work and our books and student activities, and we told ourselves, idiotically, that we didn’t have time for deep relationships. We too often approached each other shrouded in what Candace Vogler calls an “edifice of thought.” When confronted with uncertainty or a difficulty, we tended to revert to our strengths, which were our IQs and our thinking and talking skills. We sought to be masters of our life, rather than surrendering to emotions which are so much out of our control.</p><p><strong>我们忙着学业、看书、参加学生活动。我们自以为是地认为，我们才没空去建立什么交心的情感关系。我们几乎总是在靠近彼此时，裹着一层坎迪斯·沃格勒称之为“思维的虚假大厦”的东西。（注：芝大哲学教授，研究领域涉及伦理学，女性主义，社会政治哲学等等）当碰到不确定的情形或难关时，我们总爱借助于我们的强处，比如智商、思维能力、口才等。我们想成为自己生活的主宰者，而不是向我们几乎无法控制的情绪缴械投降。</strong></p><p>And the university didn’t help. The atmosphere at Chicago then was emotionally avoidant from the top down. Too much of life was defined by what could be discussed in the classroom, and everything else just fell by the wayside. There wasn’t enough dancing and drinking or any of the other activities that make diffidence possible. There wasn’t enough joint physical activity.</p><p>芝大在这件事上没有帮上忙。彼时的芝大氛围，从上到下都透着一股逃避情感话题的感觉。学习生活的主题是课堂上能讨论什么，其他事情都会半途而废。没有什么舞会、酒会或是任何其他让大家袒露真我的活动。当时也没什么太多联合的体育赛事。</p><p>Too much emphasis was put on scholarship and professionalism, and those things were defined by a pose of detachment, specialization, critical thinking, aloofness and a mythical belief in cool reasoning.</p><p><strong>当时更多的是强调学术表现和职业素养，而这两样又主要表现为情感抽离、专业化、批判性思维、冷眼旁观以及对冷静推理的迷之执着。</strong></p><p>Too much time was spent studying, which is solitary activity. Too much of student life was oriented around the Reg, and not because couples were fooling around in the stacks.</p><p>大部分时间都花在了学习上，基本上都是独来独往。过多的学生生活围绕着图书馆，但原因不是因为情侣们在书架的掩护下谈情说爱。</p><p>I left Chicago better at reading books than at reading people.</p><p><strong>我离开芝大时，读书的本事远胜读人。</strong></p><p>I did not have the eyes to see the beauty in people who were so open hearted that they had nothing particularly interesting to say. I didn’t know how to handle the deepest and scariest intimacies.</p><p><strong>我的眼睛看不到善良诚恳之人身上的美，因为我那时觉得他们没什么思想深度。我也不知道如何应对深刻却又让人生畏的亲密关系。</strong></p><p>I’m hoping I’m a little better. I’ve had some graduate tutors in this.</p><p>但愿我现在好一些了。观众席里有当时我的教学辅导。</p><p>Life will offer you a diminishing number of opportunities to show how smart you are. It will offer an infinite number of occasions that require kindness, mercy, grace, sensitivity, sympathy, generosity and love. Life will require that you widen your repertoire of emotions, that you throw yourself headlong into other people. That you take the curriculum of intimacy. If you haven’t mastered it yet, I ask you to turn to this task intentionally now.</p><p><strong>随着我们不断长大，生活中可以证明自己有多聪明的机会变得越来越少。但生活中有无数个场合需要善良、仁慈、优雅、敏锐、同情、慷慨和爱。生活需要你拓宽自己情绪的全部曲目，需要你径直去和他人打交道，需要你上一学期的亲密关系课。如果你还未掌握它，我希望你现在就开始刻意准备吧。</strong></p><p>So I’m asking one final thing of you members of the Class of 2017. Tomorrow you will graduate. And that is a great accomplishment. But before you do, I hope that tonight you will do one thing to cap your education. Go to the Regenstein with a special friend in your life. Find the spot deep in the stacks where Nietzsche’s “The Death of Tragedy” is found. But don’t open the book.</p><p>我最后还有一个希望，2017 届的同学们。明日你们即将毕业，这当然可喜可贺。但在明天到来之前，我希望今晚你能做一件锦上添花之事。和一位对你意义非凡的人一同去图书馆。在书堆的深处找到那本尼采的《悲剧的死亡》（此处有梗）。但是不要翻开它。</p><p>Take off some of your clothes and fool around.</p><p>褪去几件衣裳，邂逅美好时光</p><p>Thank you and God bless you.</p><p>谢谢，上帝保佑你们。</p>]]></content>
    
    
    <categories>
      
      <category>文艺</category>
      
      <category>演讲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摘抄</tag>
      
      <tag>思想</tag>
      
      <tag>英语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理</title>
    <link href="/2023/08/10/digital-image-processing/"/>
    <url>/2023/08/10/digital-image-processing/</url>
    
    <content type="html"><![CDATA[<p>在数字图像处理领域，本书作为主要教材已有 40 多年的历史。第四版是作者在前三版的基础上修订而成的，是前三版的发展与延续。除保留前几版的大部分内容外，根据读者的反馈，作者对本书进行了全面修订，融入了近几年来数字图像处理领域的重要进展，增加了几百幅新图像、几十个新图表和上百道新习题。全书共十二章，即绪论、数字图像基础、灰度变换与空间滤波、频率域滤波、图像复原与重建、小波变换和其他图像变换、彩色图像处理、图像压缩和水印、形态学图像处理、图像分割、特征提取、图像模式等。</p><p>本书的读者对象主要是从事信号与信息处理、通信工程、电子科学与技术、信息工程、自动化、计算机科学与技术、地球物理、生物工程、生物医学工程、物理、化学、医学、遥感等领域的大学教师和科技工作者、研究生、大学本科高年级学生及工程技术人员。</p><h2 id="第-1-章-绪论"><a href="#第-1-章-绪论" class="headerlink" title="第 1 章 绪论"></a>第 1 章 绪论</h2><h3 id="1-1-什么是数字图像处理"><a href="#1-1-什么是数字图像处理" class="headerlink" title="1.1 什么是数字图像处理"></a>1.1 什么是数字图像处理</h3><p>一幅图像可以定义为一个二维函数 $f(x, y)$，其中 $x$ 和 $y$ 是空间（平面）坐标，任一一对空间坐标 $(x, y)$ 处的幅值 $f$ 称为图像在该点的<code>强度</code>或<code>灰度</code>。当 $x$，$y$ 和灰度值 $f$ 都是有限的离散量时，我们称该图像为<code>数字图像</code>。<code>数字图像处理</code>是指借助于数字计算机来处理数字图像。注意，数字图像由有限数量的元素组成，每个元素都有一个特定的位置和数值。这些元素称为<code>图画元素</code>、<code>图像元素</code>或<code>像素</code>。</p><p>考虑三种类型的计算机图像处理：</p><ul><li>低级处理：初级图像操作，涉及降噪、对比度增强和图像锐化等。</li><li>中级处理：涉及诸多任务，如图像分割、提取特征（如边缘、轮廓和各个目标的识别）。</li><li>高级处理：涉及“理解”目标，以及执行与人类视觉相关的认识功能。</li></ul><p>本书将<code>数字图像处理</code>界定为输入和输出都是图像的处理，它包含从图像种提取特征的处理，甚至包含各个目标的识别。举例：如文本自动分析。</p><h3 id="1-2-数字图像处理的起源"><a href="#1-2-数字图像处理的起源" class="headerlink" title="1.2 数字图像处理的起源"></a>1.2 数字图像处理的起源</h3><p>数字图像处理的历史与数字计算机的发展密切相关。事实上，数字图像处理要求巨大的储存和计算能力，数字图像处理领域的发展一直依赖于数字计算机及数据存储、显示和传输等支撑技术的发展。</p><h3 id="1-3-数字图像处理技术应用领域实例"><a href="#1-3-数字图像处理技术应用领域实例" class="headerlink" title="1.3 数字图像处理技术应用领域实例"></a>1.3 数字图像处理技术应用领域实例</h3><p>基于电磁波谱辐射的成像：</p><ul><li>伽马射线成像：核医学和天文观测。</li><li>X 射线成像：医学诊断，工业成像，天文学。</li><li>紫外波段成像：平板印刷术、工业检测、显微方法、激光、生物成像、天文观测。</li><li>可见光和红外波段成像：光显微方法、天文学、遥感、工业和执法。</li><li>微波波段成像：雷达，不受天气、光照条件影响。</li><li>无线电波段成像：医学和天文学。</li><li>其他方式成像：声波成像（B超）、电子显微方法、合成成像（分形）。</li></ul><h3 id="1-4-数字图像处理的基本步骤"><a href="#1-4-数字图像处理的基本步骤" class="headerlink" title="1.4 数字图像处理的基本步骤"></a>1.4 数字图像处理的基本步骤</h3><p><img src="/images/digital-image-processing/P1_23.png" alt=" "></p><h3 id="1-5-图像处理系统的组成"><a href="#1-5-图像处理系统的组成" class="headerlink" title="1.5 图像处理系统的组成"></a>1.5 图像处理系统的组成</h3><p><img src="/images/digital-image-processing/P1_24.png" alt=" "></p><h2 id="第-2-章-数字图像基础"><a href="#第-2-章-数字图像基础" class="headerlink" title="第 2 章 数字图像基础"></a>第 2 章 数字图像基础</h2><h3 id="2-1-视觉感知要素"><a href="#2-1-视觉感知要素" class="headerlink" title="2.1 视觉感知要素"></a>2.1 视觉感知要素</h3><h4 id="2-1-1-人眼的结构"><a href="#2-1-1-人眼的结构" class="headerlink" title="2.1.1 人眼的结构"></a>2.1.1 人眼的结构</h4><p><img src="/images/digital-image-processing/P2_1.png" alt=" "></p><p><strong>角膜</strong>是坚硬并且透明的组织，覆盖在人眼的前表面。<br><strong>巩膜</strong>是包围眼球其余部分的不透明膜。<br><strong>脉络膜</strong>中含有血管网，它是眼睛的主要营养来源。<br><strong>虹膜</strong>的收缩和扩张控制进入人眼的光量。<br><strong>晶状体</strong>吸收约 8% 的可见光谱，对短波长的光有较高的吸收率。<br><strong>视网膜</strong>布满整个后部的内壁。眼睛聚焦时，来自物体的光在视网膜上成像。其上分布有对颜色高度敏感的锥状体和对低光照敏感的杆状体。</p><p><img src="/images/digital-image-processing/P2_2.png" alt=" "></p><h4 id="2-1-2-人眼中图像的成像"><a href="#2-1-2-人眼中图像的成像" class="headerlink" title="2.1.2 人眼中图像的成像"></a>2.1.2 人眼中图像的成像</h4><p>在普通照相机中，镜头的焦距是固定的。不同距离的聚焦是通过改变镜头和成像平面之间的距离来实现的，胶片（或数码相机的成像芯片）放在成像平面上。在人眼中，情况与此相反；晶状体和成像区域（视网膜）之间的距离是固定的，正确聚焦的焦距是通过改变晶状体的形状得到的。在远离或接近目标时，睫状体中的纤维通过分别压扁或加厚晶状体来实现聚焦。</p><p><img src="/images/digital-image-processing/P2_3.png" alt=" "></p><h4 id="2-1-3-亮度适应与辨别"><a href="#2-1-3-亮度适应与辨别" class="headerlink" title="2.1.3 亮度适应与辨别"></a>2.1.3 亮度适应与辨别</h4><p>人类视觉系统能够适应的光强邓建的范围很宽——从暗阈值到强光约有 $10^{10}$ 级别。实验数据表明，主观亮度（即人类视觉系统感知的亮度）是进入人眼的光强的对数函数。</p><p>现象一：视觉系统往往会在不同灰度区域的边界处出现“下冲”或“上冲”现象，典型如<code>马赫带效应</code>。</p><p><img src="/images/digital-image-processing/P2_7.png" alt=" "></p><p>现象二：<code>同时对比</code>，即一个区域的感知亮度不只取决于其灰度，还与其周边环境的灰度相关。</p><p><img src="/images/digital-image-processing/P2_8.png" alt=" "></p><p>现象三：<code>光学错视</code>，即人眼中充斥这不存在的信息或错误地感知了物体的几何特点。</p><p><img src="/images/digital-image-processing/P2_9.png" alt=" "></p><h3 id="2-2-光和电磁波"><a href="#2-2-光和电磁波" class="headerlink" title="2.2 光和电磁波"></a>2.2 光和电磁波</h3><p>电磁波谱可用波长、频率或能量来表示。波长（$\lambda$）和频率（$v$）的关系为：$\lambda &#x3D; c &#x2F; v$；式中 $c$ 是光速。</p><p>电磁波谱个分量的能量为 $E &#x3D; hv$；式中 $h$ 是普朗克常数。常用能量单位是电子伏特。</p><p>电磁波可视为以波长 $\lambda$ 传播的正弦波，或视为没有质量的粒子流，每个粒子像波浪一样行进并以光速运动。每个无质量的粒子都是具有一定（一束）能量的粒子，称为<code>光子</code>。</p><p>光是一种电磁辐射，它可以被人眼感知。电磁波谱可见光波段范围是 0.43 um（紫色）~ 0.79 um（红色）。</p><p>感知的物体颜色由物体反射的光的性质决定。相对平衡地以所有可见光波长反射光的物体，在观察者看来呈现白色。</p><p>没有颜色的光称为<code>单色光</code>或<code>无色光</code>。单色光的唯一属性是亮度。单色光从黑到白的数值范围通常称为<code>灰度级</code>，而单色图像常称为<code>灰度图像</code>。</p><p>对于彩色光，除了频率外，我们还用三个其他量来描述彩色光源：辐射、光通量和亮度。<code>辐射</code>是从光源流出的总能量，通常用瓦特（W）来度量。<code>光通量</code>是观察者从光源感知的能量，但通常用流明（lm）来度量。<code>亮度</code>是光感知的主观描绘子，它实际上不能度量，体现的是强度的无色概念，是描述色彩感觉的关键因素之一。</p><p>原理上，如果能够开发传感器来检测由一个电磁波谱波段发射的能量，那么 就能在该波段上对感兴趣的事件成像。</p><h3 id="2-3-图像感知与获取"><a href="#2-3-图像感知与获取" class="headerlink" title="2.3 图像感知与获取"></a>2.3 图像感知与获取</h3><p><img src="/images/digital-image-processing/P2_12.png" alt=" "></p><p>我们感兴趣的大多数图像，都是由“照射”源和形成图像的“场景”元素对光能的反射和吸收产生的。对“照射”和“场景”加引号的目的，是强调它们要比我们熟悉的可见光源照射三维场景的情况更为普遍。例如，照射可能来自电磁能量源，如雷达、红外线或 X 射线系统。也可能来自非传统光源（如超声波），甚至来自计算机产生的照射模式。</p><h4 id="2-3-1-使用单个传感器获取图像"><a href="#2-3-1-使用单个传感器获取图像" class="headerlink" title="2.3.1 使用单个传感器获取图像"></a>2.3.1 使用单个传感器获取图像</h4><p><img src="/images/digital-image-processing/P2_13.png" alt=" "></p><h4 id="2-3-2-使用条带传感器获取图像"><a href="#2-3-2-使用条带传感器获取图像" class="headerlink" title="2.3.2 使用条带传感器获取图像"></a>2.3.2 使用条带传感器获取图像</h4><p><img src="/images/digital-image-processing/P2_14.png" alt=" "></p><ul><li>安装有成像条带传感器的飞行器以恒定高度和速度飞过待成像区域，对地面进行成像。</li><li>医学和工业成像使用环形条带传感器获取三维物体的剖面（“切片”）图像。</li></ul><h4 id="2-3-3-使用阵列传感器获取图像"><a href="#2-3-3-使用阵列传感器获取图像" class="headerlink" title="2.3.3 使用阵列传感器获取图像"></a>2.3.3 使用阵列传感器获取图像</h4><p><img src="/images/digital-image-processing/P2_15.png" alt=" "></p><p>优点是将能量聚焦到阵列表面就可得到一幅完整的图像，不需要传感器排列的运动。典型如数字摄像机的典型传感器 CCD（电荷耦合器件）阵列。</p><h4 id="2-3-4-一个简单的成像模型"><a href="#2-3-4-一个简单的成像模型" class="headerlink" title="2.3.4 一个简单的成像模型"></a>2.3.4 一个简单的成像模型</h4><p>我们用形如 $f(x,y)$ 的二维函数来表示图像。在空间坐标 $(x,y)$ 处 $f$ 的值是一个标量，其物理异议由图像源决定，其值与物理源（如电磁波）辐射的能量成正比。因此 $f(x,y)$ 一定是非负的和有限的，即 $0 \leq f(x,y) &lt; \infty$ 。</p><p>函数 $f(x,y)$ 由两个分量表征：（1）入射到被观察场景的光源照射量；（2）被场景中物体反射的照射量。它们分别称为<code>入射分量</code>和<code>反射分量</code>，并分别用 $i(x,y)$ 和 $r(x,y)$ 表示。这两个函数的乘积形成 $f(x,y)$，即 $f(x,y)&#x3D;i(x,y)r(x,y)$，式中，$0 \leq i(x,y) &lt; \infty$ 且 $0 \leq r(x,y) \leq 1$。</p><p>于是，反射分量限制在 0（全吸收）和 1（全反射）之间。$i(x,y)$ 的性质取决于照射源，而 $r(x,y)$ 的性质取决于被成像物体的特性。这些表达式也适用于投射成像的情况，如胸透 X 射线。这时，要用透射系数代替反射函数。</p><h3 id="2-4-图像取样和量化"><a href="#2-4-图像取样和量化" class="headerlink" title="2.4 图像取样和量化"></a>2.4 图像取样和量化</h3>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
      <tag>算法</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 模板</title>
    <link href="/2023/08/09/cpp-template/"/>
    <url>/2023/08/09/cpp-template/</url>
    
    <content type="html"><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch00/" title="">前言</a></h4><h3 id="第-1-部分-基础概念"><a href="#第-1-部分-基础概念" class="headerlink" title="第 1 部分 基础概念"></a>第 1 部分 基础概念</h3><hr><p>本部分将会介绍 C++ 模板的一些基础概念和语言特性。将会通过函数模板和类模板的例子来讨论模板的目的和概念。然后会继续介绍一些其他的模板特性，比如非类型模板参数（nontype template parameters），变参模板（variadic templates），typename 关键字和成员模板（member templates）。也会讨论如何处理移动语义（move semantics），如何声明模板参数，以及如何使用泛型代码实现可以在编译阶段执行的程序（compile-time programming）。在结尾处我们会针对一些术语和模板在实际中的应用，给应用开发工程师和泛型库的开发者们提供一些建议。</p><p><strong>为什么要使用模板？</strong></p><p>C++ 要求我们要用特定的类型来声明变量，函数以及其他一些内容。这样很多代码可能就只是处理的变量类型有所不同。比如对不同的数据类型，快速排序的算法实现在结构上可能完全一样，不管是对整型的数组，还是字符串类型的向量（vector），只要他们所包含的内容之间可以相互比较。</p><p>如果你所使用的语言不支持这一泛型特性，你将可能只有如下糟糕的选择：</p><ol><li>你可以对不同的类型一遍又一遍的实现相同的算法。</li><li>你可以在某一个公共基类（common base type， 比如 Object 和 void*）里面实现通用的算法代码。</li><li>你也可以使用特殊的预处理方法。</li></ol><p>如果你是从其它语言转向 C++，你可能已经使用过以上几种或全部的方法了。然而他们都各有各的缺点：</p><ol><li>如果你一遍又一遍地实现相同算法，你就是在重复地制造轮子！你会犯相同的错误，而且为了避免犯更多的错误，你也不会倾向于使用复杂但是很高效的算法。</li><li>如果在公共基类里实现统一的代码，就等于放弃了类型检查的好处。而且，有时候某些类必须要从某些特殊的基类派生出来，这会进一步增加维护代码的复杂度。</li><li>如果采用预处理的方式，你需要实现一些“愚蠢的文本替换机制”，这将很难兼顾作用域和类型检查，因此也就更容易引发奇怪的语义错误。</li></ol><p>而模板这一方案就不会有这些问题。模板是为了一种或者多种未明确定义的类型而定义的函数或者类。在使用模板时，需要显式地或者隐式地指定模板参数。由于模板是 C++ 的语言特性，类型和作用域检查将依然得到支持。</p><p>目前模板正在被广泛使用。比如在 C++ 标准库中，几乎所有的代码都用到了模板。标准库提供了一些排序算法来排序某种特定类型的值或者对象，也提供类一些数据结构（亦称容器）来维护某种特定类型的元素，对于字符串而言，这一“特定类型”指的就是“字符”。当然这只是最基础的功能。模板还允许我们参数化函数或者类的行为，优化代码以及参数化其他信息。这些高级特性会在后面某些章节介绍，我们接下来将先从一些简单模板开始介绍。</p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch01/" title="">第 1 章 函数模板</a></h4><h4 id="-2"><a href="#-2" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch02/" title="">第 2 章 类模板</a></h4><h4 id="-3"><a href="#-3" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch03/" title="">第 3 章 非类型模板参数</a></h4><h4 id="-4"><a href="#-4" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch04/" title="">第 4 章 可变参数模板</a></h4><h4 id="-5"><a href="#-5" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch05/" title="">第 5 章 基础技术</a></h4><h4 id="-6"><a href="#-6" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch06/" title="第 6 章 移动语义与 enable_if()">第 6 章 移动语义与 enable_if()</a></h4><h4 id="-7"><a href="#-7" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch07/" title="">第 7 章 按值传递还是按引用传递？</a></h4><h4 id="-8"><a href="#-8" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch08/" title="">第 8 章 编译期编程</a></h4><h4 id="-9"><a href="#-9" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch09/" title="">第 9 章 在实战中使用模板</a></h4><h4 id="-10"><a href="#-10" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch10/" title="">第 10 章 基础模板术语</a></h4><h4 id="-11"><a href="#-11" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch11/" title="">第 11 章 泛型库</a></h4><h3 id="第-2-部分-深入模板"><a href="#第-2-部分-深入模板" class="headerlink" title="第 2 部分 深入模板"></a>第 2 部分 深入模板</h3><hr><p>本书的第一部分提供了基于 C++ 模板的大部分语法概念的解读，这足以对日常 C++ 编程所能遇到的问题进行解答。本书的第二部分提供了一个参考，旨在回答在推动语言发展过程中实现某些高级软件效果时遇到的更不寻常的问题。如果需要，您可以在初读时跳过此部分，并根据后面各章中的引用提示或在索引中查找某个概念时返回特定主题。</p><p>我们的目标是在清楚和完整的前提下，保持讨论的简洁性。为此，示例都很简短，通常也有些虚假。这也确保了我们不会错开手头的话题而陷入到无关的议题中。</p><p>此外，我们还前瞻了 C++ 模板语言特性未来的变化与扩展。这一部分的议题包含以下内容：</p><ul><li>基础模板声明议题</li><li>模板中名称的意义</li><li>C++ 模板实例化机制</li><li>模板参数推导规则</li><li>特化与重载</li><li>未来的可能性</li></ul><h4 id="-12"><a href="#-12" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch12/" title="">第 12 章 深入模板基础</a></h4><h4 id="-13"><a href="#-13" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch13/" title="">第 13 章 模板中的名称</a></h4><h4 id="-14"><a href="#-14" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch14/" title="">第 14 章 实例化</a></h4><h4 id="-15"><a href="#-15" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch15/" title="">第 15 章 模板实参推导</a></h4><h4 id="-16"><a href="#-16" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch16/" title="">第 16 章 特化和重载</a></h4><h4 id="-17"><a href="#-17" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch17/" title="">第 17 章 未来发展方向</a></h4><h3 id="第-3-部分-模板和设计"><a href="#第-3-部分-模板和设计" class="headerlink" title="第 3 部分 模板和设计"></a>第 3 部分 模板和设计</h3><hr><h4 id="-18"><a href="#-18" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch18/" title="">第 18 章 模板的多态性</a></h4><h4 id="-19"><a href="#-19" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch19/" title="">第 19 章 Trait 的实现</a></h4><h4 id="-20"><a href="#-20" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch20/" title="">第 20 章 类型属性上的重载</a></h4><h4 id="-21"><a href="#-21" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch21/" title="">第 21 章 模板和继承</a></h4><h4 id="-22"><a href="#-22" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch22/" title="">第 22 章 桥接静态和动态多态性</a></h4><h4 id="-23"><a href="#-23" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch23/" title="">第 23 章 元编程</a></h4><h4 id="-24"><a href="#-24" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch24/" title="">第 24 章 类型列表</a></h4><h4 id="-25"><a href="#-25" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch25/" title="">第 25 章 元组</a></h4><h4 id="-26"><a href="#-26" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch26/" title="">第 26 章 可识别的联合</a></h4><h4 id="-27"><a href="#-27" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch27/" title="">第 27 章 表达式模板</a></h4><h4 id="-28"><a href="#-28" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch28/" title="">第 28 章 调试模板</a></h4><h4 id="-29"><a href="#-29" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch29/" title="">附录</a></h4><h4 id="-30"><a href="#-30" class="headerlink" title=""></a><a href="/2025/05/31/cpp-template-ch/cpp-template-ch30/" title="">参考文献</a></h4>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>特性</tag>
      
      <tag>语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Modern C++</title>
    <link href="/2023/08/08/effective-modern-cpp/"/>
    <url>/2023/08/08/effective-modern-cpp/</url>
    
    <content type="html"><![CDATA[<p>一份宏大的作品，能够带动一个领域的蓬勃发展。C++ 社群在相对沉寂数十年之后迎来新一波浪潮，原因是，作为一门编程工具的最核心，C++ 的语言和标准库都出现巨大的拓展和强化。这一番大变革始自 2011，并分别于 2014、2017 持续进化。业界习惯性地将这些新版本统称为 Modern C++，用以区别“传统” C++。</p><p>作为知名书系的最新作品，《Effective Modern C++》的佳质和佳评一如其早期同门作品《Effective C++》和《More Effective C++》。本书延续作者 Scott Meyers 的一贯风格和质量，其最大特质就是，不但告诉我们 How，更用巨大而精良的篇幅告诉我们 Why。作者穷追猛打讲究再三的劲儿，常让我筋疲力尽，痛并快乐地爬行于某个条款之际拍案而叹：“天哪，还有下一页！”</p><p>而我，是一个在 C++ 领域已经生活了 25 年的老兵。</p><p>是的，我是一个在 C++ 领域已经生活了 25 年的老兵，这意味着我具备相当的 C++ 能力。尽管如此，面对号称全新语言的 Modern C++，我时或也有力不能逮、掩卷长叹的焦躁，特别是面对 Rvalue Reference（右值引用）、Perfect Forwarding（完美转发）、Metaprogramming（元编程）、Type Deduction（类型推导）、Type Traits（型别特征）等艰涩主题的时候。然而正是在特别艰涩的主题上你可以领受本书的巨大价值：如果你想完善根基，本书是你唯一的选择。</p><p>———— 侯捷推荐序</p><h2 id="第-1-章-型别推导"><a href="#第-1-章-型别推导" class="headerlink" title="第 1 章 型别推导"></a>第 1 章 型别推导</h2><p>C++98 仅有一套型别推导规则，用于函数模板。C++11 对这套规则进行了一些改动，并且增加了两套规则，一套用于 <code>auto</code>，另一套用于 <code>decltype</code>。后来，C++14 又扩展了能够运用 <code>auto</code> 和 <code>decltype</code> 的语境。型别推导应用范围的不断普及，使得人们不必再去写下那些不言自明或是完全冗余的型别。它还让 C++ 软件获得更高的适应性，因为在源代码的一个地方对一个型别实施的改动，可以自动通过型别推导传播到其他地方。然而，它也有可能导致写出来的代码较难看懂，因为编译器推导出的型别，可能不像我们所认为的那样显而易见。</p><p>想要使用现代 C++ 高效编程，就离不开对于型别推导操作的坚实理解。型别推导涉及的语境实在不胜枚举：在函数模板的调用中，在 <code>auto</code> 现身的大多数场景中，在 <code>decltype</code> 表达式中，特别是在 C++14 中那个神秘莫测的 <code>decltype(auto)</code> 结构中。</p><p>本章讨论的是每个 C++ 开发工程师都需要了解的有关型别推导的知识。本章解释了模板型别推导如何运作，<code>auto</code> 的型别推导如何构建在此运作规则之上，以及 <code>decltype</code> 独特的型别推导规则。本章还教你如何迫使编译器来展示其型别推导的结果，从而让你确信该结果如你所愿。</p><h3 id="条款-1-理解模板型别推导"><a href="#条款-1-理解模板型别推导" class="headerlink" title="条款 1 理解模板型别推导"></a>条款 1 理解模板型别推导</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(ParamType param)</span></span>;<br><br><span class="hljs-built_in">f</span>(expr);  <span class="hljs-comment">// 从 expr 来推导 T 和 ParamType 的型别</span><br></code></pre></td></tr></table></figure><p>在编译期，编译器会通过 <code>expr</code> 推导两个型别：一个是 <code>T</code> 的型别，另一个是 <code>ParamType</code> 的型别，这两个型别往往不一样。因为，<code>ParamType</code> 常会包含了一些饰词，如 <code>const</code> 或引用符号等限定词。</p><p>我们很自然地会认为，<code>T</code> 的型别推导结果和传递给函数的实参型别是同一的。但是，这一点并不总是成立。<code>T</code> 的型别推导结果，不仅仅依赖 <code>expr</code> 的型别，还依赖 <code>ParamType</code> 的形式。具体要分三种情况讨论：</p><h4 id="情况-1：ParamType-是个指针或引用，但不是个万能指针"><a href="#情况-1：ParamType-是个指针或引用，但不是个万能指针" class="headerlink" title="情况 1：ParamType 是个指针或引用，但不是个万能指针"></a>情况 1：ParamType 是个指针或引用，但不是个万能指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;  <span class="hljs-comment">// param 是个引用</span><br><br>      <span class="hljs-type">int</span>   x = <span class="hljs-number">27</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>  cx = x;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br><span class="hljs-built_in">f</span>(x);   <span class="hljs-comment">// T 的型别是       int，param 的型别是 int&amp;</span><br><span class="hljs-built_in">f</span>(cx);  <span class="hljs-comment">// T 的型别是 const int，param 的型别是 const int&amp;</span><br><span class="hljs-built_in">f</span>(rx);  <span class="hljs-comment">// T 的型别是 const int，param 的型别是 const int&amp;</span><br></code></pre></td></tr></table></figure><p><code>cx</code> 和 <code>rx</code> 的示例中，<code>T</code> 被推导为 <code>const int</code>，说明对象的常量性会成为 <code>T</code> 的型别推导结果的组成部分。</p><p><code>rx</code> 具有引用型别，但 <code>T</code> 并未被推导成一个引用。原因在于，<code>rx</code> 的引用性会在型别推导过程中被忽略。</p><p>对于 <code>param</code> 型别改成 <code>const T&amp;</code>，由千我们现在会假定 <code>param</code> 具有 <code>const</code> 引用型别，<code>T</code> 的型别推导结果中包含 <code>const</code> 也就没有必要了。</p><p>如果 <code>param</code> 是个指针（或指涉到 <code>const</code> 对象的指针）而非引用， 运作方式本质上并无不同。</p><h4 id="情况-2：ParamType-是个万能引用"><a href="#情况-2：ParamType-是个万能引用" class="headerlink" title="情况 2：ParamType 是个万能引用"></a>情况 2：ParamType 是个万能引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span></span>;  <span class="hljs-comment">// param 现在是个万能引用</span><br><br>      <span class="hljs-type">int</span>   x = <span class="hljs-number">27</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>  cx = x;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br><span class="hljs-built_in">f</span>(x);   <span class="hljs-comment">//  x 是个左值，T 的型别是       int&amp;，param 的型别是 int&amp;</span><br><span class="hljs-built_in">f</span>(cx);  <span class="hljs-comment">// cx 是个左值，T 的型别是 const int&amp;，param 的型别是 const int&amp;</span><br><span class="hljs-built_in">f</span>(rx);  <span class="hljs-comment">// rx 是个左值，T 的型别是 const int&amp;，param 的型别是 const int&amp;</span><br><span class="hljs-built_in">f</span>(<span class="hljs-number">27</span>);  <span class="hljs-comment">// 27 是个右值，T 的型别是       int ，param 的型别是 int&amp;&amp;</span><br></code></pre></td></tr></table></figure><ul><li>如果 <code>expr</code> 是个左值，<code>T</code> 和 <code>ParamType</code> 都会被推到为左值引用。这个结果具有双重的奇特之处：首先，这是在模板型别推导中，<code>T</code> 被推导为引用型别的唯一情形。其次，尽管在声明时使用的是右值引用语法，它的型别推导结果却是左值引用。</li><li>如果 <code>expr</code> 是个右值，则应用“常规”（即情况 1 中的）规则。</li></ul><p><a href="#">条款 24</a> 详尽解释了为何上述例子会产生这样的结果。关键之处在于，万能引用形参的型别推导规则不同于左值引用和右值引用形参。具体地，当遇到万能引用时，型别推导规则会区分实参是左值还是右值。而非万能引用是从来不会作这样的区分的。</p><h4 id="情况-3：ParamType-既非指针也非引用"><a href="#情况-3：ParamType-既非指针也非引用" class="headerlink" title="情况 3：ParamType 既非指针也非引用"></a>情况 3：ParamType 既非指针也非引用</h4><h4 id="数组实参"><a href="#数组实参" class="headerlink" title="数组实参"></a>数组实参</h4><h4 id="函数实参"><a href="#函数实参" class="headerlink" title="函数实参"></a>函数实参</h4><div class="note note-success">            <p><strong>要点速记</strong></p><ul><li>在模板型别推导过程中，具有引用型别的实参会被当成非引用型别来处理。换言之，其引用性会被忽略。</li><li>对万能引用形参进行推导时，左值实参会进行特殊处理。</li><li>对按值传递的形参进行推导时，若实参型别中带有 <code>const</code> 或 <code>volatile</code> 饰词，则它们还是会被当作不带 <code>const</code> 或 <code>volatile</code> 饰词的型别来处理。</li><li>在模板型别推导过程中，数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用。</li></ul>          </div><h2 id="第-2-章-auto"><a href="#第-2-章-auto" class="headerlink" title="第 2 章 auto"></a>第 2 章 auto</h2><h2 id="第-3-章-转向现代-C"><a href="#第-3-章-转向现代-C" class="headerlink" title="第 3 章 转向现代 C++"></a>第 3 章 转向现代 C++</h2><h2 id="第-4-章-智能指针"><a href="#第-4-章-智能指针" class="headerlink" title="第 4 章 智能指针"></a>第 4 章 智能指针</h2><h2 id="第-5-章-右值引用、移动语义和完美转发"><a href="#第-5-章-右值引用、移动语义和完美转发" class="headerlink" title="第 5 章 右值引用、移动语义和完美转发"></a>第 5 章 右值引用、移动语义和完美转发</h2><h2 id="第-6-章-Lambda-表达式"><a href="#第-6-章-Lambda-表达式" class="headerlink" title="第 6 章 Lambda 表达式"></a>第 6 章 Lambda 表达式</h2><h2 id="第-7-章-并发-API"><a href="#第-7-章-并发-API" class="headerlink" title="第 7 章 并发 API"></a>第 7 章 并发 API</h2><h2 id="第-8-章-微调"><a href="#第-8-章-微调" class="headerlink" title="第 8 章 微调"></a>第 8 章 微调</h2>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>经验</tag>
      
      <tag>准则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective STL</title>
    <link href="/2023/08/07/effective-stl/"/>
    <url>/2023/08/07/effective-stl/</url>
    
    <content type="html"><![CDATA[<p>本书是 Effective C++ 的第 3 卷，被评为“值得所有 C++ 程序员阅读的 C++ 书籍之一”。本书详细讲述了使用 STL 的 50 条指导原则，并提供了透彻的分析和深刻的实例，实用性极强，是 C++ 程序员必备的基础书籍。C++ 的标准模板库（STL）是革命性的，要用好 STL 并不容易。本书作者 Scott Meyers 揭示了专家总结的一些关键规则，包括专家们总是采用的做法，以及专家们总是避免的做法。通过这些规则，STL 程序员可以最大限度地使用 STL。</p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>经验</tag>
      
      <tag>准则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>More Effective C++</title>
    <link href="/2023/08/06/more-effective-cpp/"/>
    <url>/2023/08/06/more-effective-cpp/</url>
    
    <content type="html"><![CDATA[<p>继 Effective C++ 之后，Scott Meyers 于 1996 年推出这本“续集”。条款变得比较少，页数倒是多了一些，原因是这次选材比“第一集”更高阶。尤其是第 5 章。Meyers 将此章命名为技术（techniques），并明白告诉你，其中都是一些 patterns（模式），例如 virtual contructors（虚构造函数），smart pointers（智能指针），reference counting（引用计数），proxy classes（策略类），double dispatching（双重派发）……这一章的每个条款篇幅都长达 15~30 页之多，实在让人有“山重水复疑无路，柳暗花明又一村”之叹。</p><span id="more"></span><h2 id="基础议题"><a href="#基础议题" class="headerlink" title="基础议题"></a>基础议题</h2><h3 id="条款-1：仔细区分指针和引用"><a href="#条款-1：仔细区分指针和引用" class="headerlink" title="条款 1：仔细区分指针和引用"></a>条款 1：仔细区分指针和引用</h3><h3 id="条款-2：最好使用-C-转型操作符"><a href="#条款-2：最好使用-C-转型操作符" class="headerlink" title="条款 2：最好使用 C++ 转型操作符"></a>条款 2：最好使用 C++ 转型操作符</h3><h3 id="条款-3：绝对不要以多态反诗处理数组"><a href="#条款-3：绝对不要以多态反诗处理数组" class="headerlink" title="条款 3：绝对不要以多态反诗处理数组"></a>条款 3：绝对不要以多态反诗处理数组</h3><h3 id="条款-4：非必要不提供默认构造函数"><a href="#条款-4：非必要不提供默认构造函数" class="headerlink" title="条款 4：非必要不提供默认构造函数"></a>条款 4：非必要不提供默认构造函数</h3><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="条款-5：对定制的“类型转换函数”保持警觉"><a href="#条款-5：对定制的“类型转换函数”保持警觉" class="headerlink" title="条款 5：对定制的“类型转换函数”保持警觉"></a>条款 5：对定制的“类型转换函数”保持警觉</h3><h3 id="条款-6：区分自增-自减操作符的前置和后置形式"><a href="#条款-6：区分自增-自减操作符的前置和后置形式" class="headerlink" title="条款 6：区分自增&#x2F;自减操作符的前置和后置形式"></a>条款 6：区分自增&#x2F;自减操作符的前置和后置形式</h3><h3 id="条款-7：千万不要重载-，-和-操作符"><a href="#条款-7：千万不要重载-，-和-操作符" class="headerlink" title="条款 7：千万不要重载 &amp;&amp;，|| 和 , 操作符"></a>条款 7：千万不要重载 &amp;&amp;，|| 和 , 操作符</h3><h3 id="条款-8：了解各种不同意义的-new-和-delete"><a href="#条款-8：了解各种不同意义的-new-和-delete" class="headerlink" title="条款 8：了解各种不同意义的 new 和 delete"></a>条款 8：了解各种不同意义的 new 和 delete</h3><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="条款-9：利用析构函数避免资源泄露"><a href="#条款-9：利用析构函数避免资源泄露" class="headerlink" title="条款 9：利用析构函数避免资源泄露"></a>条款 9：利用析构函数避免资源泄露</h3><h3 id="条款-10：在构造函数内阻止资源泄露"><a href="#条款-10：在构造函数内阻止资源泄露" class="headerlink" title="条款 10：在构造函数内阻止资源泄露"></a>条款 10：在构造函数内阻止资源泄露</h3><h3 id="条款-11：禁止异常流出析构函数之外"><a href="#条款-11：禁止异常流出析构函数之外" class="headerlink" title="条款 11：禁止异常流出析构函数之外"></a>条款 11：禁止异常流出析构函数之外</h3><h3 id="条款-12：了解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”之间的差异"><a href="#条款-12：了解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”之间的差异" class="headerlink" title="条款 12：了解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”之间的差异"></a>条款 12：了解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”之间的差异</h3><h3 id="条款-13：以传引用的方式捕获异常"><a href="#条款-13：以传引用的方式捕获异常" class="headerlink" title="条款 13：以传引用的方式捕获异常"></a>条款 13：以传引用的方式捕获异常</h3><h3 id="条款-14：明智运用异常规约"><a href="#条款-14：明智运用异常规约" class="headerlink" title="条款 14：明智运用异常规约"></a>条款 14：明智运用异常规约</h3><h3 id="条款-15：了解异常处理的成本"><a href="#条款-15：了解异常处理的成本" class="headerlink" title="条款 15：了解异常处理的成本"></a>条款 15：了解异常处理的成本</h3><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><h3 id="条款-16：谨记-80-20-法则"><a href="#条款-16：谨记-80-20-法则" class="headerlink" title="条款 16：谨记 80-20 法则"></a>条款 16：谨记 80-20 法则</h3><h3 id="条款-17：考虑使用惰性求值"><a href="#条款-17：考虑使用惰性求值" class="headerlink" title="条款 17：考虑使用惰性求值"></a>条款 17：考虑使用惰性求值</h3><h3 id="条款-18：分期摊还预期的计算成本"><a href="#条款-18：分期摊还预期的计算成本" class="headerlink" title="条款 18：分期摊还预期的计算成本"></a>条款 18：分期摊还预期的计算成本</h3><h3 id="条款-19：了解临时对象的来源"><a href="#条款-19：了解临时对象的来源" class="headerlink" title="条款 19：了解临时对象的来源"></a>条款 19：了解临时对象的来源</h3><h3 id="条款-20：协助完成“返回值优化”"><a href="#条款-20：协助完成“返回值优化”" class="headerlink" title="条款 20：协助完成“返回值优化”"></a>条款 20：协助完成“返回值优化”</h3><h3 id="条款-21：利用重载技术避免隐式类型转换"><a href="#条款-21：利用重载技术避免隐式类型转换" class="headerlink" title="条款 21：利用重载技术避免隐式类型转换"></a>条款 21：利用重载技术避免隐式类型转换</h3><h3 id="条款-22：考虑以操作符复合形式取代其独身形式"><a href="#条款-22：考虑以操作符复合形式取代其独身形式" class="headerlink" title="条款 22：考虑以操作符复合形式取代其独身形式"></a>条款 22：考虑以操作符复合形式取代其独身形式</h3><h3 id="条款-23：考虑使用其他程序库"><a href="#条款-23：考虑使用其他程序库" class="headerlink" title="条款 23：考虑使用其他程序库"></a>条款 23：考虑使用其他程序库</h3><h3 id="条款-24：了解虚函数、多继承、虚基类、RTTI-的成本"><a href="#条款-24：了解虚函数、多继承、虚基类、RTTI-的成本" class="headerlink" title="条款 24：了解虚函数、多继承、虚基类、RTTI 的成本"></a>条款 24：了解虚函数、多继承、虚基类、RTTI 的成本</h3><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="条款-25：将构造函数和非成员函数虚化"><a href="#条款-25：将构造函数和非成员函数虚化" class="headerlink" title="条款 25：将构造函数和非成员函数虚化"></a>条款 25：将构造函数和非成员函数虚化</h3><h3 id="条款-26：限制某个类所能产生的对象数量"><a href="#条款-26：限制某个类所能产生的对象数量" class="headerlink" title="条款 26：限制某个类所能产生的对象数量"></a>条款 26：限制某个类所能产生的对象数量</h3><h3 id="条款-27：要求（或禁止）对象产生于堆之中"><a href="#条款-27：要求（或禁止）对象产生于堆之中" class="headerlink" title="条款 27：要求（或禁止）对象产生于堆之中"></a>条款 27：要求（或禁止）对象产生于堆之中</h3><h3 id="条款-28：智能指针"><a href="#条款-28：智能指针" class="headerlink" title="条款 28：智能指针"></a>条款 28：智能指针</h3><h3 id="条款-29：引用计数"><a href="#条款-29：引用计数" class="headerlink" title="条款 29：引用计数"></a>条款 29：引用计数</h3><h3 id="条款-30：代理类"><a href="#条款-30：代理类" class="headerlink" title="条款 30：代理类"></a>条款 30：代理类</h3><h3 id="条款-31：让函数根据一个以上的对象类型来决定如何虚化"><a href="#条款-31：让函数根据一个以上的对象类型来决定如何虚化" class="headerlink" title="条款 31：让函数根据一个以上的对象类型来决定如何虚化"></a>条款 31：让函数根据一个以上的对象类型来决定如何虚化</h3><h2 id="杂项讨论"><a href="#杂项讨论" class="headerlink" title="杂项讨论"></a>杂项讨论</h2><h3 id="条款-32：在未来时态下发展程序"><a href="#条款-32：在未来时态下发展程序" class="headerlink" title="条款 32：在未来时态下发展程序"></a>条款 32：在未来时态下发展程序</h3><h3 id="条款-33：将非尾端类设计为抽象类"><a href="#条款-33：将非尾端类设计为抽象类" class="headerlink" title="条款 33：将非尾端类设计为抽象类"></a>条款 33：将非尾端类设计为抽象类</h3><h3 id="条款-34：如何在同一个程序中结合-C-和-C"><a href="#条款-34：如何在同一个程序中结合-C-和-C" class="headerlink" title="条款 34：如何在同一个程序中结合 C++ 和 C"></a>条款 34：如何在同一个程序中结合 C++ 和 C</h3><h3 id="条款-35：让自己习惯于标准-C-语言"><a href="#条款-35：让自己习惯于标准-C-语言" class="headerlink" title="条款 35：让自己习惯于标准 C++ 语言"></a>条款 35：让自己习惯于标准 C++ 语言</h3>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>经验</tag>
      
      <tag>准则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++</title>
    <link href="/2023/08/05/effective-cpp/"/>
    <url>/2023/08/05/effective-cpp/</url>
    
    <content type="html"><![CDATA[<p>有人说 C++ 程序员可以分为两类，读过 Effective C++ 的和没读过的。世界级 C++ 大师 Scott Meyers 成名之作的第三版的确当得起这样的评价。当您读过本书之后，就获得了迅速提升自己 C++ 功力的一个契机。</p><p>在国际上，本书所引起的反响，波及整个计算机的出版领域，余音至今未绝。几乎在所有 C++ 书籍的推荐名单上，本书都会位于前三名。作者高超的技术把握力、独特的视角、诙谐轻松的写作风格、独具匠心的内容组织，都受到极大的推崇和效仿。这种奇特的现象，只能解释为人们对这本书衷心的赞美和推崇。</p><p>这本书不是读完一遍就可以束之高阁的快餐读物，也不是用于解决手边问题的参考手册，而是需要您去反复阅读体会的，C++ 是真正程序员的语言，背后有着精深的思想与无与伦比的表达能力，这使得它具有类似宗教般的魅力。希望这本书能够帮助您跨越 C++ 的重重险阻，领略高处才有的壮美风光，做一个成功而快乐的 C++ 程序员。</p><h2 id="1-让自己习惯-C"><a href="#1-让自己习惯-C" class="headerlink" title="1. 让自己习惯 C++"></a>1. 让自己习惯 C++</h2><p>不论你的编程背景是什么，C++ 都可能让你觉得有点熟悉。它是一个威力强大的语言，带着众多特性，但是在你可以驾驭其威力并有效运用其特性之前，你必须先习惯 C++ 的办事方式。本书谈的便是这个。总有某些东西比其他更基础些，本章就是最基本的一些东西。</p><h3 id="条款-01：视-C-为一个语言联邦"><a href="#条款-01：视-C-为一个语言联邦" class="headerlink" title="条款 01：视 C++ 为一个语言联邦"></a>条款 01：视 C++ 为一个语言联邦</h3><p>今天的 C++ 已经是一个多重范式的编程语言（muti-paradigm programming language），一个同时支持过程形式（procedural），面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）的语言。</p><p>将 C++ 视为一个由相关语言组成的联邦而非单一语言。在其某个次语言（sublanguage）中，各种守则与通例都倾向简单、直观易懂、并且容易记住。然而，当你从一个次语言移往另一个次语言，守则可能改变。为了理解 C++，你必须认识其主要的次语言。</p><ul><li>C</li><li>Object Oriented C++</li><li>Template C++</li><li>STL</li></ul><p>因此说，C++ 并不是一个带有一组守则的一体语言：它是从四个次语言组成的联邦政府，每个次语言都有自己的规约。记住这四个次语言你就会发现 C++ 容易了解得多。</p><div class="note note-success">            <ul><li>C++ 高效编程守则视状况而变化，取决于你使用 C++ 的哪一部分。</li></ul>          </div><h3 id="条款-02：尽量以-const，enum，inline-替换-define"><a href="#条款-02：尽量以-const，enum，inline-替换-define" class="headerlink" title="条款 02：尽量以 const，enum，inline 替换 #define"></a>条款 02：尽量以 const，enum，inline 替换 #define</h3><p>宏定义只会被预处理器看到，而不会被编译器看到；但是常量却可以。<br>可以定义一个类的专属常量，却无法利用 <code>#define</code> 来实现相同的功能，因为宏定义并不重视作用域。<br>无法取地址的常量可以用类内枚举取代。</p><p>宏函数变量必须加小括号，而且其行为并不完全与函数相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 以 a 和 b 中较大值调用 f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a, b);    <span class="hljs-comment">// a 被累加两次</span><br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a, b+<span class="hljs-number">10</span>); <span class="hljs-comment">// a 被累加一次</span><br></code></pre></td></tr></table></figure><p>在这里，调用 <code>f</code> 之前，<code>a</code> 的递增次数竟然取决于“它被拿来和谁比较”！</p><p>使用内联模板函数替换宏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">callWithMax</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(a &gt; b ? a : b);<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <ul><li>对于单纯常量，最好使用 <code>const</code> 对象或 <code>enums</code> 替换 <code>#defines</code>。</li><li>对于形似函数的宏（macros），最好改用 <code>inline</code> 函数替换 <code>#defines</code>。</li></ul>          </div><h3 id="条款-03：尽可能使用-const"><a href="#条款-03：尽可能使用-const" class="headerlink" title="条款 03：尽可能使用 const"></a>条款 03：尽可能使用 const</h3><p><code>const</code> 修饰指针需要区分顶层 <code>const</code> 与底层 <code>const</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> greeting[] = <span class="hljs-string">&quot;Hello&quot;</span>;       <span class="hljs-comment">// 底层 const，顶层 const</span><br><span class="hljs-type">char</span>       *       p = greeting; <span class="hljs-comment">// 数据不是常量，指针不是常量</span><br><span class="hljs-type">char</span> <span class="hljs-type">const</span> *       p = greeting; <span class="hljs-comment">// 数据是常量，指针不是常量</span><br><span class="hljs-type">char</span>       * <span class="hljs-type">const</span> p = greeting; <span class="hljs-comment">// 数据不是常量，指针是常量</span><br><span class="hljs-type">char</span> <span class="hljs-type">const</span> * <span class="hljs-type">const</span> p = greeting; <span class="hljs-comment">// 数据是常量，指针是常量</span><br></code></pre></td></tr></table></figure><p>STL 迭代器的 <code>const</code> 语义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>...<br><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator  iter = vec.<span class="hljs-built_in">begin</span>();  <span class="hljs-comment">// T * const</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator cIter = vec.<span class="hljs-built_in">begin</span>();  <span class="hljs-comment">// T const *</span><br></code></pre></td></tr></table></figure><p>对函数的返回值添加 <code>const</code> 有助于防止用户将返回值按左值使用。</p><h4 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h4><p>将 <code>const</code> 实施于成员函数有两大好处：</p><ol><li>它们使类接口比较容易被理解。这是因为，得知哪个函数可以改动对象内容而哪个函数不行，很是重要。</li><li>它们使“操作 <code>const</code> 对象”成为可能。这对编写高效代码是个关键，因为如<a href="#%E6%9D%A1%E6%AC%BE-20%E5%AE%81%E4%BB%A5%E4%BC%A0%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E6%9B%BF%E6%8D%A2%E4%BC%A0%E5%80%BC">条款 20</a> 所言，改善 C++ 程序效率的一个根本办法是以常引用的方式传递对象，而此技术可行的前提是，我们有 <code>const</code> 成员函数可用来处理取得（并经修饰而成）的 <code>const</code> 对象。</li></ol><p>两个成员函数，如果只是常量性不同，可以被重载。</p><p>对于成员函数的常量性判定，需要区分<strong>物理常量性</strong>和<strong>逻辑常量性</strong>：</p><ul><li>物理常量性是指，成员函数只有在不更改对象之任何成员变量（<code>static</code> 除外）时才可以说是 <code>const</code>。也就是说它不更改对象内的任何一个比特。<br>  不幸的是许多成员函数虽然不十足具备 <code>const</code> 性质却能通过物理常量性测试。更具体地说，一个更改了”指针所指物”的成员函数虽然不能算是 <code>const</code>，但如果只有指针（而非其所指物）隶属于对象，那么称此函数为物理常量性不会引发编译器异议。这导致反直观结果。</li><li>逻辑常量性是指，一个 <code>const</code> 成员函数可以修改它所处理的对象内的某些比特，但只有在客户端侦测不出的情况下才得如此。对于与物理常量性冲突的字段，需要用 <code>mutable</code> 关键字修饰。<code>mutable</code> 可以释放掉非静态成员函数的按比特常量约束。</li></ul><h4 id="在-const-和非-const-成员函数中避免重复"><a href="#在-const-和非-const-成员函数中避免重复" class="headerlink" title="在 const 和非 const 成员函数中避免重复"></a>在 const 和非 const 成员函数中避免重复</h4><p>对于在 <code>const</code> 和非 <code>const</code> 成员函数中有都会出现的重复逻辑，推荐使用非 <code>const</code> 版本调用 <code>const</code> 版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span><br>    &#123;<br>        ...  <span class="hljs-comment">// 边界检查</span><br>        ...  <span class="hljs-comment">// 标志数据访问</span><br>        ...  <span class="hljs-comment">// 校验数据完整性</span><br>        <span class="hljs-keyword">return</span> text[position];<br>    &#125;<br><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position)<br>    &#123;<br>        <span class="hljs-keyword">return</span><br>            <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;(                        <span class="hljs-comment">// 将 op[] 返回值的 const 移除</span><br>                <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> TextBlock&amp;&gt;(*<span class="hljs-keyword">this</span>)  <span class="hljs-comment">// 为 *this 加上 const</span><br>                    [position]                        <span class="hljs-comment">// 调用 const op[]</span><br>            );<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string text;<br>&#125;;<br></code></pre></td></tr></table></figure><p>反向做法——令 <code>const</code> 版本调用非 <code>const</code> 版本是不应该做的。因为 <code>const</code> 成员函数承诺绝不改变其对象的逻辑状态, 非 <code>const</code> 成员函数却没有这般承诺。如果在 <code>const</code> 函数内调用非 <code>const</code> 函数，就是冒了这样的风险：你曾经承诺不改动的那个对象被改动了。</p><div class="note note-success">            <ul><li>将某些东西声明为 <code>const</code> 可帮助编译器侦测出错误用法。<code>const</code> 可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li><li>编译器强制实施“物理上的常量性”（bitwise constness），但你编写程序时应使用“概念上的常量性”（conceptual constness）。</li><li>当 const 和非 const 成员函数有着实质等价的实现时，令非 const 版本调用 const 版本可避免代码重复。</li></ul>          </div><h3 id="条款-04：确定对象被使用前已先被初始化"><a href="#条款-04：确定对象被使用前已先被初始化" class="headerlink" title="条款 04：确定对象被使用前已先被初始化"></a>条款 04：确定对象被使用前已先被初始化</h3><p>永远在使用对象之前先将它初始化。对于无任何成员的内置类型，你必须手工完成此事。</p><p>对于内置类型以外的任何其他类型，初始化责任落在构造函数身上。规则很简单：确保每一个构造函数都将对象的每一个成员初始化。</p><p>推荐使用成员初值列来初始化每个成员，避免先构造再赋值的开销，且确保初始化顺序与成员声明的顺序相同。</p><p>对于有多个构造函数，出现重复初始化的代码，C++11 之后推荐使用委托构造函数，消除重复的初始化代码。</p><p>对于多个编译单元间的具有依赖关系的静态非局部变量的初始化问题，由于 C++ 对“定义于不同编译单元内的非局部静态对象”的初始化次序并无明确定义，推荐的做法是：将每个非局部静态对象搬到自己的专属函数内（该对象在此函数内被声明为静态）。这些函数返回一个引用指向它所含的对象。（单例模式的常见实现手法）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystem</span> &#123; ... &#125;;<br><br><span class="hljs-function">FileSystem&amp; <span class="hljs-title">tfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> FileSystem fs;<br>    <span class="hljs-keyword">return</span> fs;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span> &#123; ... &#125;;<br><br>Directory::<span class="hljs-built_in">Directory</span>(params)<br>&#123;<br>    ...<br>    std::<span class="hljs-type">size_t</span> disks = <span class="hljs-built_in">tfs</span>().<span class="hljs-built_in">numDisks</span>();<br>    ...<br>&#125;<br><br><span class="hljs-function">Directory&amp; <span class="hljs-title">tempDir</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> Directory td;<br>    <span class="hljs-keyword">return</span> td;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <ul><li>为内置型对象进行手工初始化，因为 C++ 不保证初始化它们。</li><li>构造函数最好使用成员初值列（member initialization list），而不要在构造函数本体内使用赋值操作（assignment）。初值列列出的成员函数，其排列次序应该和它们在类中的声明次序相同。</li><li>为免除“跨编译单元之初始化次序”问题，请以局部静态对象替换非局部静态对象。</li></ul>          </div><h2 id="2-构造-析构-赋值运算"><a href="#2-构造-析构-赋值运算" class="headerlink" title="2. 构造&#x2F;析构&#x2F;赋值运算"></a>2. 构造&#x2F;析构&#x2F;赋值运算</h2><h3 id="条款-05：了解-C-默默编写并调用哪些函数"><a href="#条款-05：了解-C-默默编写并调用哪些函数" class="headerlink" title="条款 05：了解 C++ 默默编写并调用哪些函数"></a>条款 05：了解 C++ 默默编写并调用哪些函数</h3><div class="note note-success">            <ul><li>编译器可以暗自为类创建默认构造函数、复制构造函数、复制赋值操作符，以及析构函数。</li></ul>          </div><h3 id="条款-06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款-06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款 06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款 06：若不想使用编译器自动生成的函数，就该明确拒绝</h3><div class="note note-success">            <ul><li>为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为私有并且不予实现。使用像 <code>Uncopyable</code> 这样的基类也是一种做法。</li></ul>          </div><h3 id="条款-07：为多态基类声明虚析构函数"><a href="#条款-07：为多态基类声明虚析构函数" class="headerlink" title="条款 07：为多态基类声明虚析构函数"></a>条款 07：为多态基类声明虚析构函数</h3><div class="note note-success">            <ul><li>带多态性质的（polymorphic）基类应该声明一个虚析构函数。如果类带有任何虚函数，它就应该拥有一个虚析构函数。</li><li>一个类的设计目的如果不是作为基类使用，或不是为了具备多态性（polymorphically），就不该声明虚析构函数。</li></ul>          </div><h3 id="条款-08：别让异常逃离析构函数"><a href="#条款-08：别让异常逃离析构函数" class="headerlink" title="条款 08：别让异常逃离析构函数"></a>条款 08：别让异常逃离析构函数</h3><div class="note note-success">            <ul><li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕获任何异常，然后吞下它们（不传播）或结束程序。</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么类应该提供一个普通函数（而非在析构函数中）执行该操作。</li></ul>          </div><h3 id="条款-09：绝不在构造和析构过程中调用虚函数"><a href="#条款-09：绝不在构造和析构过程中调用虚函数" class="headerlink" title="条款 09：绝不在构造和析构过程中调用虚函数"></a>条款 09：绝不在构造和析构过程中调用虚函数</h3><div class="note note-success">            <ul><li>在构造和析构期间不要调用虚函数，因为这类调用从不下降至派生类（比起当前执行构造函数和析构函数的那层）。</li></ul>          </div><h3 id="条款-10：令-operator-返回一个-this-的引用"><a href="#条款-10：令-operator-返回一个-this-的引用" class="headerlink" title="条款 10：令 operator&#x3D; 返回一个 *this 的引用"></a>条款 10：令 operator&#x3D; 返回一个 *this 的引用</h3><div class="note note-success">            <ul><li>令赋值（assignment）操作符返回一个 <code>*this</code> 的引用，以支持连锁赋值。</li></ul>          </div><h3 id="条款-11：在-operator-中处理“自我赋值”"><a href="#条款-11：在-operator-中处理“自我赋值”" class="headerlink" title="条款 11：在 operator&#x3D; 中处理“自我赋值”"></a>条款 11：在 operator&#x3D; 中处理“自我赋值”</h3><div class="note note-success">            <ul><li>确保当对象自我赋值时 <code>operator=</code> 有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及复制并交换。</li><li>确定任何函数如果操作一个以上的对象，其中多个对象是同一个对象时，其行为依然正确。</li></ul>          </div><h3 id="条款-12：复制对象时勿忘其每一个成分"><a href="#条款-12：复制对象时勿忘其每一个成分" class="headerlink" title="条款 12：复制对象时勿忘其每一个成分"></a>条款 12：复制对象时勿忘其每一个成分</h3><div class="note note-success">            <ul><li>复制函数应该确保复制“对象内的所有成员变量”以及“所有基类成分”。</li><li>不要尝试以某个复制函数实现另一个复制函数。应该将共同机能放进第三个函数中，并由两个复制函数共同调用。</li></ul>          </div><h2 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3. 资源管理"></a>3. 资源管理</h2><h3 id="条款-13：以对象管理资源"><a href="#条款-13：以对象管理资源" class="headerlink" title="条款 13：以对象管理资源"></a>条款 13：以对象管理资源</h3><div class="note note-success">            <ul><li>为防止资源泄露，请使用 RAII 对象，它们在构造函数中获得资源并在析构函数中释放资源。</li><li>两个常被使用的 RAII 类分别是 <code>tr1::shared_ptr</code> 和 <code>auto_ptr</code>。前者常是较佳的选择，因为其复制行为比较直观。若选择 <code>auto_ptr</code>，复制动作会使它（被复制物）指向 <code>null</code>。</li></ul>          </div><h3 id="条款-14：在资源管理类中小心拷贝行为"><a href="#条款-14：在资源管理类中小心拷贝行为" class="headerlink" title="条款 14：在资源管理类中小心拷贝行为"></a>条款 14：在资源管理类中小心拷贝行为</h3><div class="note note-success">            <ul><li>复制 RAII 对象必须一并复制它所管理的资源，所以资源的复制行为决定 RAII 对象的复制行为。</li><li>普遍而常见的 RAII 类的复制行为是：抑制复制、试行引用计数（reference counting）。不过其他行为也都可能被实现。</li></ul>          </div><h3 id="条款-15：在资源管理类中提供对原始资源的访问"><a href="#条款-15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15：在资源管理类中提供对原始资源的访问"></a>条款 15：在资源管理类中提供对原始资源的访问</h3><div class="note note-success">            <ul><li>API 往往要求访问原始资源（raw resources），所以每一个 RAII 类应该提供一个“取得其所管理之资源”的办法。</li><li>对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。</li></ul>          </div><h3 id="条款-16：成对使用-new-和-delete-时要采取相同形式"><a href="#条款-16：成对使用-new-和-delete-时要采取相同形式" class="headerlink" title="条款 16：成对使用 new 和 delete 时要采取相同形式"></a>条款 16：成对使用 new 和 delete 时要采取相同形式</h3><div class="note note-success">            <ul><li>如果你在 <code>new</code> 表达式中使用 []，必须在相应的 <code>delete</code> 表达式中也使用 []。如果你在 <code>new</code> 表达式中不使用 []，一定不要在相应的 delete 表达式中使用 []。</li></ul>          </div><h3 id="条款-17：以独立语句将-newed-对象置入智能指针"><a href="#条款-17：以独立语句将-newed-对象置入智能指针" class="headerlink" title="条款 17：以独立语句将 newed 对象置入智能指针"></a>条款 17：以独立语句将 newed 对象置入智能指针</h3><div class="note note-success">            <ul><li>以独立语句将 <code>new</code> 生成的对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。</li></ul>          </div><h2 id="4-设计与声明"><a href="#4-设计与声明" class="headerlink" title="4. 设计与声明"></a>4. 设计与声明</h2><h3 id="条款-18：让接口容易被正确使用，不易被误用"><a href="#条款-18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款 18：让接口容易被正确使用，不易被误用"></a>条款 18：让接口容易被正确使用，不易被误用</h3><div class="note note-success">            <ul><li>好的接口很容易被使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li><li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以消除客户的资源管理责任。</li><li><code>tr1::shared_ptr</code> 支持定制型删除器（custom deleter）。这可防范 DLL 问题，可被用来自动解除互斥锁等等。</li></ul>          </div><h3 id="条款-19：设计类犹如设计类型"><a href="#条款-19：设计类犹如设计类型" class="headerlink" title="条款 19：设计类犹如设计类型"></a>条款 19：设计类犹如设计类型</h3><div class="note note-success">            <ul><li>类的设计就是类型的设计。在定义一个新类型之前，请确保你已经考虑过本条款覆盖的所有讨论主题。</li></ul>          </div><h3 id="条款-20：宁以传常量引用替换传值"><a href="#条款-20：宁以传常量引用替换传值" class="headerlink" title="条款 20：宁以传常量引用替换传值"></a>条款 20：宁以传常量引用替换传值</h3><div class="note note-success">            <ul><li>尽量以传递常量引用替换传值。前者通常比较高效，并可避免对象切割问题。</li><li>以上规则并不适用于内置类型，以及 STL 的迭代器和函数对象。对它们而言，传值往往比较适当。</li></ul>          </div><h3 id="条款-21：必须返回对象时，别妄想返回其引用"><a href="#条款-21：必须返回对象时，别妄想返回其引用" class="headerlink" title="条款 21：必须返回对象时，别妄想返回其引用"></a>条款 21：必须返回对象时，别妄想返回其引用</h3><div class="note note-success">            <ul><li>绝不要返回指针或引用指向一个局部栈对象，或返回引用指向一个堆分配对象，或返回指针或引用指向一个局部静态对象而言有可能同时需要多个这样的对象。条款 4 已经为“在单线程中合理返回一个局部静态对象”提供一份设计实例。</li></ul>          </div><h3 id="条款-22：将成员变量声明为私有"><a href="#条款-22：将成员变量声明为私有" class="headerlink" title="条款 22：将成员变量声明为私有"></a>条款 22：将成员变量声明为私有</h3><div class="note note-success">            <ul><li>切记将成员变量声明为私有。这可赋予客户访问数据的一致性、可细微划分访问控制、允许约束条件获得保证，并提供类作者以充分的实现弹性。</li><li><code>protected</code> 并不比 <code>public</code> 更具封装性。</li></ul>          </div><h3 id="条款-23：宁以非成员、非友元替换成员函数"><a href="#条款-23：宁以非成员、非友元替换成员函数" class="headerlink" title="条款 23：宁以非成员、非友元替换成员函数"></a>条款 23：宁以非成员、非友元替换成员函数</h3><div class="note note-success">            <ul><li>如果你需要为某个函数的所有参数（包括 <code>this</code> 指针所指的那个隐藏参数）进行类型转换，那么这个函数必须是个非成员函数。</li><li>宁可拿非成员非友元函数替换成员函数。这样做可以增加封装性、包裹弹性和机能扩充性。</li></ul>          </div><h3 id="条款-24：若所有参数皆需类型转换，请为此采用非成员函数"><a href="#条款-24：若所有参数皆需类型转换，请为此采用非成员函数" class="headerlink" title="条款 24：若所有参数皆需类型转换，请为此采用非成员函数"></a>条款 24：若所有参数皆需类型转换，请为此采用非成员函数</h3><div class="note note-success">            <ul><li>如果你需要为某个函数的所有参数（包括被 <code>this</code> 指针所指的那个隐藏参数）进行类型转换，那么这个函数必须是个非成员函数。</li></ul>          </div><h3 id="条款-25：考虑写出一个不抛异常的-swap-函数"><a href="#条款-25：考虑写出一个不抛异常的-swap-函数" class="headerlink" title="条款 25：考虑写出一个不抛异常的 swap 函数"></a>条款 25：考虑写出一个不抛异常的 swap 函数</h3><div class="note note-success">            <ul><li>当 <code>std::swap</code> 对你的类型效率不高时，提供一个 <code>swap</code> 成员函数，并确定这个函数不抛出异常。</li><li>如果你提供一个成员函数版 <code>swap</code>，也该提供一个非成员版 <code>swap</code> 用来调用前者。对于类（而非模板），也请特化 <code>std::swap</code>。</li><li>调用 <code>swap</code> 时应针对 <code>std::swap</code> 使用 <code>using</code> 声明式，然后调用 <code>swap</code> 并且不带任何“命名空间资格修饰”。</li><li>为“用户定义类型”进行 <code>std templates</code> 全特化是好的，但千万不要尝试在 <code>std</code> 内加入某些对 <code>std</code> 而言全新的东西。</li></ul>          </div><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><h3 id="条款-26：尽可能延后变量定义式的出现时间"><a href="#条款-26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款 26：尽可能延后变量定义式的出现时间"></a>条款 26：尽可能延后变量定义式的出现时间</h3><div class="note note-success">            <ul><li>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</li></ul>          </div><h3 id="条款-27：尽量少做转型动作"><a href="#条款-27：尽量少做转型动作" class="headerlink" title="条款 27：尽量少做转型动作"></a>条款 27：尽量少做转型动作</h3><div class="note note-success">            <ul><li>如果可以，尽量避免转型，特别是在注重效率的代码中避免 <code>dynamic_cast</code>。如果有个设计需要转型动作，试着发展无需转型的替代设计。</li><li>如果转型是必须的，试着将它隐藏于某个函数背后。客户随时可以调用该函数，而不需要将转型放进他们自己的代码内。</li><li>宁可使用 C++ 风格（新式）转型，不要使用旧式转型。前者很容易辨别出来，而且也比较有着分门别类的职掌。</li></ul>          </div><h3 id="条款-28：避免返回指向对象内部成分的句柄"><a href="#条款-28：避免返回指向对象内部成分的句柄" class="headerlink" title="条款 28：避免返回指向对象内部成分的句柄"></a>条款 28：避免返回指向对象内部成分的句柄</h3><div class="note note-success">            <ul><li>避免返回句柄（包括引用、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助 <code>const</code> 成员函数的行为像个 <code>const</code>，并将发生“虚吊号码牌”（dangling handles）的可能性降至最低。</li></ul>          </div><h3 id="条款-29：为“异常安全”而努力是值得的"><a href="#条款-29：为“异常安全”而努力是值得的" class="headerlink" title="条款 29：为“异常安全”而努力是值得的"></a>条款 29：为“异常安全”而努力是值得的</h3><div class="note note-success">            <ul><li>异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。</li><li>“强烈保证”往往能够以复制并交换实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。</li><li>函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</li></ul>          </div><h3 id="条款-30：透彻了解内联的里里外外"><a href="#条款-30：透彻了解内联的里里外外" class="headerlink" title="条款 30：透彻了解内联的里里外外"></a>条款 30：透彻了解内联的里里外外</h3><div class="note note-success">            <ul><li>将大多数内联限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li><li>不要只因为函数模板出现在头文件，就将它们声明为内联。</li></ul>          </div><h3 id="条款-31：将文件的编译依存关系降至最低"><a href="#条款-31：将文件的编译依存关系降至最低" class="headerlink" title="条款 31：将文件的编译依存关系降至最低"></a>条款 31：将文件的编译依存关系降至最低</h3><div class="note note-success">            <ul><li>支持“编译依存性最小化”的一般构想是：相依与声明式，不要相依于定义式。基于此构想的两个手段是句柄类（Handle classes）和接口类（Interface classes）。</li><li>程序库头文件应该以“完全仅有声明式”的形式存在。这种做法不论是否涉及模板都适用。</li></ul>          </div><h2 id="6-继承与面向对象设计"><a href="#6-继承与面向对象设计" class="headerlink" title="6. 继承与面向对象设计"></a>6. 继承与面向对象设计</h2><h3 id="条款-32：确定你的公有继承塑模出“是一个”关系"><a href="#条款-32：确定你的公有继承塑模出“是一个”关系" class="headerlink" title="条款 32：确定你的公有继承塑模出“是一个”关系"></a>条款 32：确定你的公有继承塑模出“是一个”关系</h3><div class="note note-success">            <ul><li>“公有继承”意味着“是一个”。适用于基类身上的每一件事情一定也适用于派生类身上，因为每一个派生类对象也都是一个基类对象。</li></ul>          </div><h3 id="条款-33：避免遮掩继承而来的名称"><a href="#条款-33：避免遮掩继承而来的名称" class="headerlink" title="条款 33：避免遮掩继承而来的名称"></a>条款 33：避免遮掩继承而来的名称</h3><div class="note note-success">            <ul><li>派生类内的名称会遮掩基类内的名称。在共有继承下从来没有人希望如此。</li><li>为了让被遮掩的名称再见天日，可使用 using 声明式或转交函数(forwarding functions)。</li></ul>          </div><h3 id="条款-34：区分接口继承和实现继承"><a href="#条款-34：区分接口继承和实现继承" class="headerlink" title="条款 34：区分接口继承和实现继承"></a>条款 34：区分接口继承和实现继承</h3><div class="note note-success">            <ul><li>接口继承和实现继承不同。在共有继承下，派生类总是继承基类的接口。</li><li>纯虚函数只具体指定接口继承。</li><li>简朴的非纯虚函数具体指定接口继承及缺省实现继承。</li><li>非虚函数具体指定接口继承以及强制性实现继承。</li></ul>          </div><h3 id="条款-35：考虑虚函数以外的其他选择"><a href="#条款-35：考虑虚函数以外的其他选择" class="headerlink" title="条款 35：考虑虚函数以外的其他选择"></a>条款 35：考虑虚函数以外的其他选择</h3><div class="note note-success">            <ul><li>虚函数的替代方案包括 NVI 手法以及策略设计模式的多种形式。NVI 手法自身是一个特殊形式的模板方法设计模式。</li><li>将机能从成员函数移到类外部函数，带来的一个缺点是，非成员函数无法访问类的非公有成员。</li><li>tr1::function 对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式兼容”的所有可调用物。</li></ul>          </div><h3 id="条款-36：绝不重新定义继承而来的非虚函数"><a href="#条款-36：绝不重新定义继承而来的非虚函数" class="headerlink" title="条款 36：绝不重新定义继承而来的非虚函数"></a>条款 36：绝不重新定义继承而来的非虚函数</h3><div class="note note-success">            <ul><li>绝对不要重新定义继承而来的非虚函数。</li></ul>          </div><h3 id="条款-37：绝不重新定义继承而来的缺省参数值"><a href="#条款-37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款 37：绝不重新定义继承而来的缺省参数值"></a>条款 37：绝不重新定义继承而来的缺省参数值</h3><div class="note note-success">            <ul><li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定的，而虚函数 – 你唯一应该覆写的东西 – 却是动态绑定的。</li></ul>          </div><h3 id="条款-38：通过复合塑模出“有一个”或“根据某物实现出”"><a href="#条款-38：通过复合塑模出“有一个”或“根据某物实现出”" class="headerlink" title="条款 38：通过复合塑模出“有一个”或“根据某物实现出”"></a>条款 38：通过复合塑模出“有一个”或“根据某物实现出”</h3><div class="note note-success">            <ul><li>复合的意义与共有继承完全不同。</li><li>在应用域，复合意味着有一个。在实现域，复合意味着根据某物实现出。</li></ul>          </div><h3 id="条款-39：明智而审慎地使用私有继承"><a href="#条款-39：明智而审慎地使用私有继承" class="headerlink" title="条款 39：明智而审慎地使用私有继承"></a>条款 39：明智而审慎地使用私有继承</h3><div class="note note-success">            <ul><li>私有继承意味着根据某物实现出。它通常比复合的级别低。但是当派生类需要访问基类的保护成员，或需要重新定义继承而来的虚函数时，这么设计是合理的。</li><li>和复合不同，私有继承可以造成空基类优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。</li></ul>          </div><h3 id="条款-40：明智而审慎地使用多重继承"><a href="#条款-40：明智而审慎地使用多重继承" class="headerlink" title="条款 40：明智而审慎地使用多重继承"></a>条款 40：明智而审慎地使用多重继承</h3><div class="note note-success">            <ul><li>多重继承比单一继承复杂。它可能导致新的歧义，以及对虚继承的需要。</li><li>虚继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果虚基类不带任何数据，将是最具实用价值的情况。</li><li>多重继承的确有正当用途。其中一个情节涉及“共有继承某个接口类”和“私有继承某个协助实现的类”的两相组合。</li></ul>          </div><h2 id="7-模板与泛型编程"><a href="#7-模板与泛型编程" class="headerlink" title="7. 模板与泛型编程"></a>7. 模板与泛型编程</h2><h3 id="条款-41：了解隐式接口和编译期多态"><a href="#条款-41：了解隐式接口和编译期多态" class="headerlink" title="条款 41：了解隐式接口和编译期多态"></a>条款 41：了解隐式接口和编译期多态</h3><div class="note note-success">            <ul><li>类（classes）和模板（templates）都支持接口（interfaces）和多态（polymorphism）。</li><li>对类而言接口是显式的（explicit），以函数签名为中心。多态则是通过虚函数发生于运行期。</li><li>对模板参数而言，接口是隐式的（implicit），奠基于有效表达式。多态则是通过模板具现化和函数重载解析（function overloading resolution）发生于编译期。</li></ul>          </div><h3 id="条款-42：了解-typename-的双重意义"><a href="#条款-42：了解-typename-的双重意义" class="headerlink" title="条款 42：了解 typename 的双重意义"></a>条款 42：了解 typename 的双重意义</h3><div class="note note-success">            <ul><li>声明模板参数时，前缀关键字 <code>class</code> 和 <code>typename</code> 可互换。</li><li>请使用关键字 <code>typename</code> 标识嵌套从属类型名称；但不得在基类列或成员初值列内以它作为基类修饰符。</li></ul>          </div><h3 id="条款-43：学习处理模板化基类内的名称"><a href="#条款-43：学习处理模板化基类内的名称" class="headerlink" title="条款 43：学习处理模板化基类内的名称"></a>条款 43：学习处理模板化基类内的名称</h3><div class="note note-success">            <ul><li>可在派生类模板内通过 “this-&gt;” 指涉基类模板内的成员名称，或籍由一个明白写出的“基类资格修饰符”完成。</li></ul>          </div><h3 id="条款-44：将与参数无关的代码抽离模板"><a href="#条款-44：将与参数无关的代码抽离模板" class="headerlink" title="条款 44：将与参数无关的代码抽离模板"></a>条款 44：将与参数无关的代码抽离模板</h3><div class="note note-success">            <ul><li>模板生成多个类或多个函数，所以任何模板代码都不该与某个造成膨胀的模板参数产生相依关系关系。</li><li>因非类型模板参数而造成的代码膨胀，往往可以消除，做法是以函数参数或类成员变量替换模板参数。</li><li>因类型参数而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述的具现类型共享实现码。</li></ul>          </div><h3 id="条款-45：运用成员函数模板接受所有兼容类型"><a href="#条款-45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款 45：运用成员函数模板接受所有兼容类型"></a>条款 45：运用成员函数模板接受所有兼容类型</h3><div class="note note-success">            <ul><li>请使用成员函数模板生成“可接收所有兼容类型”的函数。</li><li>如果你声明成员模板用于“泛化复制构造”或“泛化赋值操作”，你还是需要声明正常的复制构造和复制赋值操作符。</li></ul>          </div><h3 id="条款-46：需要类型转换时请为模板定义非成员函数"><a href="#条款-46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款 46：需要类型转换时请为模板定义非成员函数"></a>条款 46：需要类型转换时请为模板定义非成员函数</h3><div class="note note-success">            <ul><li>当我们编写一个类模板，而它所提供之“与此模板相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“类模板内部的友元函数”。</li></ul>          </div><h3 id="条款-47：请使用萃取类表现类型信息"><a href="#条款-47：请使用萃取类表现类型信息" class="headerlink" title="条款 47：请使用萃取类表现类型信息"></a>条款 47：请使用萃取类表现类型信息</h3><div class="note note-success">            <ul><li>Traits 类使得“类型相关信息”在编译期可用。它们以模板和模板特化完成实现。</li><li>整合重载技术后，traits 类有可能在编译期对类型执行 <code>if...else</code> 测试。</li></ul>          </div><h3 id="条款-48：认识模板元编程"><a href="#条款-48：认识模板元编程" class="headerlink" title="条款 48：认识模板元编程"></a>条款 48：认识模板元编程</h3><div class="note note-success">            <ul><li>模板元编程（Template Meta Programming, TMP）可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率。</li><li>TMP 可被用来生成“基于策略选择组合”的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li></ul>          </div><h2 id="8-定制-new-和-delete"><a href="#8-定制-new-和-delete" class="headerlink" title="8. 定制 new 和 delete"></a>8. 定制 new 和 delete</h2><h3 id="条款-49：了解-new-handler-的行为"><a href="#条款-49：了解-new-handler-的行为" class="headerlink" title="条款 49：了解 new-handler 的行为"></a>条款 49：了解 new-handler 的行为</h3><div class="note note-success">            <ul><li><code>set_new_handler</code> 允许客户指定一个函数，在内存分配无法获得满足时被调用。</li><li>Nothrow new 是一个颇为局限的工具，因为它只适用于内存分配；后续的构造函数调用还是可能抛出异常。</li></ul>          </div><h3 id="条款-50：了解-new-和-delete-的合理替换时机"><a href="#条款-50：了解-new-和-delete-的合理替换时机" class="headerlink" title="条款 50：了解 new 和 delete 的合理替换时机"></a>条款 50：了解 new 和 delete 的合理替换时机</h3><div class="note note-success">            <ul><li>有许多理由需要写个自定义 <code>new</code> 和 <code>delete</code>，包括改善效能、对堆栈运用错误进行调试、收集堆栈使用信息。</li></ul>          </div><h3 id="条款-51：编写-new-和-delete-时需固守常规"><a href="#条款-51：编写-new-和-delete-时需固守常规" class="headerlink" title="条款 51：编写 new 和 delete 时需固守常规"></a>条款 51：编写 new 和 delete 时需固守常规</h3><div class="note note-success">            <ul><li><code>operator new</code> 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用 new-handler。它也应该有能力处理零字节申请。类专属版本则还应该处理“比正确大小更大的（错误）申请”。</li><li><code>operator delete</code> 应该在收到空指针时不做任何事。类专属版本则还应该处理“比正确大小更大的（错误）申请”。</li></ul>          </div><h3 id="条款-52：写了原位-new-也要写原位-delete"><a href="#条款-52：写了原位-new-也要写原位-delete" class="headerlink" title="条款 52：写了原位 new 也要写原位 delete"></a>条款 52：写了原位 new 也要写原位 delete</h3><div class="note note-success">            <ul><li>当你写一个 <code>placement operator new</code>，请确定也写了对应的 <code>placement operator delete</code>。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄露。</li><li>当你声明 <code>placement new</code> 和 <code>placement delete</code>，请确定不要无意思（非故意）地遮掩了它们的正常版本。</li></ul>          </div><h2 id="9-杂项讨论"><a href="#9-杂项讨论" class="headerlink" title="9. 杂项讨论"></a>9. 杂项讨论</h2><h3 id="条款-53：不要轻易忽视编译器的警告"><a href="#条款-53：不要轻易忽视编译器的警告" class="headerlink" title="条款 53：不要轻易忽视编译器的警告"></a>条款 53：不要轻易忽视编译器的警告</h3><div class="note note-success">            <ul><li>严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取“无任何警告”的荣誉。</li><li>不要过度依赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失。</li></ul>          </div><h3 id="条款-54：让自己熟悉包括-TR1-在内的标准程序库"><a href="#条款-54：让自己熟悉包括-TR1-在内的标准程序库" class="headerlink" title="条款 54：让自己熟悉包括 TR1 在内的标准程序库"></a>条款 54：让自己熟悉包括 TR1 在内的标准程序库</h3><div class="note note-success">            <ul><li>C++ 标准库的主要机能由 STL、iostreams、locales 组成。并包含 C99 标准程序库。</li><li>TR1 添加了智能指针（例如 <code>tr1::shared_ptr</code>）、一般化函数指针（<code>tr1::function</code>）、基于哈希的（hash-based）容器、正则表达式（regular expression）、以及另外 10 个组件的支持。</li><li>TR1 自身只是一份规范。未获得 TR1 提供的好处，你需要一份实物。一个好的实物来源是 Boost。</li></ul>          </div><h3 id="条款-55：让自己熟悉-Boost"><a href="#条款-55：让自己熟悉-Boost" class="headerlink" title="条款 55：让自己熟悉 Boost"></a>条款 55：让自己熟悉 Boost</h3><div class="note note-success">            <ul><li>Boost 是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的 C++ 程序库开发。Boost 在 C++ 标准化过程中扮演深具影响力的角色。</li><li>Boost 提供许多 TR1 组件实现品，以及其他许多程序库。</li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>经验</tag>
      
      <tag>准则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Lambda 的故事</title>
    <link href="/2023/08/04/cpp-lambda-story/"/>
    <url>/2023/08/04/cpp-lambda-story/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/cpp-lambda-story/cpp_with_lambda.png" alt=" "></p><h2 id="C-98-03-中的-Lambda"><a href="#C-98-03-中的-Lambda" class="headerlink" title="C++98&#x2F;03 中的 Lambda"></a>C++98&#x2F;03 中的 Lambda</h2><p>作为开始，了解一些关于我们所讨论的主题的背景知识是很有必要的。为此，我们会转而回顾过去，看看那些不使用任何现代 C++ 技术的代码——即 C++98&#x2F;03 规范下的代码。</p><p>在本章中，我们将会学习：</p><ul><li>如何将旧式的函数对象传给 C++ 标准库中的各种算法。</li><li>函数对象类型的限制。</li><li>为什么辅助函数不够好。</li><li>C++0x&#x2F;C++11 中引入 Lambda 的动机。</li></ul><h3 id="C-98-03-中的可调用对象"><a href="#C-98-03-中的可调用对象" class="headerlink" title="C++98&#x2F;03 中的可调用对象"></a>C++98&#x2F;03 中的可调用对象</h3><p>标准库的一个基本设计思想是：对于像 <code>std::sort</code>，<code>std::for_each</code>，<code>std::transform</code> 等这样的泛型函数，能够接受任何可调用对象然后对输入容器中的每个元素依次调用它。然而，在 C++98&#x2F;03 中，可调用对象只包括函数指针和重载了调用操作符的类类型（通常被称为“函子”）。</p><p>举例来说，我们有一个打印一个向量中所有元素的应用程序。<br>在第一个版本中，我们使用普通的函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex1_1: 一个基础的函数对象.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// C++03 不支持统一初始化！</span><br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 只有 push_back 可用... :)</span><br>    std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), PrintFunc);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码使用 <code>std::for_each</code> 来迭代 <code>vector</code>（我们使用的是 C++98&#x2F;03，所以没有基于范围的 for 循环！），然后它将 <code>PrintFunc</code> 作为一个可调用对象传递。</p><p>我们可以使用调用操作符将此函数转换为类类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex1_2: 一个简单的打印功能的函数对象.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Printer</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// C++98/03 中没有初始化器列表...</span><br>    std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Printer</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子定义了一个重载了 <code>operator()</code> 的结构体，因此你能够像普通函数一样去“调用”它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">Printer printer;<br><span class="hljs-built_in">printer</span>();            <span class="hljs-comment">// 调用 operator()</span><br>printer.<span class="hljs-built_in">operator</span>()(); <span class="hljs-comment">// 等价调用</span><br></code></pre></td></tr></table></figure><p>而非成员函数通常是无状态的（你可以在常规函数中使用全局变量或静态变量，但这不是最好的解决方案，这样的方法很难跨多个 Lambda 调用组控制状态），函数式的类类型却可以持有非静态成员变量从而能够保存状态。一个典型的例子是记录一个可调用对象被一个算法调用的次数。解决方案通常需要维护一个计数器，然后在每次调用时更新它的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex1_3: 带状态的函数对象.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PrinterEx</span> &#123;<br>    <span class="hljs-built_in">PrinterEx</span>(): <span class="hljs-built_in">numCalls</span>(<span class="hljs-number">0</span>) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        ++numCalls;<br>    &#125;<br>    <span class="hljs-type">int</span> numCalls;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-type">const</span> PrinterEx vis = std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">PrinterEx</span>());<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;num calls: &quot;</span> &lt;&lt; vis.numCalls &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上例中，数据成员 numCalls 被用在调用运算符重载中计数此函数的调用次数。<code>std::for_each</code> 返回我们传入的函数对象，因此我们能够得到该对象并获取其数据成员。</p><p>如你所料，我们能够得到以下输出：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">1<br>2<br>num calls: 2<br></code></pre></td></tr></table></figure><p>我们还可以从调用作用域“捕获”变量。为此，我们必须创建一个数据成员，并在构造函数中初始化它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex1_4: 捕获变量的函数对象.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PrinterEx</span> &#123;<br>    <span class="hljs-built_in">PrintEx</span>(<span class="hljs-type">const</span> std::string&amp; str) :<br>        <span class="hljs-built_in">strText</span>(str), <span class="hljs-built_in">numCalls</span>(<span class="hljs-number">0</span>) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        std::cout &lt;&lt; strText &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        ++numCalls;<br>    &#125;<br>    std::string strText;<br>    <span class="hljs-type">int</span> numCalls;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string <span class="hljs-title">introText</span><span class="hljs-params">(<span class="hljs-string">&quot;Elem: &quot;</span>)</span></span>;<br>    <span class="hljs-type">const</span> PrinterEx vis = std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),<br>                                        <span class="hljs-built_in">PrinterEx</span>(introText));<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;num calls: &quot;</span> &lt;&lt; vis.numCalls &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个版本中，<code>PrinterEx</code> 带有一个额外参数去初始化其数据成员。之后在调用运算符中使用这个变量，输出如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">Elem: 1<br>Elem: 2<br>num calls: 2<br></code></pre></td></tr></table></figure><h3 id="何谓“函子”"><a href="#何谓“函子”" class="headerlink" title="何谓“函子”"></a>何谓“函子”</h3><p>在上面的小节中，我们有时将带有 <code>operator()</code> 的类类型叫做“函子”。虽然这个术语很方便，而且比“函数对象类类型”要短得多，但并不正确的。</p><p>从词源上来看，“函子”来自于函数式编程，它有不同的含义而不是 C++ 中的术语。引用 Bartosz Milewski 中对于<a href="https://bartoszmilewski.com/2015/01/20/functors/">函子</a>的定义：</p><div class="note note-info">            <p>函子是类别之间的映射。给定两类别 C 和 D，一个函子 F 能将 C 中的对象映射到 D 中的对象——它是作用在对象上的函数。</p>          </div><p>这个定义看上去相当抽象，但幸运的是，我们还可以去看到一些简化版 。在《C++ 函数式编程》这本书的第 10 章中，作者 Ivan Cukic 将这个抽象的定义“翻译”成更适合 C++ 语言的版本：</p><div class="note note-info">            <p>拥有一个定义在其上的变换（或映射）函数的类模板 F 是一个函子。</p>          </div><p>此外，这样的变换函数必须遵守恒性等和可组合性这两条规则。“函子”一词在 C++ 规范中没有以任何形式出现（即使在 C++ 98&#x2F;03 中也是如此），因此在本书的其余部分，我们将尽量避免使用它。</p><p>当然，你还可以通过以下资源的阅读来了解更多关于函子的内容：</p><ul><li><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures - adit.io</a></li><li><a href="https://bartoszmilewski.com/2015/01/20/functors/">Functors | Bartosz Milewski’s Programming Cafe</a></li><li><a href="https://stackoverflow.com/questions/356950/what-are-c-functors-and-their-uses">What are C++ functors and their uses? - Stack Overflow</a></li><li><a href="https://en.wikipedia.org/wiki/Functor">Functor - Wikipedia</a></li></ul><h3 id="函数对象类类型的问题"><a href="#函数对象类类型的问题" class="headerlink" title="函数对象类类型的问题"></a>函数对象类类型的问题</h3><p>如你所见，创建一个重载了调用运算符的类类型非常强大。你可以有全流程的把控，你可以以任何喜欢的方式设计它们。</p><p>然而，在 C++98&#x2F;03 中，问题在于当你要用一个算法调用一个函数对象时，你却不得不在不同的地方定义它。这可能意味着可调用对象可以在源文件的前面或后面几十或几百行，甚至位于不同的翻译单元中。</p><p>作为一种可能的解决方案，你可能尝试过编写局部类，因为 C++ 支持这样的语法。但这并不适用于模板。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 一个局部函数对象类型</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LocalPrinter</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span>&#123;<br>            std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>)</span></span>;<br>    std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">LocalPrinter</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>尝试在 GCC 上用 <code>-std=c++98</code> 参数来编译它将会得到如下错误提示：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">error: template argument for<br>&#x27;template&lt;class _IIter, class _Funct&gt; _Funct<br>std::for_each(_IIter, _IIter, _Funct)&#x27;<br>uses local type &#x27;main()::LocalPrinter&#x27;<br></code></pre></td></tr></table></figure><p>看起来，在 C++ 98&#x2F;03 中，无法用局部类型实例化模板。</p><p>C++ 程序员很快就理解了这些限制，并找到了在 C++98&#x2F;03 中绕过这个问题的方法。一种解决方案就是准备一组辅助类。让我们看下一节。</p><h3 id="使用辅助类"><a href="#使用辅助类" class="headerlink" title="使用辅助类"></a>使用辅助类</h3><p>那么，究竟什么是辅助类和和预定义的函数对象呢?</p><p>如果你去查看标准库中的 <code>&lt;functional&gt;</code> 头文件，你将会一系列可以立即用于标准库算法的类型和函数。</p><p>例如：</p><ul><li><code>std::plus&lt;T&gt;()</code> - 接受两个参数并返回它们的和。</li><li><code>std::minus&lt;T&gt;()</code> - 接受两个参数并返回它们的差。</li><li><code>std::less&lt;T&gt;()</code> - 接受两个参数返回是否第一个参数小于第二个参数。</li><li><code>std::greater_equal&lt;T&gt;()</code> - 接受两个参数返回是否第一个参数大于等于第二个参数。</li><li><code>std::bind1st</code> - 创建一个将第一个参数固定为所给值的可调用对象。</li><li><code>std::bind2nd</code> - 创建一个将第二个参数固定为所给值的可调用对象。</li><li><code>std::mem_fun</code> - 创建一个成员函数的包装对象。</li><li>等等。</li></ul><p>让我们编写一些得益于这些辅助类的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex1_5: 使用旧式的 C++98/03 样式的辅助类。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// .. push back until 9...</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> smaller5 = std::<span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),<br>                                          std::<span class="hljs-built_in">bind2nd</span>(std::<span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">5</span>));<br>    <span class="hljs-keyword">return</span> smaller5;<br>&#125;<br></code></pre></td></tr></table></figure><p>该示例使用 <code>std::less</code> 并通过使用 <code>std::bind2nd</code> 固定其第二个参数（<code>bind1st</code>, <code>bind2nd</code> 和其他函数辅助器已在 C++11 中弃用，并在 C++ 17 中移除。本章中的代码仅用于说明 C++ 98&#x2F;03 中的问题。请在你的项目中使用更加现代的替代方案。）。这整个组件被传递到 <code>count_if</code> 中。你可能已经猜到了，代码最终转换成了一个执行简单比较的函数：<code>return x &lt; 5;</code>如果你想要更多现成的帮助程序，那么你还可以查看 boost 库，例如 <code>boost::bind</code>。</p><p>不幸的是，这种方法的主要问题是语法复杂且难以学习。</p><p>例如，编写包含两个或多个辅助函数的代码很不自然。如下例所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex1_6：辅助器的组合。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> std::placeholders::_1;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// push_back until 9...</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> val = std::<span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),<br>                                     std::<span class="hljs-built_in">bind</span>(std::<span class="hljs-built_in">logical_and</span>&lt;<span class="hljs-type">bool</span>&gt;(),<br>                                     std::<span class="hljs-built_in">bind</span>(std::<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;(), _1, <span class="hljs-number">2</span>),<br>                                     std::<span class="hljs-built_in">bind</span>(std::<span class="hljs-built_in">less_equal</span>&lt;<span class="hljs-type">int</span>&gt;(), _1, <span class="hljs-number">6</span>)));<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure><p>改代码使用了 <code>std::bind</code>（它来自 C++ 11，所以我们作弊了，它不是 C++98&#x2F;03）<br>来完成 <code>std::greater</code>，<code>std::less_equal</code> 以及 <code>std::logical_and</code> 的连接。此外，代码使用 <code>_1</code> 作为第一个输入参数的占位符。</p><p>虽然上面的代码可以工作，并且你可以在局部定义它，但是你可能已经看出来它的复杂以及不自然的语法。且不说这个组合只代表了一个简单的条件：<code>return x &gt; 2 &amp;&amp; x &lt;= 6;</code>那么，是否还有更好用更直接的方法呢？</p><h3 id="新特性引入的动机"><a href="#新特性引入的动机" class="headerlink" title="新特性引入的动机"></a>新特性引入的动机</h3><p>如你所见，在 C++98&#x2F;03，调用标准库的一些算法和工具总是需要定义并传入一个可调用对象。然而，所有的可选方案都或多或少有一些限制。例如，你不能定义一个局部函数对象类型，或是使用辅助函数对象的组合，但它很复杂。</p><p>幸运的是，在 C++11 中我们终于看到了许多改进！</p><p>首先，C++ 标准委员会取消了模板实例化对局部类类型的限制。从 C++11 开始，你可以在任何你需要的局部作用域编写重载了调用操作符的类类型。</p><p>更重要的是，C++11 还带来了另一个想法：如果我们有一个简短的语法，然后编译器可以将它“展开”为相应的局部函数对象的定义呢?</p><p>这就是“Lambda 表达式”的诞生！</p><p>如果我们看看 <a href="https://timsong-cpp.github.io/cppwp/n3337/">N3337</a>—— C++11 的最终草案，我们可以看到一个关于 Lambdas 的单独部分：[<a href="https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda">expr.prim.lambda</a>]。</p><p>让我们在下一章中看看这个新特性。</p><h2 id="C-11-中的-Lambda"><a href="#C-11-中的-Lambda" class="headerlink" title="C++11 中的 Lambda"></a>C++11 中的 Lambda</h2><p>万岁！C++ 委员会听取了开发人员的意见，在 C++11 标准中加入了 Lambda 表达式！</p><p>Lambda 表达式很快就成为现代 C++ 中最具辨识度的一个特性。</p><p>你可以在 <a href="https://timsong-cpp.github.io/cppwp/n3337/">N3337</a>（C++11 的最终草案）中阅读其完整规范，以及关于 Lambda 的单独部分：<a href="https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda">[express .prim.lambda]</a>。</p><p>我认为委员会以一种聪明的方式在语言中添加了 Lambda。他们设计了新的语法，但随后编译器将其“展开”为一个未命名的“隐藏的”函数对象类型。这样我们就拥有了真正强类型语言的所有优点（以及缺点），使代码理解起来更加容易。</p><p>在本章，你将会学习到：</p><ul><li>Lambda 的基础语法。</li><li>如何捕获一个变量。</li><li>如何捕获一个类的非静态成员变量。</li><li>Lambda 的返回类型。</li><li>什么是闭包类型。</li><li>怎样将 Lambda 表达式转换成一个函数指针从而能够去使用 C 风格的 API.</li><li>什么是 IIFE 以及为什么它是的有用的。</li><li>如何继承一个 Lambda 表达式。</li></ul><p>让我们出发吧！</p><h3 id="Lambda-表达式的语法"><a href="#Lambda-表达式的语法" class="headerlink" title="Lambda 表达式的语法"></a>Lambda 表达式的语法</h3><p>下图说明了 C++11 中 Lambda 的语法：<br><img src="/images/cpp-lambda-story/lambda_in_c++11.png" alt="C++11 中的 Lambda 语法"></p><p>现在让我们通过几个例子来感受一下它。</p><h4 id="Lambda-表达式的几个例子"><a href="#Lambda-表达式的几个例子" class="headerlink" title="Lambda 表达式的几个例子"></a>Lambda 表达式的几个例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 1. 最简单的 Lambda 表达式：</span><br>[] &#123;&#125;;<br></code></pre></td></tr></table></figure><p>在第一个示例中，你可以看到一个“最迷你”的 Lambda 表达式。它只需要<code>[]</code>部分（Lambda 引入器），然后用空的<code>&#123;&#125;</code>部分作为函数体。形参列表<code>()</code>是可选的，在本例中不需要。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 2. 拥有两个参数的 lambda：</span><br>[] (<span class="hljs-type">float</span> f, <span class="hljs-type">int</span> a) &#123; <span class="hljs-keyword">return</span> a * f; &#125;;<br>[] (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)   &#123; <span class="hljs-keyword">return</span> a &lt; b; &#125;;<br></code></pre></td></tr></table></figure><p>在第二个例子中，可能是最常见的例子了，你可以看到参数都传递到<code>()</code>部分，就像普通函数一样。返回类型不需要，因为编译器会自动推导它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 3. 尾随返回类型：</span><br>[] (MyClass t) -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">auto</span> a = t.<span class="hljs-built_in">compute</span>(); <span class="hljs-built_in">print</span>(a); <span class="hljs-keyword">return</span> a; &#125;;<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们显式地设置了一个返回类型。后面的返回类型也可用在 C++11 以来的常规函数声明中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 4. 额外的说明符：</span><br>[x] (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) <span class="hljs-keyword">mutable</span> &#123; ++x; <span class="hljs-keyword">return</span> a &lt; b; &#125;;<br>[]  (<span class="hljs-type">float</span> param) <span class="hljs-keyword">noexcept</span> &#123; <span class="hljs-keyword">return</span> param * param; &#125;;<br>[x] (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">noexcept</span> &#123; ++x; <span class="hljs-keyword">return</span> a &lt; b; &#125;;<br></code></pre></td></tr></table></figure><p>最后一个示例显示，在 Lambda 的主体之前，可以使用其他说明符。在代码中，我们使用了 <code>mutable</code>（这样我们可以改变捕获的变量）和 <code>noexcept</code>。第三个 Lambda 使用了 <code>mutable</code> 和 <code>noexcept</code>，并且它们必须以该顺序出现（你不能写 <code>noexcept</code> <code>mutable</code>，因为编译器会拒绝它）。</p><p>虽然 <code>()</code> 部分是可选的，但如果你想应用 <code>mutable</code> 或 <code>noexcept</code>，此时 <code>()</code> 则需要在出现的表达中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 5. 可选项</span><br>[x] &#123; std::cout &lt;&lt; x; &#125;; <span class="hljs-comment">// 不需要 ()</span><br>[x] <span class="hljs-keyword">mutable</span> &#123; ++x; &#125;; <span class="hljs-comment">// 无法通过编译！</span><br>[x] () <span class="hljs-keyword">mutable</span> &#123; ++x; &#125;; <span class="hljs-comment">// 可以，mutable 前面的 () 是必要的</span><br>[] <span class="hljs-keyword">noexcept</span> &#123; &#125;; <span class="hljs-comment">// 无法通过编译！</span><br>[] () <span class="hljs-keyword">noexcept</span> &#123; &#125;; <span class="hljs-comment">// 可以</span><br></code></pre></td></tr></table></figure><p>同样的模式也适用于其他可以应用于 Lambdas 的说明符，比如 C++17 中的 <code>constexpr</code> 和 C++20 中的 <code>consteval</code>。</p><p>在熟悉了基本的例子之后，我们现在可以尝试去理解它是如何工作的，并学习 Lambda 表达式的所有可能用法。</p><h3 id="核心定义"><a href="#核心定义" class="headerlink" title="核心定义"></a>核心定义</h3><p>在我们继续之前，从 C++ 标准中引入一些核心定义是很方便的：<br>来自 <a href="https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda#2">[expr.prim.lambda#2]</a></p><div class="note note-info">            <p>Lambda 表达式的计算结果是一个临时的纯右值。这个临时值叫做闭包对象。</p>          </div><p>作为旁注，Lambda 表达式是一个 prvalue 即“纯右值” 。这种类型的表达式通常产生自初始化并出现在赋值的右侧（或在 <code>return</code> 语句中）。阅读 C++ Reference，<a href="https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda#3">[express.prim.lambda#3]</a> 中给出的的另一个定义是：</p><div class="note note-info">            <p>Lambda 表达式的类型（也就是闭包对象的类型）是一个唯一的，未命名的非联合类类型——称为闭包类型。</p>          </div><h4 id="编译器展开"><a href="#编译器展开" class="headerlink" title="编译器展开"></a>编译器展开</h4><p>从以上定义中，我们可以了解到编译器从一个 Lambda 表达式生成唯一的闭包类型。然后我们可以通过这个类型来实例化出闭包对象。</p><p>以下示例展示了如何写一个 Lambda 表达式并将其传给 <code>std::for_each</code>。为了便于比较，代码还说明了编译器生成的相应的函数对象类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_1: Lambda 和 相应的函数对象。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span>&#123;<br>            std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>    &#125; someInstance;<br><br>    <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt; v &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>    std::for_each(v.<span class="hljs-built_in">cbegin</span>(), v.<span class="hljs-built_in">cend</span>(), someInstance);<br>    std::for_each(v.<span class="hljs-built_in">cbegin</span>(), v.<span class="hljs-built_in">cend</span>(), [] (<span class="hljs-type">int</span> x) &#123;<br>            std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>在本例中，编译器将 <code>[](int x) &#123; std::cout &lt;&lt; x &lt;&lt; &#39;\n&#39;; &#125;</code> 翻译成一个匿名函数对象，简化形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125; someInstance;<br></code></pre></td></tr></table></figure><p>“翻译”或“展开”的过程可以很容易地在 <a href="https://cppinsights.io/">C++ Insights</a> 在线网页工具上看到。该工具获取有效的 C++ 代码，然后产生编译器需要的源代码版本：像 Lambda 的匿名函数对象，模板的实例化等其他 C++ 的特性。</p><p>在下一节中，我们将深入研究 Lambda 表达式的各个部分。</p><h3 id="Lambda-表达式的类型"><a href="#Lambda-表达式的类型" class="headerlink" title="Lambda 表达式的类型"></a>Lambda 表达式的类型</h3><p>由于编译器为每个 Lambda （闭包类型）生成唯一的名称，所以我们就没法把它“拼写”在前面。</p><p>这就是为什么必须使用 <code>auto</code>（或 <code>decltype</code>）来推断其类型。<br><code>auto myLambda = [](int a) -&gt; double &#123; return 2.0 * a; &#125;;</code><br>而且，如果你有两个看起来一样的 Lambda：<br><code>auto firstLam = [](int x) &#123; return x * 2; &#125;;</code><br><code>auto secondLam = [](int x) &#123; return x * 2; &#125;;</code><br>它们的类型也是不同的，即使“代码背后”是相同的！编译器需要为这两个 Lambda 声明的每个都生成惟一的匿名类型。我们可以用下面的代码来证明这个属性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_1: 相同的代码，不同的类型。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> oneLam = [](<span class="hljs-type">int</span> x) <span class="hljs-keyword">noexcept</span> &#123; <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>; &#125;;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> twoLam = [](<span class="hljs-type">int</span> x) <span class="hljs-keyword">noexcept</span> &#123; <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>; &#125;;<br>    <span class="hljs-built_in">static_assert</span>(!std::is_same&lt;<span class="hljs-keyword">decltype</span>(oneLam), <span class="hljs-keyword">decltype</span>(twoLam)&gt;::value,<br>                  <span class="hljs-string">&quot;must be different!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子验证了 <code>oneLam</code> 和 <code>twoLam</code> 的闭包类型是否不相同。</p><div class="note note-info">            <p>在 C++17 中我们可以使用无需消息的 <code>static_assert</code> 以及用于类型萃取的辅助变量模板 <code>is_same_v</code>：<code>static_assert(std::is_same_v&lt;double, decltype(baz(10))&gt;);</code></p>          </div><p>然而，虽然你不知道确切的名称，但是你还是可以拼出 Lambda 的签名，然后将其存储在 <code>std::function</code> 中。一般来说，如果 Lambda 是通过<code>std::function&lt;&gt;</code>类型“表示”的，那么它可以完成定义为 <code>auto</code> 的 Lambda 无法完成的任务。例如，前面的 Lambda 具有 <code>double(int)</code> 的签名，因为它接受 <code>int</code> 作为输入参数并返回 <code>double</code>。然后我们可以用以下方法创建 <code>std::function</code> 对象:</p><p><code>std::function&lt;double(int)&gt; myFunc = [](int a) -&gt; double &#123; return 2.0 * a; &#125;;</code></p><p><code>std::function</code> 是一个重量级的对象，因为它需要处理所有可调用对象。要做到这一点，它需要高级的内部机制，如类型双关语，甚至是动态内存分配。我们可以通过一个简单的实验来检验它的大小:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_3: std::function 和 auto 类型推导。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> myLambda = [](<span class="hljs-type">int</span> a) <span class="hljs-keyword">noexcept</span> -&gt; <span class="hljs-type">double</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2.0</span> * a;<br>    &#125;;<br><br>    <span class="hljs-type">const</span> std::function&lt;<span class="hljs-type">double</span>(<span class="hljs-type">int</span>)&gt; myFunc =<br>        [](<span class="hljs-type">int</span> a) <span class="hljs-keyword">noexcept</span> -&gt; <span class="hljs-type">double</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2.0</span> * a;<br>    &#125;;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sizeof(myLambda) is &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(myLambda) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sizeof(myFunc) is &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(myFunc) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">myLambda</span>(<span class="hljs-number">10</span>) == <span class="hljs-built_in">myFunc</span>(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 GCC 编译下代码输出如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">sizeof(myLambda) is 1<br>sizeof(myFunc) is 32<br></code></pre></td></tr></table></figure><p>因为 myLambda 只是一个无状态的 Lambda，所以它也是一个空类，没有任何数据成员字段，所以它的最小大小只有一个字节。另一边的 <code>std::function</code> 版本则要大得多——32 个字节。这就是为什么如果可以的话，应该依靠自动类型推导来获得尽可能小的闭包对象。</p><p>当我们讨论 <code>std::function</code> 时，还需要注意的是，这种类型不是只移型闭包。你可以在 C++14 的可移动的类型章节中阅读关于这个问题的更多信息。</p><h4 id="构造和复制"><a href="#构造和复制" class="headerlink" title="构造和复制"></a>构造和复制</h4><p>在特性规范 [expr.prim.lambda] 里我们 可以读到如下信息：</p><div class="note note-info">            <p>一个 Lambda 表达式关联的闭包类型拥有一个删除的默认构造函数和一个删除的复制赋值运算符。</p>          </div><p>这就是为什么你无法写出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> foo = [&amp;x, &amp;y]() &#123; ++x; ++y; &#125;;<br><span class="hljs-keyword">decltype</span>(foo) fooCopy;<br></code></pre></td></tr></table></figure><p> 在 GCC 上这段代码将出现如下错误提示：<br><img src="/images/cpp-lambda-story/gcc-error.png" alt=" "><br>然而，你可以复制 Lambda：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_4: Copying Lambdas. Live code</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> firstLam = [](<span class="hljs-type">int</span> x) <span class="hljs-keyword">noexcept</span> &#123; <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>; &#125;;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> secondLam = firstLam;<br>    <span class="hljs-built_in">static_assert</span>(std::is_same&lt;<span class="hljs-keyword">decltype</span>(firstLam), <span class="hljs-keyword">decltype</span>(secondLam)&gt;::value,<br>                  <span class="hljs-string">&quot;must be the same&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你复制一个 lambda，那么你也复制了它的状态。当我们讨论捕获变量时，这一点很重要。在该上下文中，闭包类型将捕获的变量存储为成员字段。执行 Lambda 复制将复制这些数据成员字段。</p><div class="note note-info">            <p><strong>展望未来</strong><br>在 C++20 中，无状态 Lambda 将是默认为可构造和可赋值的。</p>          </div><h3 id="调用运算符"><a href="#调用运算符" class="headerlink" title="调用运算符"></a>调用运算符</h3><p>放入 Lambda 体中的代码被“翻译”为对应闭包类型的 <code>operator()</code> 中的代码。</p><p>在 C++11 中，默认情况下它是一个 <code>const inline</code> 成员函数。例如：<br><code>auto lam = [](double param) &#123; /* do something*/ &#125;;</code><br>将会被展开成类似于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__anonymousLambda</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">double</span> param)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">/* do something */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>接下来我们讨论这种方法的结果，以及如何修改生成的调用操作符声明。</p><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>值得一提的是，在定义 Lambda 时，无法创建接受不同参数的“重载” Lambda。如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// doesn&#x27;t compile!</span><br><span class="hljs-keyword">auto</span> lam = [](<span class="hljs-type">double</span> param) &#123; <span class="hljs-comment">/* do something*/</span> &#125;;<br><span class="hljs-keyword">auto</span> lam = [](<span class="hljs-type">int</span>    param) &#123; <span class="hljs-comment">/* do something*/</span> &#125;;<br></code></pre></td></tr></table></figure><p>以上代码无法通过编译，由于编译器无法将这两个 Lambda 翻译到一个函数对象。此外，你不能定义两个相同的变量。然而，创建同一个函数对象中的两个调用运算符的重载却是允许的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyFunctionObject</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">double</span> param)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">/* do something */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span>    param)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">/* do something */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>MyFunctionObject</code> 可以同时接收 <code>double</code> 和 <code>int</code> 这两种参数。如果你需要类似行为的 Lambda，你可以去看关于 Lambda 继承的小节或是 C++17 中的重载模式小节。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>C++11 允许以 <code>[[attr_name]]</code> 的语法去给 Lambda 设置属性。但是，如果将一个属性应用到 Lambda，那么它将应用于调用的类型而不是运算符本身。这就是为什么现在（甚至在 C++20 中）有没有对 Lambda 有意义的属性。大多数编译器甚至会报告错误。如果我们取一个 C++17 的属性，并尝试将它与表达式一起使用：<br><code>auto myLambda = [](int a) [[nodiscard]] &#123; return a * a; &#125;;</code><br>这会在 Clang 上生成以下错误：<br><code>error: &#39;nodiscard&#39; attribute cannot be applied to types</code><br>虽然理论上已经准备好了 Lambda 语法，但目前还没有适用的语法属性。</p><h4 id="其他变化"><a href="#其他变化" class="headerlink" title="其他变化"></a>其他变化</h4><p>我们在语法部分简要介绍了这个主题，但是你并不局限于闭包类型的调用操作符的默认声明。在 C++11 中，你可以添加 <code>mutable</code> 或异常声明符。</p><div class="note note-info">            <p>如果可能的话，本书中较长的例子尝试用 <code>const</code> 标记闭包对象，并使 Lambda noexcept。</p>          </div><p>你可以通过在参数声明子句后面指定 <code>mutable</code> 和 <code>noexcept</code> 来使用这些关键字：<br><code>auto myLambda = [](int a) mutable noexcept &#123; /* do something */ &#125;</code><br>编译器将生成如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__anonymousLambda</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">double</span> param)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-comment">/* do something */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>请注意，<code>const</code> 关键字现在没有了，调用操作符现在可以更改 Lambda 的数据成员。<br>但是什么数据成员呢？如何声明 Lambda 的数据成员？请参阅下一节关于变量的“捕获”：</p><h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><p>方括号 <code>[]</code> 不仅引导了 Lambda 而且还保存了捕获变量的列表。因此，它也被称作“捕获子句”。</p><p>通过从 Lambda 外部作用域捕获一个变量， 你为闭包类型创建了一个非静态数据成员。进而在 Lambda 主体内部，你可以访问到它。</p><p>在 C++98&#x2F;03 章节，我们为 <code>Printer</code> 函数对象做了相似的事情。在那个类里，我添加了一个 <code>std::string</code> 类型的数据成员 <code>strText</code> 并在构造函<br>数中做了初始化。可调用对象拥有一个数据成员使我们能够保存它的状态。</p><p>C++11 中的捕获语法是这样的：</p><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td><code>[&amp;]</code></td><td>通过引用捕获在到达作用域中声明的所有自动存储持续时间变量</td></tr><tr><td><code>[=]</code></td><td>按值捕获(创建副本)在到达范围中声明的所有自动存储持续时间变量</td></tr><tr><td><code>[x, &amp;y]</code></td><td>通过值显式捕获x，通过引用显式捕获 y</td></tr><tr><td><code>[args...]</code></td><td>按值捕获模板参数包</td></tr><tr><td><code>[&amp;args...]</code></td><td>按引用捕获模板参数包</td></tr><tr><td><code>[this]</code></td><td>捕获成员函数内部的 <code>this</code> 指针</td></tr></tbody></table><p>请注意，对于 <code>[=]</code> 和 <code>[&amp;]</code> 情况，编译器会为 Lambda 主体内所有使用的变量生成数据成员。这是一种方便的语法，你不需要显式提及捕获的变量。</p><p>下面是基本语法的总结和示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">2</span>, y = <span class="hljs-number">3</span>;<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> l1 = [] () &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;; <span class="hljs-comment">// 无捕获</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> l2 = [=]() &#123; <span class="hljs-keyword">return</span> x; &#125;; <span class="hljs-comment">// Lambda 中使用的所有变量都会被复制</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> l3 = [&amp;]() &#123; <span class="hljs-keyword">return</span> y; &#125;; <span class="hljs-comment">// Lambda 中使用的所有变量都会被引用</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> l4 = [x]() &#123; <span class="hljs-keyword">return</span> x; &#125;; <span class="hljs-comment">// 仅通过值捕获 x (复制)</span><br><span class="hljs-comment">// const auto lx = [=x]() &#123; return x; &#125;; // 语法错误，显示复制 x 不需要 =</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> l5 = [&amp;y]   () &#123; <span class="hljs-keyword">return</span> y; &#125;; <span class="hljs-comment">// 仅通过引用捕获 y</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> l6 = [x, &amp;y]() &#123; <span class="hljs-keyword">return</span> x * y; &#125;; <span class="hljs-comment">// x 值捕获 y 引用捕获</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> l7 = [=, &amp;x]() &#123; <span class="hljs-keyword">return</span> x + y; &#125;; <span class="hljs-comment">// x 以引用捕获，除此之外都以值捕获</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> l8 = [&amp;,  y]() &#123; <span class="hljs-keyword">return</span> x - y; &#125;; <span class="hljs-comment">// y 以值捕获，除此之外都以引用捕获</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p><strong>什么是“自动存储期”？</strong><br>程序中的所有对象都有四种可能的“存储”方式：automatic（自动存储）、static（静态）、thread（线程）或 dynamic（动态）。自动意味着在作用域开始时分配存储，就像在函数中一样。大多数局部变量都有自动存储期（声明为 <code>static</code>、<code>extern</code> 或 <code>thread_local</code> 的除外）。详见 <a href="https://en.cppreference.com/w/cpp/language/storage_duration">cppreference - storage duration</a>。</p>          </div><p>为了理解捕获一个变量时到底发生了什么，让我们来考虑以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::string str &#123;<span class="hljs-string">&quot;Hello World&quot;</span>&#125;;<br><span class="hljs-keyword">auto</span> foo = [str]() &#123; std::cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; &#125;;<br><span class="hljs-built_in">foo</span>();<br></code></pre></td></tr></table></figure><p>对于上面的 Lambda，<code>str</code> 是按值进行捕获的（也就是被复制）。编译器可能会为此生成如下的局部函数对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_unnamedLambda</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    std::string str;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当你将一个变量传递给捕获子句时，它就被用来直接初始化数据成员 <code>str</code>。所以前面的例子可以“展开”为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::string str &#123;<span class="hljs-string">&quot;Hello World&quot;</span>&#125;;<br>_unnamedLambda foo &#123; str &#125;;<br><span class="hljs-built_in">foo</span>();<br></code></pre></td></tr></table></figure><p>标准详见 <a href="https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda#21">[expr.prim.lambda#21]</a></p><div class="note note-info">            <p>当计算 Lambda 表达式时，使用值捕获的实体直接初始化结果闭包对象的每个相应的非静态数据成员。</p>          </div><p>再来看一个捕获了两个变量的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">1</span>;<br>std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> foo = [&amp;x, &amp;y] <span class="hljs-keyword">noexcept</span> &#123; ++x; ++y; &#125;;<br><span class="hljs-built_in">foo</span>();<br>std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><p>对于以上 Lambda，编译器可能生成如下局部函数对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_unnameLambda</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        ++x; ++y;<br>    &#125;;<br>    <span class="hljs-type">int</span>&amp; x;<br>    <span class="hljs-type">int</span>&amp; y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由于我们按引用捕获了 <code>x</code> 和 <code>y</code>；闭包类型将会包含两个数据成员，而且都是引用。</p><div class="note note-info">            <p>值捕获变量的值是在定义 Lambda 时的值，而不是在调用时的值！引用捕获的变量的值是使用 Lambda 时的值，而不是定义它时的值。</p>          </div><div class="note note-info">            <p>C++ 闭包不会延长捕获的引用的生存期。确保在调用 Lambda 时捕获变量仍然存在。</p>          </div><h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><p>在本书中，我展示了一个可能的编译器生成的代码，作为一个结构体来定义闭包类类型。然而，这只是一种简化——一种理想模型——在编译器内部，情况可能会有所不同。</p><p>例如，对于 Clang，它的抽象语法生成树（AST：Abstract Syntax Tree）就使用类来表示一个闭包。其调用运算符被定义为共有的，而数据成员则被定义为私有的。</p><p>这就是为什么我们无法写出这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> lam = [=]() &#123; std::cout &lt;&lt; x; &#125;;<br>lam.x = <span class="hljs-number">10</span>; <span class="hljs-comment">// ??</span><br></code></pre></td></tr></table></figure><p>在 GCC （在 Clang 与之类似）将会得到如下报错信息：<br><code>error: &#39;struct main()::&lt;lambda()&gt;&#39; has no member named &#39;x&#39;</code></p><p>另一方面，规范的一个重要部分提到，捕获的变量是直接初始化的，这对于私有成员(对于代码中的常规类)是不可能的。这意味着编译器可以在这里发挥一点“魔力”，创建更高效的代码(不需要复制变量，甚至不需要移动它们)。</p><p>如果你想了解更多关于 Lambda 的内部实现细节，请移步至 Andreas Fertig（C++ Insights 的创办人） 的博客：<a href="https://andreasfertig.blog/2020/11/under-the-covers-of-cpp-Lambdas-part-2-captures-captures-captures/">Under the covers of C++ Lambdas - Part 2: Captures, captures, captures</a>。</p><h4 id="捕获所有或显式捕获"><a href="#捕获所有或显式捕获" class="headerlink" title="捕获所有或显式捕获"></a>捕获所有或显式捕获</h4><p>虽然指定 <code>[=]</code> 或 <code>[&amp;]</code> 可能很方便，因为它捕获了所有自动存存储期的变量，然而显式捕获一个变量会更清晰。这样，编译器就可以警告你不想要的效果（例如，请参阅关于全局变量和静态变量的说明）。</p><p>你也可以在 Scott Meyer 著的 《Effective Modern C++》的条款 31：“避免默认捕获模式”了解更多相关信息。</p><h4 id="关键字-mutable"><a href="#关键字-mutable" class="headerlink" title="关键字 mutable"></a>关键字 mutable</h4><p>闭包类型的 <code>operator()</code> 默认被标记为 <code>const</code>，因此你无法在 Lambda 体内改变捕获到的变量值。</p><p>如果你想改变这个行为，你需要在形参列表后面添加 <code>mutable</code> 关键字。这种语法有效地从闭包类型的调用操作符声明中删除了 <code>const</code>。如果你有定义了一个带有 <code>mutable</code> 关键字的 Lambda 表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">auto</span> foo = [x]() <span class="hljs-keyword">mutable</span> &#123; ++x; &#125;;<br></code></pre></td></tr></table></figure><p>它将会被“拓展”成如下函数对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__Lambda_x1</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123; ++x; &#125;<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如你所见，调用运算符重载可以更改成员字段的值了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_5: Capturing Two Variables by Copy and Mutable.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> print = [](<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>        std::cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in main()&quot;</span>, x, y);<br>    <span class="hljs-keyword">auto</span> foo = [x, y, &amp;print]() <span class="hljs-keyword">mutable</span> &#123;<br>        ++x;<br>        ++y;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in foo()&quot;</span>, x, y);<br>    &#125;;<br>    <span class="hljs-built_in">foo</span>();<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in main()&quot;</span>, x, y);<br>&#125;<br><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// in main(): 1 1</span><br><span class="hljs-comment">// in foo(): 2 2</span><br><span class="hljs-comment">// in main(): 1 1</span><br></code></pre></td></tr></table></figure><p>在上例中，我们可以改变 <code>x</code> 和 <code>y</code> 的值。因为它们只是封闭作用域中 <code>x</code> 和 <code>y</code> 的副本，所以在调用 <code>foo</code> 之后我们看不到它们的新值。</p><p>另一方面，如果通过引用捕获，则不需要对 Lambda 应用 <code>mutable</code> 修改该值。这是因为捕获的数据成员是引用，这意味着无论如何都不能将它们绑定到新对象，但可以更改引用的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> foo = [&amp;x]() <span class="hljs-keyword">noexcept</span> &#123; ++x; &#125;;<br><span class="hljs-built_in">foo</span>();<br>std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><p>在上面的例子中，Lambda 没有被指定为 <code>mutable</code>，但是它可以改变被引用的值。</p><p>需要注意的一件重要事情是，当应用 <code>mutable</code> 时，不能用 <code>const</code> 标记生成的闭包对象，因为这会阻止对 Lambda 的调用！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> lam = [x]() <span class="hljs-keyword">mutable</span> &#123; ++x; &#125;<br><span class="hljs-built_in">lam</span>(); <span class="hljs-comment">// 无法编译！</span><br></code></pre></td></tr></table></figure><p>最后一行不能编译，因为不能在 <code>const</code> 对象上调用非 <code>const</code> 成员函数。</p><h4 id="调用计数器——捕获变量的一个例子"><a href="#调用计数器——捕获变量的一个例子" class="headerlink" title="调用计数器——捕获变量的一个例子"></a>调用计数器——捕获变量的一个例子</h4><p>在我们开始讨论关于捕获的更复杂的主体之前，我们可以休息一下，来专注于一个更加实际的例子。</p><p>当你想要使用标准库中的某些现有算法并更改其默认行为时，Lambda 表达式非常方便。例如，对于 <code>std::sort</code> 你可以传入你自己的比较函数。</p><p>但是我们可以更进一步，传入一个有调用计数器的增强版比较函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_6: Invocation Counter.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec &#123; <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span> &#125;;<br>    <span class="hljs-type">size_t</span> compCounter = <span class="hljs-number">0</span>;<br>    std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(),<br>        [&amp;compCounter](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) <span class="hljs-keyword">noexcept</span> &#123;<br>          ++compCounter;<br>        <span class="hljs-keyword">return</span> a &lt; b;<br>      &#125;<br>    );<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;number of comparisons: &quot;</span> &lt;&lt; compCounter   &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; v : vec)<br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例中提供的比较器的工作方式与默认比较器相同，如果 <code>a</code> 小于 <code>b</code>，它将返回，因此我们使用从小到大的自然顺序。然而，传递给 <code>std::sort</code> 的 Lambda 也捕获了一个局部变量 <code>compCounter</code>。然后使用该变量对排序算法中对该比较器的所有调用进行计数。</p><h4 id="捕获全局变量"><a href="#捕获全局变量" class="headerlink" title="捕获全局变量"></a>捕获全局变量</h4><p>如果你试图在你的 Lambda 中使用 <code>[=]</code> 来捕获一个全局变量 ，你可能认为这个全局对象也会以传值的方式被捕获……，但并非如此。看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_7: Capturing Globals.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">int</span> global = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; global &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">auto</span> foo = [=]() <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">noexcept</span> &#123; ++global; &#125;;<br>    <span class="hljs-built_in">foo</span>();<br>    std::cout &lt;&lt; global &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> increaseGlobal = []() <span class="hljs-keyword">noexcept</span> &#123; ++global; &#125;;<br>    <span class="hljs-built_in">increaseGlobal</span>();<br>    std::cout &lt;&lt; global &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> moreIncreaseGlobal = [global]() <span class="hljs-keyword">noexcept</span> &#123;     ++global; &#125;;<br>    <span class="hljs-built_in">moreIncreaseGlobal</span>();<br>    std::cout &lt;&lt; global &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上例中定义了一个全局变量，然后在 <code>main</code> 函数中定义的几个 Lambda 中使用它。如果你运行这段代码，那么无论你以何种方式捕获，它都将始终指<br>向全局对象，并不会创建本地副本。</p><p>这是因为只有具有自动存储期的变量才能被捕获。GCC 甚至可以报出以下警告：<br><code>warning: capture of variable &#39;global&#39; with non-automatic storage duration</code><br>只有在显式捕获全局变量时才会出现此警告，因此如果使用 <code>[=]</code>，编译器也帮不了你。</p><p>Clang 编译器甚至更有帮助，因为它会生成一个错误：<br><code>error: &#39;global&#39; cannot be captured because it does not have automatic storage duration</code></p><h4 id="捕获静态变量"><a href="#捕获静态变量" class="headerlink" title="捕获静态变量"></a>捕获静态变量</h4><p>与捕获全局变量类似，对于静态对象，你也会得到相似的错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_8: Capturing Static Variables.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> static_int = <span class="hljs-number">10</span>;<br>    std::cout &lt;&lt; static_int &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">auto</span> foo = [=]() <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">noexcept</span>&#123; ++static_int; &#125;;<br>    <span class="hljs-built_in">foo</span>();<br>    std::cout &lt;&lt; static_int &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> increase = []() <span class="hljs-keyword">noexcept</span> &#123; ++static_int; &#125;;<br>    <span class="hljs-built_in">increase</span>();<br>    std::cout &lt;&lt; static_int &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> moreIncrease = [static_int]() <span class="hljs-keyword">noexcept</span> &#123;     ++static_int; &#125;;<br>    <span class="hljs-built_in">moreIncrease</span>();<br>    std::cout &lt;&lt; static_int &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">bar</span>();<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// 11</span><br><span class="hljs-comment">// 12</span><br><span class="hljs-comment">// 13</span><br></code></pre></td></tr></table></figure><p>这次，我们尝试捕获一个静态变量，然后更改它的值，但由于它不是自动存储期，编译器无法做到这一点。</p><p>当你通过名称 <code>[static_int]</code> 捕获变量时，GCC 报告一个警告，而 Clang 显示一个错误。</p><h4 id="捕获类成员和-this-指针"><a href="#捕获类成员和-this-指针" class="headerlink" title="捕获类成员和 this  指针"></a>捕获类成员和 this  指针</h4><p>当你在类成员函数中，并且希望捕获数据成员时，事情会变得稍微复杂一些。由于所有非静态数据成员都与 <code>this</code> 指针相关，因此它也必须存储在某个地方。</p><p>看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_9: Error when capturing a data member.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Baz</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> lam = [s]() &#123; std::cout &lt;&lt; s; &#125;;<br>        <span class="hljs-built_in">lam</span>();<br>    &#125;<br>    std::string s;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Baz b;<br>    b.<span class="hljs-built_in">foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码尝试去捕获一个数据成员 s。然而编译器却发出了如下错误信息：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">In member function &#x27;void Baz::foo()&#x27;:<br>error: capture of non-variable &#x27;Baz::s&#x27;<br>error: &#x27;this&#x27; was not captured for this Lambda function<br></code></pre></td></tr></table></figure><p>为了解决这个错误，我们必须捕获 <code>this</code> 指针。之后我们就能访问到数据成员了。</p><p>我们将代码更新为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Baz</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> lam = [<span class="hljs-keyword">this</span>]() &#123; std::cout &lt;&lt; s; &#125;;<br>        <span class="hljs-built_in">lam</span>();<br>    &#125;<br>    std::string s;<br>&#125;;<br></code></pre></td></tr></table></figure><p>现在就没有编译错误了。</p><p>你也可以使用 <code>[=]</code> 或 <code>[&amp;]</code> 去捕获 <code>this</code> 指针（它们在 C++ 11&#x2F;14 中具有相同的效果）。</p><p>请注意，我们通过指针的值捕获了 <code>this</code>。这就是为什么你可以访问初始数据成员，而不是它的副本。</p><p>在 C++11（甚至是 C++14）中你无法这样写：<code>auto lam = [*this]() &#123; std::cout &lt;&lt; s; &#125;</code>这段代码在 C++11&#x2F;14 下无法编译，然而，在 C++17 下可以。</p><p>如果你在单个方法的上下文中使用 Lambda，那么捕获 <code>this</code> 将很好。但是更复杂的情况呢?</p><p>你知道如下代码将会发生什么吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_10: Returning a Lambda From a Method</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Baz</span> &#123;<br>    <span class="hljs-function">std::function&lt;<span class="hljs-title">void</span><span class="hljs-params">()</span>&gt; <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> [=] &#123; std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; &#125;;<br>    &#125;<br>    std::string s;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> f1 = Baz&#123;<span class="hljs-string">&quot;abc&quot;</span>&#125;.<span class="hljs-built_in">foo</span>();<br>    <span class="hljs-keyword">auto</span> f2 = Baz&#123;<span class="hljs-string">&quot;xyz&quot;</span>&#125;.<span class="hljs-built_in">foo</span>();<br>    <span class="hljs-built_in">f1</span>();<br>    <span class="hljs-built_in">f2</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码定义了一个 <code>Baz</code> 对象然后去调用 <code>foo()</code>。请注意 <code>foo()</code> 返回的是一个 Lambda（存储在 <code>std::function</code>）而且它捕获了这个类的一个成员变量。</p><p>由于我们使用了临时对象，因而无法确定当我们调用 <code>f1</code> 和 <code>f2</code> 的时候会发生什么。这是一个悬垂引用问题，会导致未定义行为。类似的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bar</span> &#123;<br>    <span class="hljs-function">std::string <span class="hljs-type">const</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> s; &#125;;<br>    std::string s;<br>&#125;;<br><span class="hljs-keyword">auto</span>&amp;&amp; f1 = Bar&#123;<span class="hljs-string">&quot;abc&quot;</span>&#125;.<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// a dangling reference</span><br></code></pre></td></tr></table></figure><p>如果显式地声明捕获(<code>[s]</code>)，则会得到编译器错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::function&lt;<span class="hljs-title">void</span><span class="hljs-params">()</span>&gt; <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> [s] &#123; std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; &#125;;<br>&#125; <span class="hljs-comment">// error: &#x27;this&#x27; was not captured!</span><br></code></pre></td></tr></table></figure><p>总而言之，当 Lambda 比对象本身活得更久时，捕获这一点可能会变得棘手。当你使用异步调用或多线程时，可能会发生这种情况。</p><p>我们将在 C++17 的章节中回到这个主题。参见“并发执行使用 Lambda”。</p><h4 id="只移对象"><a href="#只移对象" class="headerlink" title="只移对象"></a>只移对象</h4><p>如果你有一个只移对象（例如 <code>unique_ptr</code>），你无法将它作为一个捕获变量移动到 Lambda 内。按值捕获不起作用，你只能按引用去捕获。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>&#125;)</span></span>;<br><span class="hljs-keyword">auto</span> foo = [p]() &#123;&#125;; <span class="hljs-comment">// 无法通过编译</span><br><span class="hljs-keyword">auto</span> foo_ref = [&amp;p]() &#123; &#125;; <span class="hljs-comment">// 通过编译，然而，所有权未能传递</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，你可以看到捕获 <code>unique_ptr</code> 的唯一方法是通过引用。然而，这种方法可能不是最好的，因为它不转移指针的所有权。</p><p>在关于 C++14 的下一章中，你将看到由于使用初始化器捕获，这个问题得到了解决。转到  C++14 章中的“移动”一节，继续了解这个主题。</p><h4 id="常量性的保留"><a href="#常量性的保留" class="headerlink" title="常量性的保留"></a>常量性的保留</h4><p>如果你捕获一个常量，那么常量性会被保留下来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">auto</span> foo = [x] () <span class="hljs-keyword">mutable</span> &#123;<br>        std::cout &lt;&lt; std::is_const&lt;<span class="hljs-keyword">decltype</span>(x)&gt;::value &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        x = <span class="hljs-number">11</span>;<br>    &#125;;<br>    <span class="hljs-built_in">foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码不能编译，因为捕获的变量是常量。下面是本例可能生成的函数对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__Lambda_x</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123; x = <span class="hljs-number">11</span>; <span class="hljs-comment">/*error!*/</span> &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> x;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="捕获参数包"><a href="#捕获参数包" class="headerlink" title="捕获参数包"></a>捕获参数包</h4><p>为了结束对捕获子句的讨论，我们应该提到你还可以利用可变模板来捕获。编译器将包展开为一个非静态数据成员列表，如果你想在模板化代码中使用 Lambda，这可能很方便。例如，下面是一个测试捕获的代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_12: Capturing a Variadic Pack.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">captureTest</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> Lambda = [args...] &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> tup = std::<span class="hljs-built_in">make_tuple</span>(args...);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;tuple size: &quot;</span> &lt;&lt;<br>            std::tuple_size&lt;<span class="hljs-keyword">decltype</span>(tup)&gt;::value &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;tuple 1st: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(tup) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;;<br>    <span class="hljs-built_in">lambda</span>(); <span class="hljs-comment">// call it</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">captureTest</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">captureTest</span>(<span class="hljs-string">&quot;Hello world&quot;</span>, <span class="hljs-number">10.0f</span>);<br>&#125;<br><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// tuple size: 4</span><br><span class="hljs-comment">// tuple 1st: 1</span><br><span class="hljs-comment">// tuple size: 2</span><br><span class="hljs-comment">// tuple 1st: Hello world</span><br></code></pre></td></tr></table></figure><p>这段实验性的代码表明，你可以按值捕获可变参数包（也可以通过引用），然后将该包“存储”到元组对象中。然后在元组上调用一些辅助函数来访问它的数据和属性。</p><p>你也可以使用 C++ Insights 来查看编译器是如何生成代码并将模板、参数包和 Lambda 扩展为代码的。参见这里的示例 <a href="https://cppinsights.io/s/19d3a45d">@C++Insight</a>。</p><h3 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h3><p>在大多数情况下，即便是在 C++11 中，你也可以跳过 Lambda 的返回类型，然后编译器可以为你推断出类型名。</p><p>附注：最初，返回类型推导仅限于函数体中包含单个返回语句的 Lambda。然而，这个限制很快就被取消了，因为实现一个更方便的版本没有问题。</p><p>总而言之，从 C++11 开始，只要所有的返回语句都是相同的类型，编译器就能够推断出返回类型。</p><p>从缺陷报告中我们可以读到以下内容：</p><div class="note note-info">            <p>如果Lambda表达式不包含尾随返回类型，则尾随返回类型表示以下类型:</p><ul><li>如果复合语句中没有 return 语句，或者所有的 return 语句返回一个 void 类型的表达式，或者没有表达式或带括号的 init-list，则类型为 void;</li><li>否则，如果所有的 return 语句都返回一个表达式以及左值到右值转换(7.3.2 [conv.lval])、数组到顶层指针转换(7.3.3 [conv.array])和函数</li><li>到指针转换(7.3.4 .lval)后返回的表达式的类型[conv.func])是相同的，即共同类型</li><li>否则，程序为病式</li></ul>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_13: Return Type Deduction.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> baz = [](<span class="hljs-type">int</span> x) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">20</span>) <span class="hljs-keyword">return</span> x * <span class="hljs-number">1.1</span>;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> x * <span class="hljs-number">2.1</span>;<br>    &#125;;<br>    <span class="hljs-built_in">static_assert</span>(std::is_same&lt;<span class="hljs-type">double</span>, <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">baz</span>(<span class="hljs-number">10</span>))&gt;::value, <span class="hljs-string">&quot;has to be the same!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的 Lambda 中，我们有两个返回语句，但它们都指向 <code>double</code>，因此编译器可以推断出类型。</p><div class="note note-info">            <p>在 C++ 14中，Lambda 的返回类型将被更新，以适应正则函数的自动类型推导规则。参见“返回类型推断”。这样就得到了一个更简单的定义。</p>          </div><h4 id="尾随返回类型语法"><a href="#尾随返回类型语法" class="headerlink" title="尾随返回类型语法"></a>尾随返回类型语法</h4><p>如果你想明确返回类型，可以使用尾随返回类型说明。例如，当你返回一个字符串字面值时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> testSpeedString = [](<span class="hljs-type">int</span> speed) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (speed &gt; <span class="hljs-number">100</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;you&#x27;re a super fast&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;you&#x27;re a regular&quot;</span>;<br>    &#125;;<br>    <span class="hljs-keyword">auto</span> str = <span class="hljs-built_in">testSpeedString</span>(<span class="hljs-number">100</span>);<br>    str += <span class="hljs-string">&quot; driver&quot;</span>; <span class="hljs-comment">// oops! no += on const char*!</span><br>    std::cout &lt;&lt; str;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码无法编译，因为编译器将 <code>const char*</code> 推断为 Lambda 的返回类型。而字符串字面量上没有 <code>+=</code> 操作符，所以代码会中断。</p><p>可以通过显式地将返回类型设置为 <code>std::string</code> 来解决这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> testSpeedString = [](<span class="hljs-type">int</span> speed) -&gt; std::string &#123;<br>    <span class="hljs-keyword">if</span> (speed &gt; <span class="hljs-number">100</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;you&#x27;re a super fast&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;you&#x27;re a regular&quot;</span>;<br>&#125;;<br><span class="hljs-keyword">auto</span> str = <span class="hljs-built_in">testSpeedString</span>(<span class="hljs-number">100</span>);<br>str += <span class="hljs-string">&quot; driver&quot;</span>; <span class="hljs-comment">// works fine</span><br></code></pre></td></tr></table></figure><p>请注意，我们现在必须删除 <code>noexcept</code>，因为 <code>std::string</code> 创建可能会抛出错误。<br>另外，你还可以使用命名空间 <code>std::string_literals</code>; 然后你返回 <code>&quot;you&#39;re a regular&quot;s</code> 表示 <code>std::string</code> 类型。</p><h3 id="转换成一个函数指针"><a href="#转换成一个函数指针" class="headerlink" title="转换成一个函数指针"></a>转换成一个函数指针</h3><p>如果你的 Lambda 并不捕获任何变量，那么编译器可以将其转换成一个常规函数指针。以下是标准对此的详细描述：</p><div class="note note-info">            <p>没有 Lambda 捕获的 Lambda 表达式的闭包类型具有一个公共非虚非显式 <code>const</code> 转换函数，该转换函数指向与闭包类型的函数调用操作符具有相同形参和返回类型的函数。此转换函数返回的值应为函数的地址，该函数在调用时与调用闭包类型的函数调用操作符具有相同的效果。</p>          </div><p>为了说明 Lambda 如何支持这种转换，让我们考虑以下示例。它定义了一个函数对象 <code>baz</code>，该对象显式地定义了转换操作符:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_15: Conversion to a Function Pointer.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callWith10</span><span class="hljs-params">(<span class="hljs-type">void</span>(* bar)(<span class="hljs-type">int</span>))</span> </span>&#123; <span class="hljs-built_in">bar</span>(<span class="hljs-number">10</span>); &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> &#123;<br>        <span class="hljs-keyword">using</span> f_ptr = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>);<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">call</span>(s); &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">f_ptr</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;call; &#125;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123; std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; &#125;;<br>    &#125; baz;<br>    <span class="hljs-built_in">callWith10</span>(baz);<br>    <span class="hljs-built_in">callWith10</span>([](<span class="hljs-type">int</span> x) &#123; std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在前面的程序中，有一个函数 <code>callWith10</code>，它接受一个函数指针。然后我们用两个参数调用它（第 18 行和第 19 行）：第一个使用 <code>baz</code>，它是一个函数对象类型，包含必要的转换操作符—它转换为 <code>f_ptr</code>，这与 <code>callWith10</code> 的输入参数相同。稍后，我们将调用 Lambda 函数。在这种情况下，编译器在下面执行所需的转换。</p><p>当需要调用需要回调的 C 风格函数时，这种转换可能很方便。例如，下面你可以找到从 C 库调用 <code>qsort</code> 并使用 Lambda 以相反顺序对元素排序的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_16: Calling a C-style function.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> values[] = &#123; <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span> &#125;;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> numElements = <span class="hljs-built_in">sizeof</span>(values)/<span class="hljs-built_in">sizeof</span>(values[<span class="hljs-number">0</span>]);<br>    std::<span class="hljs-built_in">qsort</span>(values, numElements, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>),<br>        [](<span class="hljs-type">const</span> <span class="hljs-type">void</span>* a, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* b) <span class="hljs-keyword">noexcept</span> &#123;<br>            <span class="hljs-built_in">return</span> ( *(<span class="hljs-type">int</span>*)b - *(<span class="hljs-type">int</span>*)a );<br>        &#125;<br>    );<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; val : values)<br>        std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如你所见，使用 <code>std::qsort</code>，它只接受函数指针作为比较器。编译器可以对我们传递的无状态 Lambda 进行隐式转换。</p><h4 id="棘手的情况"><a href="#棘手的情况" class="headerlink" title="棘手的情况"></a>棘手的情况</h4><p>在我们进入另一个话题之前，还有一个案例可能会很有趣：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_17: Plus and a lambda.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> funcPtr = +[]&#123;&#125;;<br>    <span class="hljs-built_in">static_assert</span>(std::is_same&lt;<span class="hljs-keyword">decltype</span>(funcPtr), <span class="hljs-built_in">void</span> (*)()&gt;::value);<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意 <code>+</code> 的奇怪语法。如果删除加号，则 <code>static_assert</code> 失败。为什么呢?<br>为了理解它是如何工作的，我们可以看看 C++ Insights 项目生成的输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> FuncPtr_4 = <span class="hljs-built_in">void</span> (*)();<br>FuncPtr_4 funcPtr = +<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-built_in">void</span> (*)()&gt;(__la.<span class="hljs-keyword">operator</span> __la::<span class="hljs-built_in">retType_4_18</span>());<br><span class="hljs-comment">/* PASSED: static_assert(std::integral_constant&lt;bool, 1&gt;::value); */</span><br><span class="hljs-comment">// __la is __Lambda_4_18 in cppinsights</span><br></code></pre></td></tr></table></figure><p>代码使用 <code>+</code>，这是一个一元操作符。该操作符可以操作指针，因此编译器将无状态 Lambda 转换为函数指针，然后将其赋值给 <code>funcPtr</code>。</p><p>另一方面，如果去掉加号，那么 <code>funcPtr</code> 就只是一个普通的闭包对象，这就是 <code>static_assert</code> 失败的原因。</p><p>虽然用 <code>+</code> 来编写这样的语法可能不是最好的主意，但是如果用 <code>static_cast</code>，效果是一样的。在不希望编译器创建太多函数实例化的情况下，可以应用此技术。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_18: Casting to a Function Pointer.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call_function</span><span class="hljs-params">(F f)</span> </span>&#123; <span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>); &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">call_function</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-built_in">int</span> (*)(<span class="hljs-type">int</span>)&gt;([](<span class="hljs-type">int</span> x)&#123;<span class="hljs-keyword">return</span> x + <span class="hljs-number">2</span>;&#125;));<br>    <span class="hljs-built_in">call_function</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-built_in">int</span> (*)(<span class="hljs-type">int</span>)&gt;([](<span class="hljs-type">int</span> x)&#123;<span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>;&#125;));<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，编译器只需要创建一个 <code>call_function</code> 的实例，因为它只接受一个函数指针 <code>int (*)(int)</code>。但是如果你去掉 <code>static_cast</code>，那么你将得到两个版本的 <code>call_function</code>，因为编译器必须为 Lambdas 创建两个不同的类型。</p><h3 id="IIFE-——-立即调用的函数表达式"><a href="#IIFE-——-立即调用的函数表达式" class="headerlink" title="IIFE —— 立即调用的函数表达式"></a>IIFE —— 立即调用的函数表达式</h3><p>到目前为止，在你看到的大多数示例中，你可以注意到我定义了一个 Lambda，然后在稍后调用它。</p><p>然而，你也可以立即调用 Lambda：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_19: Calling Lambda Immediately.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">1</span>;<br>    [&amp;]() <span class="hljs-keyword">noexcept</span> &#123; ++x; ++y; &#125;(); <span class="hljs-comment">// &lt;-- call ()</span><br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; y;<br>&#125;<br></code></pre></td></tr></table></figure><p>正如你在上面看到的，Lambda 被创建并且没有被赋值给任何闭包对象。然后用 <code>()</code> 调用它。如果你运行这个程序，你可以期望看到 <code>2, 2</code> 作为输出。当你对 <code>const</code> 对象进行复杂的初始化时，这种表达式可能很有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> val = []() &#123;<br>  <span class="hljs-comment">/* several lines of code... */</span><br>&#125;(); <span class="hljs-comment">// call it!</span><br></code></pre></td></tr></table></figure><p>以上代码中，val 是一个由 Lambda 表达式返回的某种类型的常量。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// val1 is int</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> val1 = []() &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>; &#125;();<br><span class="hljs-comment">// val2 is std::string</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> val2 = []() -&gt; std::string &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ABC&quot;</span>; &#125;();<br></code></pre></td></tr></table></figure><p>下面你可以找到一个更长的例子，我们使用 IIFE 作为辅助 Lambda 来在函数中创建一个常量值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_20: IIFE and HTML Generation.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ValidateHTML</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp;)</span> </span>&#123; &#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">BuildAHref</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; link, <span class="hljs-type">const</span> std::string&amp; text)</span> </span>&#123;<br>    <span class="hljs-type">const</span> std::string html = [&amp;link, &amp;text] &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; inText = text.<span class="hljs-built_in">empty</span>() ? link : text;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;a href=\&quot;&quot;</span> + link + <span class="hljs-string">&quot;\&quot;&gt;&quot;</span> + inText + <span class="hljs-string">&quot;&lt;/a&gt;&quot;</span>;<br>    &#125;(); <span class="hljs-comment">// call!</span><br>    <span class="hljs-built_in">ValidateHTML</span>(html);<br>    <span class="hljs-keyword">return</span> html;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> ahref = <span class="hljs-built_in">BuildAHref</span>(<span class="hljs-string">&quot;www.leanpub.com&quot;</span>, <span class="hljs-string">&quot;Leanpub Store&quot;</span>);<br>        std::cout &lt;&lt; ahref;<br>    &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;bad format...&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子包含一个函数 <code>BuildAHref</code>，它接受两个参数，然后构建一个 <code>&lt;a&gt; &lt;/a&gt;</code> HTML 标记。基于输入参数，我们构建 html 变量。如果文本不为空，则使用它作为内部 HTML 值。否则，我们使用链接。我们希望 <code>html</code>变量为 <code>const</code>，但是很难编写具有输入参数所需条件的紧凑代码。多亏了 IIFE，我们可以编写一个单独的 Lambda，然后用 <code>const</code> 标记变量。稍后，可以将该变量传递给 <code>ValidateHTML</code>。</p><h4 id="关于可读性的一个注意事项"><a href="#关于可读性的一个注意事项" class="headerlink" title="关于可读性的一个注意事项"></a>关于可读性的一个注意事项</h4><p>有时，立即调用 Lambda 可能会导致一些可读性问题。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> EnableErrorReporting = [&amp;]() &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">HighLevelWarningEnabled</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">MidLevelWarningEnabled</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">UsersWantReporting</span>(); <span class="hljs-comment">// depends on user settings...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;();<br><br><span class="hljs-keyword">if</span> (EnableErrorReporting) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，Lambda 代码非常复杂，阅读代码的开发人员不仅要破译 Lambda 是立即调用的，还要推断 <code>EnableErrorReporting</code> 类型。他们可能会假设 <code>EnableErrorReporting</code> 是闭包对象，而不仅仅是一个 <code>const</code> 变量。对于这种情况，你可以考虑不使用 <code>auto</code>，以便我们可以很容易地看到类型。甚至可以在 <code>&#125;()</code> 旁边添加注释，比如 &#x2F;&#x2F; 立即调用。</p><div class="note note-info">            <p>关于升级版的 IIFE，你可以在 C++17 章节了解到更多。</p>          </div><h3 id="从-Lambda-继承"><a href="#从-Lambda-继承" class="headerlink" title="从 Lambda 继承"></a>从 Lambda 继承</h3><p>这可能令人惊讶，但你确实可以从 Lambda 派生！</p><p>由于编译器使用 <code>operator()</code> 将 Lambda 表达式展开为函数对象，因此我们可以从这个类型继承。</p><p>来看一个基础的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_21: Inheriting from a single lambda.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Callable&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComplexFn</span> : <span class="hljs-keyword">public</span> Callable &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ComplexFn</span><span class="hljs-params">(Callable f)</span> : Callable(f) &#123;</span>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Callable&gt;<br><span class="hljs-function">ComplexFn&lt;Callable&gt; <span class="hljs-title">MakeComplexFunctionObject</span><span class="hljs-params">(Callable&amp;&amp; cal)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ComplexFn</span>&lt;Callable&gt;(std::forward&lt;Callable&gt;(cal));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> func = <span class="hljs-built_in">MakeComplexFunctionObject</span>([]() &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;Hello Complex Function Object!&quot;</span>;<br>    &#125;);<br>    <span class="hljs-built_in">func</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>ComplexFn</code> 类是从 <code>Callable</code> 派生出来的，<code>Callable</code> 是一个模板参数。如果我们想从 Lambda 中派生，我们需要一点小技巧，因为我们不能拼写出闭包类型的确切类型（除非我们将其包装到 <code>std::function</code> 中）。</p><p>这就是为什么我们需要 <code>MakeComplexFunctionObject</code> 函数来执行模板参数推导并获得 Lambda 闭包的类型。</p><p>除了它的名字，<code>ComplexFn</code> 只是一个简单的包装器，没有太多的用途。这样的代码模式有什么用例吗?</p><p>例如，我们可以扩展上面的代码，从两个 Lambdas 继承并创建一个重载集合：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_22: Inheriting from two Lambdas.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> TCall, <span class="hljs-keyword">typename</span> UCall&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleOverloaded</span> : <span class="hljs-keyword">public</span> TCall, UCall &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SimpleOverloaded</span>(TCall tf, UCall uf) : <span class="hljs-built_in">TCall</span>(tf), <span class="hljs-built_in">UCall</span>(uf) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-title">TCall::operator</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-title">UCall::operator</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> TCall, <span class="hljs-keyword">typename</span> UCall&gt;<br><span class="hljs-function">SimpleOverloaded&lt;TCall, UCall&gt; <span class="hljs-title">MakeOverloaded</span><span class="hljs-params">(TCall&amp;&amp; tf, UCall&amp;&amp; uf)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">SimpleOverloaded</span>&lt;TCall, UCall&gt;(std::forward&lt;TCall&gt; tf, std::forward&lt;UCall&gt; uf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> func = <span class="hljs-built_in">MakeOverloaded</span>(<br>        [](<span class="hljs-type">int</span>) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Int!\n&quot;</span>; &#125;,<br>        [](<span class="hljs-type">float</span>) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Float!\n&quot;</span>; &#125;<br>    );<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10.0f</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这次我们有更多的代码:我们从两个模板形参派生，但是我们还需要显式地公开它们的调用操作符。</p><p>为什么呢?这是因为在寻找正确的函数重载时，编译器要求候选函数在相同的作用域内。</p><p>为了理解这一点，让我们编写一个从两个基类派生的简单类型。该示例还注释掉了两个 <code>using</code> 语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_23: Deriving from two classes, error.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BaseInt</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;BaseInt...\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BaseDouble</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;BaseDouble...\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> BaseInt, BaseDouble &#123;<br>    <span class="hljs-comment">// using BaseInt::Func;</span><br>    <span class="hljs-comment">// using BaseDouble::Func;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    d.<span class="hljs-built_in">Func</span>(<span class="hljs-number">10.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们有两个实现 <code>Func</code> 的基类。我们想从派生对象调用那个方法。</p><p>GCC 报告以下错误：<br><code>error: request for member &#39;Func&#39; is ambiguous</code><br>因为我们注释掉了 <code>using</code> 语句 <code>::Func()</code> 可以来自 <code>BaseInt</code> 或 <code>BaseDouble</code> 的作用域。编译器有两个作用域来搜索最佳候选，根据标准，这是不允许的。</p><p>那么，让我们回到我们的主要用例：SimpleOverloaded 是一个基本类，它还不能用于生产环境。请参阅 C++17 章节，在那里我们将讨论该模式的高级版本。由于 C++17 的一些特性，我们将能够从多个 Lambdas 继承（多亏了可变模板）并语法更加紧凑。</p><h3 id="存储-Lambda-到容器"><a href="#存储-Lambda-到容器" class="headerlink" title="存储 Lambda 到容器"></a>存储 Lambda 到容器</h3><p>作为本章的最后一项技术，让我们看一下在容器中存储闭包的问题。</p><p>但是我不是写过不能默认创建和赋值 Lambda 吗?</p><p>是的，但是，我们可以在这里做一些戏法。</p><p>其中一种技术是利用无状态 Lambda 转换为函数指针的属性。虽然不能直接存储闭包对象，但可以保存从 Lambda 表达式转换而来的函数指针。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_24: Storing Lambdas As Function Pointers.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> TFunc = <span class="hljs-built_in">void</span> (*)(<span class="hljs-type">int</span>&amp;);<br>    std::vector&lt;TFunc&gt; ptrFuncVec;<br><br>    ptrFuncVec.<span class="hljs-built_in">push_back</span>([](<span class="hljs-type">int</span>&amp; x) &#123; std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; &#125;);<br>    ptrFuncVec.<span class="hljs-built_in">push_back</span>([](<span class="hljs-type">int</span>&amp; x) &#123; x *= <span class="hljs-number">2</span>; &#125;);<br>    ptrFuncVec.<span class="hljs-built_in">push_back</span>(ptrFuncVec[<span class="hljs-number">0</span>]); <span class="hljs-comment">// print it again;</span><br><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;entry : ptrFuncVec)<br>        <span class="hljs-built_in">entry</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们创建了用来存储变量的函数指针的向量。容器中有三个条目：</p><ul><li>第一个打印输入变量的值。</li><li>第二个更改它的值。</li><li>第三个复制自第一个，因此它也打印值。</li></ul><p>以上解决方案可以工作，但仅限于无状态 Lambda。如果我们想解除这个限制呢?<br>为了解决这个问题，我们可以使用求助于 <code>std::function</code>。为了使示例更有趣，它还以简单的整数转换为处理 <code>std::string</code> 对象的 Lambda 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex2_25: Storing Lambdas As std::function.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::function&lt;std::string(<span class="hljs-type">const</span> std::string&amp;)&gt;&gt; vecFilters;<br>    <span class="hljs-type">size_t</span> removedSpaceCounter = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> removeSpaces = [&amp;removedSpaceCounter](<span class="hljs-type">const</span> std::string&amp; str) &#123;<br>        std::string tmp;<br>        std::<span class="hljs-built_in">copy_if</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">back_inserter</span>(tmp),<br>                   [](<span class="hljs-type">char</span> ch) &#123;<span class="hljs-keyword">return</span> !<span class="hljs-built_in">isspace</span>(ch); &#125;);<br>        removedSpaceCounter += str.<span class="hljs-built_in">length</span>() - tmp.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;;<br><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> makeUpperCase = [](<span class="hljs-type">const</span> std::string&amp; str) &#123;<br>        std::string tmp = str;<br>        std::<span class="hljs-built_in">transform</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>(), tmp.<span class="hljs-built_in">begin</span>(),<br>                       [](<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c)&#123; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">toupper</span>(c); &#125;);<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;;<br><br>    vecFilters.<span class="hljs-built_in">emplace_back</span>(removeSpaces);<br>    vecFilters.<span class="hljs-built_in">emplace_back</span>([](<span class="hljs-type">const</span> std::string&amp; x) &#123;<span class="hljs-keyword">return</span> x + <span class="hljs-string">&quot; Amazing&quot;</span>; &#125;);<br>    vecFilters.<span class="hljs-built_in">emplace_back</span>([](<span class="hljs-type">const</span> std::string&amp; x) &#123;<span class="hljs-keyword">return</span> x + <span class="hljs-string">&quot; Modern&quot;</span>; &#125;);<br>    vecFilters.<span class="hljs-built_in">emplace_back</span>([](<span class="hljs-type">const</span> std::string&amp; x) &#123;<span class="hljs-keyword">return</span> x + <span class="hljs-string">&quot; C++&quot;</span>; &#125;);<br>    vecFilters.<span class="hljs-built_in">emplace_back</span>([](<span class="hljs-type">const</span> std::string&amp; x) &#123;<span class="hljs-keyword">return</span> x + <span class="hljs-string">&quot; World!&quot;</span>; &#125;);<br>    vecFilters.<span class="hljs-built_in">emplace_back</span>(makeUpperCase);<br><br>    <span class="hljs-type">const</span> std::string str = <span class="hljs-string">&quot; H e l l o &quot;</span>;<br>    <span class="hljs-keyword">auto</span> temp = str;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;entryFunc : vecFilters)<br>        temp = <span class="hljs-built_in">entryFunc</span>(temp);<br>    std::cout &lt;&lt; temp;<br>    std::cout &lt;&lt;<span class="hljs-string">&quot;\nremoved spaces: &quot;</span> &lt;&lt; removedSpaceCounter &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// HELLO AMAZING MODERN C++ WORLD!</span><br><span class="hljs-comment">// removed spaces: 12</span><br></code></pre></td></tr></table></figure><p>这次我们将 <code>std::function&lt;std::string(const std::string&amp;)&gt;</code> 存储在容器中。</p><p>这允许我们使用任何类型的函数对象，包括带有捕获变量的 Lambda 表达式。其中一个 Lambda <code>removeSpacesCnt</code> 捕获一个变量，该变量用于存储有关从输入字符串中删除的空格的信息。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本章中，你学习了如何创建和使用 Lambda 表达式。我描述了语法、捕获子句、Lambda 的类型，并介绍了许多示例和用例。我们甚至更进一步，我给你们展示了一种派生自 Lambda 的模式或者把它存储在一个容器里。</p><p>但这还不是全部！</p><p>Lambda 表达式已经成为现代 C++ 的重要组成部分。有了更多的用例，开发人员也看到了改进这个特性的可能性。这就是为什么你现在可以转到下一章，看看 ISO 委员会在 C++14 中添加的重要更新。</p><h2 id="C-14-中的-Lambda"><a href="#C-14-中的-Lambda" class="headerlink" title="C++14 中的 Lambda"></a>C++14 中的 Lambda</h2><p>C++14 对 Lambda 表达式增加了两个重要的功能：</p><ul><li>带初始化器的捕获</li><li>泛型 Lambda</li></ul><p>此外，该标准还更新了一些规则，例如：</p><ul><li>Lambda 的默认参数</li><li>以 <code>auto</code> 作为返回类型</li></ul><p>这些特性可以解决 C++11 中出现的几个问题。你可以在 N4140 和 Lambdas 中查看相关细节。此外，在本章，你将会了解到：</p><ul><li>捕获非静态数据成员</li><li>用现代的技术替代旧的函数风格工具，如 <code>std::bind1st</code></li><li>LIFTING 惯用法</li><li>递归 Lambda</li></ul><h3 id="Lambda-的默认参数"><a href="#Lambda-的默认参数" class="headerlink" title="Lambda 的默认参数"></a>Lambda 的默认参数</h3><p>让我们从一些较小的更新开始：</p><p>在 C++14 中，可以在函数调用中使用默认参数。这是一个小功能，但可以使 Lambda 更像一个常规函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Ex3_1: Lambda with Default Parameter.</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> lam = [](<span class="hljs-type">int</span> x = <span class="hljs-number">10</span>) &#123; std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; &#125;;<br>    <span class="hljs-built_in">lam</span>();<br>    <span class="hljs-built_in">lam</span>(<span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上例中，我们调用了 Lambda 两次。第一次没有传入任何参数，因此它使用了默认值 <code>x = 10</code>。第二次我们传入了 <code>100</code>。</p><p>有趣的是 GCC 和 CLang 编译器早在 C++11 时就支持该特性了。</p><h3 id="返回类型推导"><a href="#返回类型推导" class="headerlink" title="返回类型推导"></a>返回类型推导</h3><p>如之前章节所述，简单 Lambda 表达式的返回类型可由编译器自动推导。C++14 将这一特性扩展至常规函数，允许使用 <code>auto</code> 作为返回类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-built_in">computeX</span>(...);<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> y = <span class="hljs-built_in">computeY</span>(...);<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于以上代码，编译器将会推导出 <code>int</code> 作为返回类型。</p><p>对于 Lambda 表达式而言，C++14 意味着它们遵循与 <code>auto</code> 返回类型函数相同的规则。我们查看标准文档 [expr.prim.lambda#4] 中的定义：</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>特性</tag>
      
      <tag>语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 初始化的故事</title>
    <link href="/2023/08/03/cpp-initialization-story/"/>
    <url>/2023/08/03/cpp-initialization-story/</url>
    
    <content type="html"><![CDATA[<h2 id="关于本书"><a href="#关于本书" class="headerlink" title="关于本书"></a>关于本书</h2><p>在 C++ 中，初始化是一个热门话题！互联网上充满了关于最佳实践的讨论，甚至还有关于这个主题的有趣的表情包。这种情况并不奇怪，因为有十几种方法可以初始化一个简单的整数值、有自动类型推断的复杂规则、数据成员和对象生命周期的细微差别。</p><p>于是，出现了这本书。</p><p>通过本文，你将学习在现代 C++ 中初始化各种类型的变量和数据成员的实用选项。具体来说，本书教授了多种类型的初始化、构造函数、非静态数据成员初始化、内联变量、指定初始化器等。此外，你将看到从 C++11 到 C++20 的变化和新技术，以及大量的示例来加强你的理解。</p><p>计划是解释初始化的大部分(如果不是全部的话)，学习许多优秀的 C++ 技术，并了解底层到底发生了什么。</p><span id="more"></span><h3 id="为什么你需要阅读本书？"><a href="#为什么你需要阅读本书？" class="headerlink" title="为什么你需要阅读本书？"></a>为什么你需要阅读本书？</h3><p>使用现代 C++（从 C++11 开始），我们有许多新特性来简化工作和代码。改进的一个方面是初始化。现代 C++ 增加了新的初始化规则，试图在保持旧行为（主要来自 C 语言）兼容性的同时简化初始化。然而，有时规则可能看起来令人困惑和复杂，甚至 ISO 委员会也可能需要在此过程中纠正一些事情。这本书将帮助你浏览这些原则，以更好地理解这个主题。更重要的是，初始化只是本文的一个方面。你将学习有关类、构造函数、析构函数、对象生命周期的所有相关主题，甚至是编译器在启动时如何处理数据。</p><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><p>我们的目标是让你掌握以下知识：</p><ul><li>解释关于对象初始化的规则，包括常规变量、数据成员和非局部对象。</li><li>如何实现特殊的成员函数(构造函数、析构函数、复制&#x2F;移动操作)以及它们何时有用。</li><li>如何使用 C++11 特性有效地初始化非静态数据成员，如非静态数据成员初始化、继承和委托构造函数。</li><li>如何利用 C++17 的内联变量来简化静态变量和静态数据成员的初始化工作。</li><li>如何处理类似容器的成员、不可复制的数据成员（如 const 数据成员）或只可移动的数据成员，甚至 lambda 表达式。</li><li>在 C++20 中，什么是聚合类以及如何用指定初始化器创去建这样的对象。</li></ul><h3 id="本书的组织结构"><a href="#本书的组织结构" class="headerlink" title="本书的组织结构"></a>本书的组织结构</h3><h3 id="目标读者"><a href="#目标读者" class="headerlink" title="目标读者"></a>目标读者</h3><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h3 id="读者反馈以及勘误"><a href="#读者反馈以及勘误" class="headerlink" title="读者反馈以及勘误"></a>读者反馈以及勘误</h3><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><h3 id="代码版权"><a href="#代码版权" class="headerlink" title="代码版权"></a>代码版权</h3><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><h3 id="语法高亮显示限制"><a href="#语法高亮显示限制" class="headerlink" title="语法高亮显示限制"></a>语法高亮显示限制</h3><h3 id="特殊章节"><a href="#特殊章节" class="headerlink" title="特殊章节"></a>特殊章节</h3><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><h2 id="1-局部变量和简单类型"><a href="#1-局部变量和简单类型" class="headerlink" title="1. 局部变量和简单类型"></a>1. 局部变量和简单类型</h2><h2 id="2-用构造函数进行初始化"><a href="#2-用构造函数进行初始化" class="headerlink" title="2. 用构造函数进行初始化"></a>2. 用构造函数进行初始化</h2><h2 id="3-复制和移动操作"><a href="#3-复制和移动操作" class="headerlink" title="3. 复制和移动操作"></a>3. 复制和移动操作</h2><h2 id="4-委托构造函数和继承构造函数"><a href="#4-委托构造函数和继承构造函数" class="headerlink" title="4. 委托构造函数和继承构造函数"></a>4. 委托构造函数和继承构造函数</h2><h2 id="5-析构函数"><a href="#5-析构函数" class="headerlink" title="5. 析构函数"></a>5. 析构函数</h2><h2 id="6-类型推导和初始化"><a href="#6-类型推导和初始化" class="headerlink" title="6. 类型推导和初始化"></a>6. 类型推导和初始化</h2><h2 id="7-1-到-6-章快速总结"><a href="#7-1-到-6-章快速总结" class="headerlink" title="7. 1 到 6 章快速总结"></a>7. 1 到 6 章快速总结</h2><h2 id="8-非静态成员的初始化"><a href="#8-非静态成员的初始化" class="headerlink" title="8. 非静态成员的初始化"></a>8. 非静态成员的初始化</h2><h2 id="9-将容器作为数据成员"><a href="#9-将容器作为数据成员" class="headerlink" title="9. 将容器作为数据成员"></a>9. 将容器作为数据成员</h2><h2 id="10-非正规数据成员"><a href="#10-非正规数据成员" class="headerlink" title="10. 非正规数据成员"></a>10. 非正规数据成员</h2><h2 id="11-非局部对象"><a href="#11-非局部对象" class="headerlink" title="11. 非局部对象"></a>11. 非局部对象</h2><h2 id="12-C-20-中的聚合初始化和指定初始化"><a href="#12-C-20-中的聚合初始化和指定初始化" class="headerlink" title="12. C++20 中的聚合初始化和指定初始化"></a>12. C++20 中的聚合初始化和指定初始化</h2><h2 id="13-技术和用例"><a href="#13-技术和用例" class="headerlink" title="13. 技术和用例"></a>13. 技术和用例</h2><h2 id="14-测验和习题"><a href="#14-测验和习题" class="headerlink" title="14. 测验和习题"></a>14. 测验和习题</h2><h2 id="附录-A-特殊成员函数的生成规则"><a href="#附录-A-特殊成员函数的生成规则" class="headerlink" title="附录 A - 特殊成员函数的生成规则"></a>附录 A - 特殊成员函数的生成规则</h2><h2 id="附录-B-习题参考答案"><a href="#附录-B-习题参考答案" class="headerlink" title="附录 B - 习题参考答案"></a>附录 B - 习题参考答案</h2><h2 id="引用和参考"><a href="#引用和参考" class="headerlink" title="引用和参考"></a>引用和参考</h2>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
      <category>翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>特性</tag>
      
      <tag>语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离骚</title>
    <link href="/2023/08/02/hello-blog/"/>
    <url>/2023/08/02/hello-blog/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/hello-blog/QuYuan.png" alt=" "></p><h2 id="离骚"><a href="#离骚" class="headerlink" title="离骚"></a>离骚</h2><p>[先秦]屈原</p><p><strong>【原文】</strong><br>帝高阳之苗裔兮<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="帝：帝之本义为花蒂或胚胎，引申为始生之祖。">[1]</span></a></sup>，朕皇考曰伯庸。摄提贞于孟陬兮，惟庚寅吾以降。皇览揆余初度兮，肇锡余以嘉名。名余曰正则兮，字余曰灵均。纷吾既有此内美兮，又重之以修能。扈江离与辟芷兮，纫秋兰以为佩。汩余若将不及兮，恐年岁之不吾与。朝搴阰之木兰兮，夕揽洲之宿莽。日月忽其不淹兮，春与秋其代序。惟草木之零落兮，恐美人之迟暮。不抚壮而弃秽兮，何不改此度？乘骐骥以驰骋兮，来吾道夫先路！</p><p><strong>【译文】</strong><br>我是远祖高阳氏的后裔啊，我父亲的名字叫伯庸。岁星正好运行到寅年正月啊，我呱呱降生。父亲端详我初生时的气度啊，从那时起他赐予我这贞祥的名字：他给我起名叫正则啊，起字作灵均。我欢喜自己刚出生已有如此众多的惠质啊，又加上具有出众的才能。披戴着江离和幽香的白芷啊，缀结秋兰作为腰间配饰。我快速前行看似追寻不上目标啊，担心岁月不再留给我更多的时间！早上拔取坡地上的木兰啊，傍晚采摘水洲中的宿莽。日月倏忽不返从不停下脚步啊，春天与秋天季节在更替。想到草木都要凋零啊，就怕楚王步入衰残的暮年。为什么不趁着壮年抛弃污秽啊，就此改变你的态度？骑上骏马奔驰吧！来吧，我在前面为你开路！</p><hr><p><strong>【原文】</strong><br>昔三后之纯粹兮，固众芳之所在。杂申椒与菌桂兮，岂惟纫夫蕙茝？彼尧舜之耿介兮，既遵道而得路。何桀纣之猖披兮，夫唯捷径以窘步。惟夫党人之偷乐兮，路幽昧以险隘。岂余身之惮殃兮，恐皇舆之败绩。忽奔走以先后兮，及前王之踵武。荃不查余之中情兮，反信谗而齌怒。余固知謇謇之为患兮，忍而不能舍也。指九天以为正兮，夫唯灵修之故也。曰黄昏以为期兮，羌中道而改路。初既与余成言兮，后悔遁而有他。余既不难夫离别兮，伤灵修之数化。</p><p><strong>【译文】</strong><br>从前楚国三位贤王德行完美、纯正无私啊，因而成为群贤毕集的所在。花椒与菌桂聚集一处啊，缀结的何止蕙和？尧舜光大圣明啊，他们遵行正道使国家走上正途。桀纣一样荒乱偏邪啊，贪图近便小径以致走投无路。结党营私之徒享乐啊，国家的前途晦暗不明危险难行。难道我是害怕自身遭受灾殃吗？我是怕君王的车子遭到颠覆。我匆促奔走于君王鞍前马后啊，希望他能追踪先王的足迹。君王却不明察我内心的真情啊，反而轻信了谗言而勃然大怒。我本来就知道正道直行会引起祸患啊，宁可忍受痛苦却无法改变初衷。手指天地作为我起誓的明证啊，这都是因为君王的缘故。说好在黄昏时分相约会面的啊，走到半路又中途改道。当初已经跟我订下誓约啊，随后又反悔另有他求。我已不再为君臣分隔而难过啊，只是哀惋君王朝令夕改。</p><hr><p><strong>【原文】</strong><br>余既滋兰之九畹兮，又树蕙之百亩。畦留夷与揭车兮，杂杜衡与芳芷。冀枝叶之峻茂兮，愿竢时乎吾将刈。虽萎绝其亦何伤兮，哀众芳之芜秽。众皆竞进以贪婪兮，凭不厌乎求索。羌内恕己以量人兮，各兴心而嫉妒。忽驰骛以追逐兮，非余心之所急。老冉冉其将至兮，恐修名之不立。朝饮木兰之坠露兮，夕餐秋菊之落英。苟余情其信姱以练要兮，长顑颔亦何伤？擥木根以结茝兮，贯薜荔之落蕊。矫菌桂以纫蕙兮，索胡绳之纚纚。謇吾法夫前修兮，非世俗之所服。虽不周于今之人兮，愿依彭咸之遗则。</p><p><strong>【译文】</strong><br>我栽下了九豌的兰花啊，又种上了百亩的蕙草。将芍药和揭车分畦种植啊，其间兼有马蹄香和白芷。希望它们枝繁叶茂啊，我愿等待时机将它们采摘。即使枯黄凋落又有何伤感啊，悲哀的是这许多花草变成遍地荒棘！众人都争名逐利、贪得无厌啊，孜孜以求从不满足。他们以自己的心肠来猜度我啊，各自私念丛生又充满妒忌。急切奔跑追逐名利啊，并不是我的心中所求。人生暮景渐渐就要降临啊，我担心的是人生的美名没有树立！早上啜饮木兰上滴下的露水啊，傍晚含咀坠落的秋菊。只要我的情志美好，精纯如一啊，长久以来的神形消损又怎值得悲戚！持取木根绕结蓝花啊，将薜荔刚绽放的花心联结成串。使菌桂变直并缀结上蕙草啊，再把胡绳绞合起来而彰显飘逸身姿。我效法前贤的装束啊，并非流俗之辈所能服习。即使不能迎合当世的人啊，我愿依从彭咸留下的范型！</p><hr><p><strong>【原文】</strong><br>长太息以掩涕兮，哀民生之多艰。余虽好修姱以鞿羁兮，謇朝谇而夕替。既替余以蕙纕兮，又申之以揽茝。亦余心之所善兮，虽九死其犹未悔。怨灵修之浩荡兮，终不察夫民心。众女嫉余之蛾眉兮，谣诼谓余以善淫。固时俗之工巧兮，偭规矩而改错。背绳墨以追曲兮，竞周容以为度。忳郁邑余侘傺兮，吾独穷困乎此时也。宁溘死以流亡兮，余不忍为此态也。鸷鸟之不群兮，自前世而固然。何方圜之能周兮，夫孰异道而相安？屈心而抑志兮，忍尤而攘诟。伏清白以死直兮，固前圣之所厚。</p><p><strong>【译文】</strong><br>长长地叹息我掩面拭泪啊，感伤人生的道路是多么的艰难。我虽爱好美德却遭受羁縻啊，早上向君王进谏傍晚就被废弃。废弃我的原因是因为我身佩蕙草啊，又加上我用兰苣作为佩饰。它们都是我心头之好啊，为此即使万死我也不后悔。埋怨怀王行事荒唐啊，终究不明察我的忠心。女人们都嫉恨我美丽的容貌啊，恶语中伤说我善于淫逸。本来流俗善于取巧啊，背弃原则篡改措施。违反标准并无原则啊，争相迎合讨好且以之为常行之法。忧郁压抑我失意不乐啊，偏偏独有我受困于时。宁肯突然死去形体不存啊，我不忍心作出那副样子！鸷鸟高飞远走、卓特不群啊，先世以来就一向如此。圆凿方衲如何能够互容啊，谁可以道不同却彼此相安？委屈本心压抑情志啊，包容过错含垢忍耻。坚持清白之躯为正义而死啊，那才是先贤们所珍视的事。</p><hr><p><strong>【原文】</strong><br>悔相道之不察兮，延伫乎吾将反。回朕车以复路兮，及行迷之未远。步余马于兰皋兮，驰椒丘且焉止息。进不入以离尤兮，退将复修吾初服。制芰荷以为衣兮，集芙蓉以为裳。不吾知其亦已兮，苟余情其信芳。高余冠之岌岌兮，长余佩之陆离。芳与泽其杂糅兮，唯昭质其犹未亏。忽反顾以游目兮，将往观乎四荒。佩缤纷其繁饰兮，芳菲菲其弥章。民生各有所乐兮，余独好修以为常。虽体解吾犹未变兮，岂余心之可惩？</p><p><strong>【译文】</strong><br>悔恨选择道路时未曾看清啊，站在那里久久凝望而后我就要回返。调转我的车头重归正确的路啊，趁误入迷途还不是太远。让我的马漫步在长满兰花的湿地上啊，跑到遍是椒树的土坡上在那里休憩。进谏不被君王接纳却承受过错啊，我将隐退重新穿回当初的衣冕。裁制菱叶作为上衣啊，缀合莲花以作下裙。没有人理解我也就算了吧，只要我的情志真正高洁芳郁。加高我的帽子使之显得危耸啊，加长我的佩剑使之更加奇诡斑斓。芳香和腐臭混杂在一处啊，只有明洁的品质尚未缺损。倏忽间回首远望啊，我将去四方荒远之地游览。戴上众多华美的佩饰啊，浓郁的芳香使它们更加耀眼。人生各有各的乐事啊，我偏好美洁已习惯成自然。即使躯体分解我也不会改变啊，我的心中还有何畏惧？</p><hr><p><strong>【原文】</strong><br>女嬃之婵媛兮，申申其詈予，曰：鲧婞直以亡身兮，终然夭乎羽之野。汝何博謇而好修兮，纷独有此姱节？薋菉葹以盈室兮，判独离而不服。众不可户说兮，孰云察余之中情？世并举而好朋兮，夫何茕独而不予听。</p><p><strong>【译文】</strong><br>女嬃满心痛彻啊，重重责骂我。她说鲧因为刚直而遭流放啊，最后幽殁在羽山的郊野。你为什么还博采众芳而爱好美洁啊，美好的节操显得如此与众不同！蒺藜、枣草、地葵充满屋子啊，你却迥异于众人偏偏不肯佩用在身上。不可能向每个人都详尽说明心中的想法啊，谁能明白我们内心的真诚呢？世人相互推举而好朋比为奸啊，你为什么茕然独立却不听我的劝告。</p><hr><p><strong>【原文】</strong><br>依前圣以节中兮，喟凭心而历兹。济沅、湘以南征兮，就重华而敶词：启《九辩》与《九歌》兮，夏康娱以不顾难以图后兮，五子用失乎家衖。羿淫游以佚畋兮，又好射夫封狐。固乱流其鲜终兮，浞又贪夫厥家。浇身被服强圉兮，纵欲而不忍。日康娱而自忘兮，厥首用夫颠陨。夏桀之常违兮，乃遂焉而逢殃。后辛之菹醢兮，殷宗用而不长。汤、禹俨而祗敬兮，周论道而莫差。举贤才而授能兮，循绳墨而不颇。天无私阿兮，览民德焉错辅。夫维圣哲以茂行兮，苟得用此下土。瞻前而顾后兮，相观民之计极。夫孰非义而可用兮？孰非善而可服？阽余身而危死兮，览余初其犹未悔。不量凿而正枘兮，固前修以菹醢。曾歔欷余郁邑兮，哀朕时之不当。揽茹蕙以掩涕兮，沾余襟之浪浪。</p><p><strong>【译文】</strong><br>依从先贤的价值标准进行评判啊，满怀感喟为何遭此厄运。渡过沅、湘向南进发啊，到帝舜跟前大声陈说：夏启创制《九歌》《九辩》啊，恣意寻欢作乐以致放纵堕落。不顾念先王创业艰难并为后代打算啊，五位王公因此内讧相争。后羿过度沉溺于狩猎啊，又喜欢射杀大猪以取乐。本来恣肆妄行就没有好下场啊，寒浞夺权又占有了他的妻子。浇恃强尚武啊，放纵欲念不肯放弃糜烂生活。每天沉浸于燕舞笙歌浑然忘我啊，他的头颅因此而掉落。夏桀所行与常情有违啊，最后终究遭受了灾祸。纣王辛发明将人剁成肉酱的酷刑啊，殷商因而不能国祚绵长。大禹庄穆而敬畏神灵啊，周详地施行仁政而没有差错。推举贤德、任用能臣啊，遵守法则而不偏颇。上苍不会偏袒谁啊，视民心向背加以辅佐。只有贤达睿智﹑德行充盛啊，才能拥有这整个天下。回顾历史展望将来啊，考察人世治变的道理。谁不是因为忠义而被任用啊，谁不是因为纯良美好而成为奉行的楷模！我身陷危难几蹈死地啊，静观初心从未后悔。不度量凿孔而选用合适的榫头啊，这本是前贤被剁成肉末的原因。我频频悲叹抑郁忧伤啊，哀惋自己生不逢时。拿起柔软蕙草掩面痛哭啊，泪珠滚滚滑落打湿我的前襟。</p><hr><p><strong>【原文】</strong><br>跪敷衽以陈辞兮，耿吾既得此中正。驷玉虬以椉鹥兮，溘埃风余上征。朝发轫于苍梧兮，夕余至乎县圃。欲少留此灵琐兮，日忽忽其将暮。吾令羲和弭节兮，望崦嵫而勿迫。路曼曼其修远兮，吾将上下而求索。饮余马于咸池兮，总余辔乎扶桑。折若木以拂日兮，聊逍遥以相羊。前望舒使先驱兮，后飞廉使奔属。鸾皇为余先戒兮，雷师告余以未具。吾令凤鸟飞腾兮，继之以日夜。飘风屯其相离兮，帅云霓而来御。纷总总其离合兮，斑陆离其上下。吾令帝阍开关兮，倚阊阖而望予。时暧暧其将罢兮，结幽兰而延伫。世溷浊而不分兮，好蔽美而嫉妒。</p><p><strong>【译文】</strong><br>衣襟铺开跪着慷慨陈辞啊﹐我得到无私正道心中豁然通明。驾驭四条无角玉龙所拉的凤车啊，倏忽间我依托风云直上天空。早上从苍梧出发啊，傍晚到县圃停歇。我打算在神门前稍歇片刻啊，日头渐渐偏移入暮。我让羲和徐徐前行啊，看到崎糍山暂且止步。前途漫长遥远无边啊，我将上天入地寻求出路。在咸池饮我的马啊，将马缰系在扶桑神木。攀折若木遮蔽日光啊，姑且逍遥徜徉自由自在。使月神望舒在前面开路啊，让风伯奔跑于后。早有鸾凤为我戒严道路啊，雷神却告诉我严装未备。我命凤鸟们腾翔于九天啊，日以继夜不得疏忽。暴风骤集欲使队伍离散啊，统率着前来迎接的云雾。来势盛大忽散忽聚啊，上下翻转光彩夺目。我命天帝的看门人打开天门啊，他却倚靠在天门外视而不见。此刻光线暗淡日将西落啊，只得编结幽兰长久停驻。世道混乱良莠不分啊，喜欢掩蔽贤才妄加嫉妒。</p><hr><p><strong>【原文】</strong><br>朝吾将济于白水兮，登阆风而绁马。忽反顾以流涕兮，哀高丘之无女。溘吾游此春宫兮，折琼枝以继佩。及荣华之未落兮，相下女之可诒。吾令丰隆乘云兮，求宓妃之所在。解佩纕以结言兮，吾令謇修以为理。纷总总其离合兮，忽纬繣其难迁。夕归次于穷石兮，朝濯发乎洧盘。保厥美以骄傲兮，日康娱以淫游。虽信美而无礼兮，来违弃而改求。览相观于四极兮，周流乎天余乃下。望瑶台之偃蹇兮，见有娀之佚女。吾令鸩为媒兮，鸩告余以不好。雄鸠之鸣逝兮，余犹恶其佻巧。心犹豫而狐疑兮，欲自适而不可。凤皇既受诒兮，恐高辛之先我。</p><p><strong>【译文】</strong><br>早上我将渡过白水啊，登上阆风山系马驻足。忽然回首眺望潸然泪下啊，哀伤楚地高丘没有美女。我迅疾游历青帝所居之春宫啊，攀折那琼枝来补充我的佩饰。趁着缤纷的花草还未零落啊，我寻访美女赠送给她。我让雷神驾云而去啊，探寻宓妃所在的居处。解下佩戴的香囊来订下誓约啊，我命蹇修来当媒人。纷繁盛多来去不定啊，善变乖戾难以迁就。晚上回穷石过宿啊，早上在浦盘濯洗秀发。倚仗她的美貌心骄气傲啊，每天安然享乐游玩无度。虽然她确实美丽却缺乏礼教啊，回来吧蹇修，让我们丢开她再去别处寻求。察考天下四方啊，绕天巡行后我降临下土。望见玉台高拔耸立啊，我看到有娀氏的美丽公主。我命鸩去为我作媒啊，鸩告诉我她的种种不好。雄鸠高叫着远去啊，它轻佻讨巧实在令我厌恶。犹豫不定狐疑满腹啊，我打算亲自造访又不合礼数。凤凰虽已接受信物啊，又怕帝喾比我提前一步。</p><hr><p><strong>【原文】</strong><br>欲远集而无所止兮，聊浮游以逍遥。及少康之未家兮，留有虞之二姚。理弱而媒拙兮，恐导言之不固。世溷浊而嫉贤兮，好蔽美而称恶。闺中既以邃远兮，哲王又不寤。怀朕情而不发兮，余焉能忍而与此终古。</p><p><strong>【译文】</strong><br>想在远方栖身却无处落脚啊，姑且漫游天地飘荡不前。趁少康还未成家啊，有虞氏的二姚尚待字闺中。使者无能媒人拙劣啊，恐怕无法传达心曲不能让人信服。时世混乱嫉恨贤良啊，喜欢遮蔽美善称扬邪恶。宫闱如此深远啊，明君却偏不觉悟！怀有我这样的衷情却不能舒泄啊，我怎能强忍郁闷抱恨过此一生？</p><hr><p><strong>【原文】</strong><br>索琼茅以筳篿兮，命灵氛为余占之。曰两美其必合兮，孰信修而慕之？思九州之博大兮，岂唯是其有女？曰勉远逝而无狐疑兮，孰求美而释女？何所独无芳草兮，尔何怀乎故宇？世幽昧以昡曜兮，孰云察余之善恶。民好恶其不同兮，惟此党人其独异。户服艾以盈要兮，谓幽兰其不可佩。览察草木其犹未得兮，岂珵美之能当。苏粪壤以充祎兮，谓申椒其不芳。欲从灵氛之吉占兮，心犹豫而狐疑。巫咸将夕降兮，怀椒糈而要之。百神翳其备降兮，九疑缤其并迎。皇剡剡其扬灵兮，告余以吉故。曰勉升降以上下兮，求矩矱之所同。汤、禹俨而求合兮，挚、咎繇而能调。苟中情其好修兮，又何必用夫行媒？说操筑于傅岩兮，武丁用而不疑。吕望之鼓刀兮，遭周文而得举。宁戚之讴歌兮，齐桓闻以该辅。及年岁之未晏兮，时亦犹其未央。恐鹈鴂之先鸣兮，使夫百草为之不芳。何琼佩之偃蹇兮，众薆然而蔽之。惟此党人之不谅兮，恐嫉妒而折之。时缤纷其变易兮，又何可以淹留？兰芷变而不芳兮，荃蕙化而为茅。何昔日之芳草兮，今直为此萧艾也？岂其有他故兮，莫好修之害也！余以兰为可恃兮，羌无实而容长。委厥美以从俗兮，苟得列乎众芳。椒专佞以慢慆兮，樧又欲充夫佩帏。既干进而务入兮，又何芳之能祗？固时俗之流从兮，又孰能无变化？览椒兰其若兹兮，又况揭车与江离？惟兹佩之可贵兮，委厥美而历兹。芳菲菲而难亏兮，芬至今犹未沬。和调度以自娱兮，聊浮游而求女。及余饰之方壮兮，周流观乎上下。</p><p><strong>【译文】</strong><br>取竹片、茅叶来卜筮啊，命灵氛为我占知。他说两种美好事物一定能会合啊，哪个真正美好的人不会招人思慕？想一想九州之地的广大啊，难道只有这里才有美女存在？他说勉力远走不要迟疑啊，哪个真心追求美好的人会把你放弃？哪里没有芬芳的花草啊，你为何必单恋旧居？世道昏暗使人迷乱啊，谁说能明察我心的善恶！人的好恶尺度有别啊，只有这些党徒们格外令人不可思议。家家户户将艾草挂满腰间啊，说幽谷香兰不能作佩饰。察考选用的草木都不得当啊，难道能公正地衡量玉石的美质？拾取粪土装满香囊啊，他们说大椒毫不芳馨。我打算听从灵氛吉祥的卜辞啊，心里却还怀疑彷徨。巫咸傍晚就要降临啊，我怀揣香粽前往迎候。众神遮天蔽日纷纷降临啊，九嶷山灵纷纷也来迎接。煌煌威灵神光特显啊，他们告诉我灵氛吉卜的缘故。我上天入地周游四方啊，只为寻求君臣间同心戮力。汤禹虔敬求索与己合德的贤臣啊，伊尹、皋陶得以与之调和共济。只要内心崇尚修洁啊，又何必用那使臣来进行沟通。傅说在傅岩操杵筑土啊，武丁任用他毫无猜疑。吕尚挥刀屠肉啊，遇到文王而得到重用。宁戚击牛角高歌啊，齐桓公听到后让其入朝辅弼。趁年龄还不算老大啊，时机还未尽失。唯恐鹣鸠早早啼叫啊，使花卉凋零黯淡了芳香。为何玉佩那么卓然高贵啊，人们却群起把它光芒遮蔽？只有这些党徒不诚信啊，恐怕会出于嫉妒将它摧折伤害。时代纷乱变幻莫测啊，又有什么理由长期逗留？兰草、白芷被同化而不香醇啊，荃、蕙变得与茅草无异。为什么曾经的香草啊，如今竟与白蒿、艾草同处一地！难道还有别的缘由吗？这是不喜好修洁带来的危害！我以为兰草可以依靠啊，却不知它华而不实只是外貌修颀。委弃它的美好而随波逐流啊，荀且偷生得以列入芳香花草的行列！椒专断谄佞飞扬跋扈啊，搽又想混进人们佩带的香囊里。既然一心只想钻营汲汲于名位啊，又怎能对芳华本有的品格抱有敬意？本来时俗就随大流啊，谁又能固持原则坚定不移。看到椒和兰也是这样啊，又何况揭车和江离？想到这佩饰如此可贵啊，它的美质遭人唾弃竟到如此田地。我的香囊芬芳浓郁难以消损啊，馨香至今还未散去。调节自我以求欢娱啊，姑且飘浮观览寻找知己。趁我恰当年富力强啊，巡行天地上下游历。</p><hr><p><strong>【原文】</strong><br>灵氛既告余以吉占兮，历吉日乎吾将行。折琼枝以为羞兮，精琼爢以为粻。为余驾飞龙兮，杂瑶象以为车。何离心之可同兮？吾将远逝以自疏。邅吾道夫昆仑兮，路修远以周流。扬云霓之晻蔼兮，鸣玉鸾之啾啾。朝发轫于天津兮，夕余至乎西极。凤皇翼其承旗兮，高翱翔之翼翼。忽吾行此流沙兮，遵赤水而容与。麾蛟龙使梁津兮，诏西皇使涉予。路修远以多艰兮，腾众车使径待。路不周以左转兮，指西海以为期。屯余车其千乘兮，齐玉轪而并驰。驾八龙之婉婉兮，载云旗之委蛇。抑志而弭节兮，神高驰之邈邈。奏《九歌》而舞《韶》兮，聊假日以媮乐。陟升皇之赫戏兮，忽临睨夫旧乡。仆夫悲余马怀兮，蜷局顾而不行。</p><p>乱曰：已矣哉！国无人莫我知兮，又何怀乎故都！既莫足与为美政兮，吾将从彭咸之所居。</p><p><strong>【译文】</strong><br>灵氛已告诉我吉祥的卦辞啊，选好良辰我即将出行。攀折琼枝当作美味啊，精制玉屑作为点心。为我驾起奔腾的龙车啊，珠玉象牙缀饰车身。离心离德如何能同归一途啊，我将远走离开故国。调转车头我取道昆仑啊，路途遥远绕四方巡行。张扬云霓旌旗遮天蔽日啊，玉铃啾啾作响发出清鸣。早上由天河渡口出发啊，晚上我要到达日落的西方。凤旗庄严肃穆连绵不断啊，高高飞翔凌空舒展。我快行走到流沙地带啊，沿赤水岸边徘徊不前。指挥蛟龙在渡口间架起浮桥啊，命少眸帮我涉险过关。路途遥远艰险重重啊，传令众车径直侍候身边。路经不周山转而向左啊，遥指西海作相会地点。聚集我的车队足有千驾啊，使玉轮一起并驾齐驱。驾乘八匹龙马蜿蜒飞驰啊，载着迎风飞舞的绘有云霓的旗帜。气定神闲徐缓前进啊，神思飞扬超越无边。弹奏《九歌》应和《韶》乐而舞啊，姑且借这辰光娱乐身心。登临光明浩大的苍天啊，忽然向下一瞥看到楚地故园。车夫悲伤我马哀恋啊，徘徊不前无限顾念。</p><p>尾声：算了吧，国中没有贤士，无人理解我啊，又何必苦苦眷恋我的故国？既然没有谁能与我一起致力于政治革新啊，我将追随彭咸到他栖息的居所。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>帝：帝之本义为花蒂或胚胎，引申为始生之祖。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>文艺</category>
      
      <category>诗歌</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摘抄</tag>
      
      <tag>楚辞</tag>
      
      <tag>古典</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
