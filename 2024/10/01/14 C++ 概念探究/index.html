<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++ 概念简介 | 奇点创客</title><meta name="author" content="奇点创客"><meta name="copyright" content="奇点创客"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++ 模板不仅具备强大的泛化能力，自身也是一种“图灵完备”的语言，掀起了 C++ 之父 Bjarne Stroustrup 自己都没料到的“模板元编程”这一子领域。 但是，使用模板做泛型编程，最大的问题就是缺少良好的接口，一旦使用过程中出现偏差，报错信息我们难以理解，甚至无从下手。更糟的是，使用模板的代码几乎无法做到程序 ABI 层面兼容。这些问题的根本原因是 C++ 语言本身缺乏模板参数约束能">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 概念简介">
<meta property="og:url" content="https://qidianmaker.github.io/2024/10/01/14%20C++%20%E6%A6%82%E5%BF%B5%E6%8E%A2%E7%A9%B6/index.html">
<meta property="og:site_name" content="奇点创客">
<meta property="og:description" content="C++ 模板不仅具备强大的泛化能力，自身也是一种“图灵完备”的语言，掀起了 C++ 之父 Bjarne Stroustrup 自己都没料到的“模板元编程”这一子领域。 但是，使用模板做泛型编程，最大的问题就是缺少良好的接口，一旦使用过程中出现偏差，报错信息我们难以理解，甚至无从下手。更糟的是，使用模板的代码几乎无法做到程序 ABI 层面兼容。这些问题的根本原因是 C++ 语言本身缺乏模板参数约束能">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qidianmaker.github.io/img/14/cover.png">
<meta property="article:published_time" content="2024-10-01T14:58:52.000Z">
<meta property="article:modified_time" content="2025-07-19T14:26:00.165Z">
<meta property="article:author" content="奇点创客">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="特性">
<meta property="article:tag" content="模板">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qidianmaker.github.io/img/14/cover.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++ 概念简介",
  "url": "https://qidianmaker.github.io/2024/10/01/14%20C++%20%E6%A6%82%E5%BF%B5%E6%8E%A2%E7%A9%B6/",
  "image": "https://qidianmaker.github.io/img/14/cover.png",
  "datePublished": "2024-10-01T14:58:52.000Z",
  "dateModified": "2025-07-19T14:26:00.165Z",
  "author": [
    {
      "@type": "Person",
      "name": "奇点创客",
      "url": "https://qidianmaker.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/website/favicon.png"><link rel="canonical" href="https://qidianmaker.github.io/2024/10/01/14%20C++%20%E6%A6%82%E5%BF%B5%E6%8E%A2%E7%A9%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'medium_zoom',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ 概念简介',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/website/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博闻强识</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/read/"><i class="fa-fw fa fa-book"></i><span> 读书</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li><li><a class="site-page child" href="/travel/"><i class="fa-fw fa-solid fa-umbrella-beach"></i><span> 旅行</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-tools"></i><span> 工具</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa-solid fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/14/top.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/website/favicon.png" alt="Logo"><span class="site-name">奇点创客</span></a><a class="nav-page-title" href="/"><span class="site-name">C++ 概念简介</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博闻强识</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/read/"><i class="fa-fw fa fa-book"></i><span> 读书</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li><li><a class="site-page child" href="/travel/"><i class="fa-fw fa-solid fa-umbrella-beach"></i><span> 旅行</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-tools"></i><span> 工具</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa-solid fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++ 概念简介</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-01T14:58:52.000Z" title="发表于 2024-10-01 22:58:52">2024-10-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-19T14:26:00.165Z" title="更新于 2025-07-19 22:26:00">2025-07-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/C/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">26.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>90分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>C++ 模板不仅具备强大的泛化能力，自身也是一种“图灵完备”的语言，掀起了 C++ 之父 Bjarne Stroustrup 自己都没料到的“模板元编程”这一子领域。</p>
<p>但是，使用模板做泛型编程，最大的问题就是缺少良好的接口，一旦使用过程中出现偏差，报错信息我们难以理解，甚至无从下手。更糟的是，使用模板的代码几乎无法做到程序 ABI 层面兼容。这些问题的根本原因是 C++ 语言本身缺乏模板参数约束能力，因此，既能拥有良好接口、高性能表达泛化，又能融入语言本身是非常困难的。</p>
<p>好在 C++20 标准及其后续演进中，为我们带来了 Concepts 核心语言特性变更来解决这一难题。那么它能为我们的编程体验带来多大的革新？能解决多少模板元编程的历史遗留问题？今天我们一起探究 Concepts。</p>
<h2 id="第-1-章-概念和约束的历史"><a href="#第-1-章-概念和约束的历史" class="headerlink" title="第 1 章 概念和约束的历史"></a>第 1 章 概念和约束的历史</h2><p>早在 1987 年，C++ 之父 Bjarne Stroustrup 就着手为模板参数设置合适的接口。长期以来，模板参数没有任何约束，仅仅在实例化的时候才能发现类型上的错误。他希望模板拥有如下三大特点：</p>
<ul>
<li>强大的泛化、表达能力。</li>
<li>相对于手写代码做到零成本开销。</li>
<li>良好的接口。</li>
</ul>
<p>目前看来 C++ 做到了前两点，强大的泛化与表达能力具备“图灵完备”的能力，能够在编译时完成大量计算任务，同时生成的代码拥有比手写更高的性能，在提供前所未有的灵活性的前提下并没有性能损失，这使得模板特性非常成功。</p>
<p>20 世纪 90 年代，泛型编程因 C++ 中的标准模板库而成为主流，开发人员也开始在库开发中广泛使用泛型编程手段。使用模板做泛型编程过程中遇到的问题是缺少良好的接口，导致编译错误信息非常难读，这困扰了开发人员许多年。除了错误信息不够友好之外，在阅读使用模板元编程的库时面对大量模板参数，在不深入实现的前提下也常常不知为何物。语言上的缺陷导致后来产生 <code>enable_if</code> 等变通方法。</p>
<p>包括 C++ 之父在内的许多人都在寻求解决方案，尤其是标准委员会的成员希望该方案能够在 C++0x 版本落地，但直到后来的 C++17 版本也都没能实现。没有人能够提出一种既能满足这三种目标，又能合适地融于语言，并且编译速度足够快的方案。</p>
<p>好在 C++20 起对 concept 特性进行了标准化，目前主流的编译器也提供了支持。concept 的名字由 STL 之父 Alex Stepanov 命名，将一类数据类型和对它的一组操作所满足的公理集称为 concept：不仅需要从语法上满足要求，还需要从语义层面上满足。</p>
<p>几十年来，计算机科学一直在追求软件重用的目标。有多种方法，但没有一种方法能像其他工程学科中的类似尝试那样成功。泛型编程提供了机会。它基于这样一个原则，即软件可以分解为组件，这些组件只对其他组件做出最小的假设（concept），从而得到允许组合的最大灵活性。</p>
<p>泛型编程的关键在于高度可复用的组件必须以 concept 为基础进行编程，而 concept 尽可能匹配更多的类型，并且要求在不牺牲性能的前提下完成这一任务。标准模板库就是基于少量广泛有用的概念，使得用户能够通过各种方式与它们灵活组合。因此，concept 是泛型编程的基石。</p>
<p>本章将详细介绍 C++ 的 concept 特性发展过程，从中我们能看到语言设计者们需要面临与考虑的问题。</p>
<h3 id="1-1-1994-年（早期想法）"><a href="#1-1-1994-年（早期想法）" class="headerlink" title="1.1 1994 年（早期想法）"></a>1.1 1994 年（早期想法）</h3><p>1994 年，在 Bjarne Stroustrup 的著作 <em>The Design and Evolution of C++</em> 中提到了两种对模板参数的约束方案，分别是继承形式和依据表达式的形式。</p>
<h4 id="1-1-1-继承方案"><a href="#1-1-1-继承方案" class="headerlink" title="1.1.1 继承方案"></a>1.1.1 继承方案</h4><p>该方案是通过继承方式来表达约束的，使用和声明类同样的语法，然后在模板定义的时候将模板参数派生自约束类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    T&amp;  <span class="keyword">operator</span>= (<span class="type">const</span> T&amp;);</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>==(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;);</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;);</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span> : Comparable&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span> &#123; <span class="comment">/*...*/</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码中我们声明了约束类 Comparable，它对模板参数的要求为能够进行复制、判等、比较操作，然后在定义模板类 vector 的时候，使用继承语法 T: Comparable 表明模板参数被约束。</p>
<p>这种方式有个几个问题，首先是滥用继承，由于约束被设计成类，因此想要表达约束，使用继承这个特性也合理，但对于表达“模板参数必须支持某些操作”与“模板参数派生自某些约束”的情况而言，后者是一种不灵活的表达方式，而且会导致继承的滥用。除此之外基础类型无法使用继承特性，那么模板参数也就对基础类型封闭，它仅限于用户自定义类型。继承通常表达 subtype 关系，而不是所有的约束都需要硬塞进继承体系中。</p>
<p>其次是它混淆了编程语言中的不同层次的概念：concept 与抽象类，前者是静态的函数而后者是动态的概念，上述实现方式使得它们无法被区分。最后的问题是这种方式不够灵活，由于约束类中声明了一系列函数原型，而这些原型是严格匹配的，这就无法适用于隐式类型转换与函数重载等场景；严格匹配也限制了该方法的灵活性，且存在过约束的问题。</p>
<h4 id="1-1-2-基于表达式使用"><a href="#1-1-2-基于表达式使用" class="headerlink" title="1.1.2 基于表达式使用"></a>1.1.2 基于表达式使用</h4><p>下述代码方案是依据表达式使用的形式，它比继承的方式灵活得多，能够解决隐式类型转换和函数重载的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">constraints</span><span class="params">(T* tp)</span> </span>&#123; <span class="comment">// 要求模板参数 T 必须满足：</span></span><br><span class="line">        B* bp =tp;            <span class="comment">// 能够进行隐式类型转换到基类 B</span></span><br><span class="line">        tp-&gt;<span class="built_in">f</span>();              <span class="comment">// 存在成员函数 f</span></span><br><span class="line">        <span class="function">T <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;               <span class="comment">// 能够通过 int 类型构造该类</span></span><br><span class="line">        a = *tp;              <span class="comment">// 支持拷贝构造</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方式无须添加任何语言上的支持，但代码的编写取决于编译器实现。早期的 C++ 编译器 Cfront 会检查所有函数的语法，若模板参数不符合要求，constraints 函数将产生语法错误，用户通过错误信息找到函数 constraints 的实现便能得知对类型上的约束。而现代主流的编译器仅对被调用的函数进行代码生成，那么就要求用户使用的时候对 constraints 函数进行调用，这加重了用户的负担。</p>
<p>从这个例子我们能够看出缺少语言上的支持，那么会产生很多变通方案，包括第 10 章介绍的一些技巧。对于这个问题 Bjarne Stroustrup 想到了提供关键字 constraints 来编写约束，并且在函数调用前进行自动调用检查。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">constraints &#123;</span><br><span class="line">    T* tp; <span class="comment">// 要求模板参数 T 必须满足</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123; <span class="comment">/*...*/</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>这种方案基本不会对模板参数过约束，同时也能满足一定程度的泛化、简洁与可理解性，并且容易实现。</p>
<h3 id="1-2-2003-年（初步设计）"><a href="#1-2-2003-年（初步设计）" class="headerlink" title="1.2 2003 年（初步设计）"></a>1.2 2003 年（初步设计）</h3><p>对模板参数进行约束的想法持续到了 2003 年。Bjarne Stroustrup 在他的论文 Conceptchecking 中进一步细化并提出了 4 种解决方案。</p>
<h4 id="1-2-1-虚基类方式"><a href="#1-2-1-虚基类方式" class="headerlink" title="1.2.1 虚基类方式"></a>1.2.1 虚基类方式</h4><p>该方案与最初的继承方案不同，它完全采用虚函数机制。使用继承的好处是容易理解且不需要增加额外的语法符号，并且可视作面向对象方式的语法糖，降低了编译器实现的难度。另一个的好处是可以将模板的声明与实现分离，无须将它们统一定义到头文件中，从而隐藏了实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Element</span> &#123; <span class="comment">// 定义容器的元素支持排序操作</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">lessThan</span><span class="params">(Element&amp;)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(Element&amp;)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span> : Element&gt; <span class="comment">// 对模板参数进行约束</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(Container&lt;T&gt;&amp; c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Number</span> : Element &#123; <span class="comment">/*...*/</span> &#125;; <span class="comment">// 再次引入继承以满足要求</span></span><br></pre></td></tr></table></figure>

<p>这种方式带来的问题在于，具体实现 Element 实例的接口时，需要进行基类到具体类的转换，这需要运行时类型检查以确保类型安全。将泛型函数转换成面向对象的形式会带来性能损失：每一个模板函数的调用将触发虚函数调用。</p>
<p>虽然可以通过编译器对程序进行分析，或者通过编译器根据标记特殊处理某些模板函数的方式来提高性能，但这都不是最优雅的方式，同时也增添了编译器的实现负担。</p>
<p>另一个问题是，将对模板参数的要求提炼成基类会导致类的泛滥，而且这也不符合泛型编程的习惯。假如有两个人开发科学计算库，其中一个人表达加法使用 Addable 约束类，而另一个人表达加法使用 Add 约束类，当用户提供的 Number 类想要使用这两个人提供的泛型函数时，不得不同时派生自 Addable 约束类与 Add 约束类并实现两套接口，这样做会引入额外的复杂度。考虑如下常见的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Addable <span class="keyword">operator</span>+(<span class="type">const</span> Addable&amp;, <span class="type">const</span> Addable);</span><br></pre></td></tr></table></figure>

<p>如何确保两个约束类 Addable 拥有同一个具体类型？返回类型又该如何确定？答案是基础类型需要额外的包装才能使用，而返回抽象类型的值在 C++ 语言中是非法的。</p>
<h4 id="1-2-2-函数匹配方案"><a href="#1-2-2-函数匹配方案" class="headerlink" title="1.2.2 函数匹配方案"></a>1.2.2 函数匹配方案</h4><p>更理想的方案是避免使用继承来表达约束，可以使用匹配（match）一词取而代之，表达如下：</p>
<p>我们要求模板参数类匹配由 match 声明的函数所指定的约束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">match Addable &#123; <span class="comment">// match 声明了一系列操作的约束</span></span><br><span class="line">    Addable <span class="keyword">operator</span>+(Addable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span> match Addable&gt; <span class="comment">// 模板参数需要符合 Addable 的要求</span></span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(<span class="type">const</span> vector&lt;T&gt;&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Number</span> &#123; <span class="comment">/*...*/</span> &#125;; <span class="comment">// 无须使用继承满足要求，只需要提供 operator+</span></span><br></pre></td></tr></table></figure>

<p>当 <code>vector&lt;Number&gt;</code> 想要使用泛型函数 sum 时，要求 Number 的实现中能够提供成员函数 operator+，否则将导致编译错误。这种方式避免了基类方案中的很多缺点。</p>
<p>通过关键字 match 使得开发者可以表达自由函数与成员函数，而不仅仅局限于成员函数。此外基础数据类型也能很好地支持，只要基础类型匹配被要求的操作即可。这种灵活性一定程度带来了编译器实现上的复杂度：基类方案可以复用已有的语法规则，并且能够复用抽象类的实现模型；而函数匹配方案没有已有的实现模型，需要更复杂的代码生成策略以实现传统模板的性能。</p>
<p>该方案和基类方案都有一个共同的缺点，它们都需要严格匹配函数的签名。就操作符重载而言，可以通过成员函数与非成员函数实现，那么在声明 match 的时候就需要考虑支持这两种方式中的一种；同样需要考虑，函数的参数既可以声明成 const 也可以声明非 const 等。严格匹配无法很好地表达那些函数涉及重载与参数隐式类型转换的场景。</p>
<h4 id="1-2-3-基于表达式使用"><a href="#1-2-3-基于表达式使用" class="headerlink" title="1.2.3 基于表达式使用"></a>1.2.3 基于表达式使用</h4><p>这个方案后来也被称为得克萨斯提案，它在论文中占据近一半的篇幅。相比前两种方案一直要求模板参数能够满足什么操作，这个方案则进一步表达该如何使用这些操作，使用两个新的关键字：concept 定义概念，constraints 描述表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">concept</span> Element &#123; <span class="comment">// 定义约束 Element</span></span><br><span class="line">    <span class="built_in">constraints</span>(Element e1, Element e2) &#123;</span><br><span class="line">        <span class="type">bool</span> b = e1 &lt; e2; <span class="comment">// 要求两个 Element 能够使用 &lt; 操作，返回值能够类型转换成 bool</span></span><br><span class="line">                          <span class="comment">// 不管是以成员函数还是自由函数方式提供的</span></span><br><span class="line">        <span class="built_in">swap</span>(e1, e2); <span class="comment">// 都要求能够进行交换操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板参数声明 typename 替换成 Element 约束</span></span><br><span class="line"><span class="keyword">template</span> &lt;Element E&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;E&gt;&amp; c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123; <span class="comment">/* 满足约束无须使用继承 */</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>这种方案是基于 1994 年的 constraints 函数的想法，和普通函数类似，也需要使用合法的 C++ 表达式、语句。编译时可以通过检查 constraints 的语法来判断模板参数是否满足要求，且毫无运行时开销。与函数匹配方案相比，它无须显式指明要求的函数签名，而是以一种很自然的使用方式来表达。</p>
<p>更进一步，它还可以对多个 concept 进行组合，并使用逻辑操作符来表达：同时满足约束、满足其中一个、要求不满足。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; Printable &amp;&amp; ValueType T&gt; <span class="keyword">class</span> <span class="title class_">X</span> &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt; Printable || ValueType T&gt; <span class="keyword">class</span> <span class="title class_">Y</span> &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;!Printable &amp;&amp; ValueType T&gt; <span class="keyword">class</span> <span class="title class_">Z</span> &#123; <span class="comment">/*...*/</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>因为 concept 是一组类型的模型，是从现有类型产生新类型的常用方法，所以参数化（模板）、派生等方式也自然适用于 concept。</p>
<p>考虑通过参数化从已有的 concept 产生的新的 concept，例如标准库中迭代器的概念代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;ValueType V&gt; <span class="comment">// 参数化类型 V，需满足 ValueType</span></span><br><span class="line"><span class="keyword">concept</span> ForwardIterator &#123;</span><br><span class="line">    <span class="built_in">constraints</span>(ForwardIterator p) &#123;</span><br><span class="line">        ForwardIterator q = p; p = q; <span class="comment">// 可复制迭代器</span></span><br><span class="line">        V v = *p; q = &amp;v;             <span class="comment">// 迭代器解引用得到 V 类型</span></span><br><span class="line">        p++; ++p;                     <span class="comment">// 可以对迭代器进行 ++ 操作</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;ForwardIterator&lt;ValueType&gt; Iter&gt; <span class="comment">// 使用模板 concept</span></span><br><span class="line"><span class="function">Iter <span class="title">find</span><span class="params">(Iter first, Iter last)</span></span>;</span><br></pre></td></tr></table></figure>

<p>和模板类型类似，concept 模板也能通过接受模板参数形成新的 concept，在这个例子中当作 find 与 int 数组使用，可以形成约束 <code>ForwardIterator&lt;int&gt;</code>。concept 也可以在定义时接受多个模板参数。</p>
<p>考虑通过派生的方式从已有的 concept 形成新的 concept，同样以标准库中迭代器的概念作为例子，定义随机访问迭代器最合适的方式是通过派生已有迭代器概念。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">concept</span> RandomAccessIterator&lt;ValueType T&gt; </span><br><span class="line">    : ForwardIterator&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">constraints</span>(RandomAccessIterator p) &#123;</span><br><span class="line">        --p; p--; p + <span class="number">1</span>; p[<span class="number">1</span>]; p - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当对模板函数进行重载时，可以提供一个毫无约束的普通版本，并提供一个带约束的版本，在重载决议时，被替换的具体类型如果满足约束将使用约束版本。这也被称为基于 concept 的重载，它可以替换传统上使用的 enable_if 或标签分发技术。</p>
<p>模板参数支持非类型参数，因此可以对非类型参数进行约束，例如要求传递的非类型参数为奇数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">concept</span> Odd &#123; <span class="function"><span class="type">bool</span> <span class="title">constraints</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Odd % <span class="number">2</span>; &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Odd N&gt; <span class="keyword">class</span> <span class="title class_">Buffer</span> &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"></span><br><span class="line">Buffer&lt;<span class="type">int</span>, <span class="number">5</span>&gt; buffer; <span class="comment">// OK</span></span><br><span class="line">Buffer&lt;<span class="type">int</span>, <span class="number">6</span>&gt; buffer; <span class="comment">// 不符合约束，编译错误</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-4-基于伪签名方案"><a href="#1-2-4-基于伪签名方案" class="headerlink" title="1.2.4 基于伪签名方案"></a>1.2.4 基于伪签名方案</h4><p>使用函数签名来表达约束存在的缺点是必须严格匹配签名，这样会导致过约束问题。我们是不是可以考虑同样使用签名方式来表达，但是又不会导致过约束呢？考虑使用伪签名方式，代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">concept</span> Element &#123;</span><br><span class="line">    &lt;(Element, Element) -&gt; <span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">swap</span><span class="params">(Element, Element)</span> -&gt; <span class="type">void</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure>

<p>上述代码引入了新的语法和新的语义，这要求符合 Element 约束的类型能够支持 operator&lt; 与 swap 操作，而不关心它们的形参是否为 const 或引用形式等。它与前一个方案的表达力相同。这两种方案基于同一思想，只是语法形式不同，论文中没有对这一方案进行过多的分析。</p>
<h4 id="1-2-5-设计目标"><a href="#1-2-5-设计目标" class="headerlink" title="1.2.5 设计目标"></a>1.2.5 设计目标</h4><p>Stroustrup 在对现有模板机制进行分析，以及对比当时支持泛型的编程语言，思考如何在 C++ 中更好地支持泛型编程技术，尝试从不同角度来处理 concept 的问题，并提出了 concept 的一些设计目标。下面的设计目标是按照优先级列出的，并不是所有的目标都需要满足。</p>
<ol>
<li>灵活性。在传统的面向对象编程范式中，通过接口来保证调用者与实现者之间的约定，而 concept 约束不应该显式指明类型，并且应该是非层次体系结构的。对于基础数据类型应该天然支持而不是采用变通方案。</li>
<li>模板检查。模板的定义不应该依赖于实际被替换的类型，而是检查 concept 中声明的要求，简而言之，模板应该依赖 concept 而不是实际类型。最好是在模板使用处就能进行检查，而无须看到定义。</li>
<li>友好、精确的错误信息。模板的编译错误信息应该比之前更加友好，尤其是受约束的模板。错误信息分为三类：检查模板的定义是否使用了 concept 中未声明的操作（无须使用模板）、被替换的实际类型是否符合要求（使用模板但无须看到模板定义）、实例化时的模板是否有无效表达式（使用模板且需要看到模板的定义）。</li>
<li>基于 concept 的模板特化、函数重载。能够定义一系列受约束的模板并根据实际的模板参数选择使用哪个模板。</li>
<li>无运行时开销。借助抽象类的手段很容易实现对模板参数的检查，但这是以失去一定的灵活性与运行时性能为代价实现的。concept 约束必须延续并增强编译时计算和内联能力，这是传统模板性能的根基。</li>
<li>对编译器实现友好。模板特性本身对于编译器而言非常难实现，concept 不应该比它们更难，另一方面 concept 应该会减轻编译器检查模板代码的难度。</li>
<li>向后兼容。即便引入新的语法，也不能对已有的模板代码产生冲击。</li>
<li>分离编译。这个想法可能需要像虚函数表那样来实现模板参数与模板实现的接口，从而做到独立编译。</li>
<li>简洁的语法，强大的表达力。约束应该简单明了地表达对模板参数的要求，并且能够利用逻辑关系将已有的 concept 组合成新的 concept。一个 concept 应该能够支持多个模板参数的输入，以便表达它们之间关系的要求。除了能够从语法的角度表达，还应该能够表达它们的语义。</li>
</ol>
<p>以上便是设计 concept 特性的所有目标，当然它们也存在矛盾的地方，比如基于 concept 的重载与分离编译这两点，一个是编译时目标，而另一个是运行时目标。</p>
<h3 id="1-3-2004-年（印第安纳提案与得克萨斯提案）"><a href="#1-3-2004-年（印第安纳提案与得克萨斯提案）" class="headerlink" title="1.3 2004 年（印第安纳提案与得克萨斯提案）"></a>1.3 2004 年（印第安纳提案与得克萨斯提案）</h3><p>2004 年，concept 特性出现了两大提案，分别被称为“印第安纳提案”与“得克萨斯提案”，它们分别对伪签名方案与基于表达式方案做出了更加深入的分析。</p>
<h4 id="1-3-1-印第安纳提案"><a href="#1-3-1-印第安纳提案" class="headerlink" title="1.3.1 印第安纳提案"></a>1.3.1 印第安纳提案</h4><p>该提案基于伪签名方案并提供如下的语法形式，它看上去和函数匹配方案类似，但是匹配要求没那么严格。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typeid</span> T&gt; <span class="comment">// 定义小于概念</span></span><br><span class="line"><span class="keyword">concept</span> LessThanComparable &#123;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(T x, T y);</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(T x, T y);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typeid</span> T&gt; <span class="comment">// 对模板参数 T 进行约束，要求小于、拷贝</span></span><br><span class="line">    where &#123; LessThanComparable&lt;T&gt;, CopyConstructible&lt;T&gt; &#125;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，只要被替换后的实际类型支持 operator&lt; 和 operator&lt;&#x3D; 操作即可：不管是内建方式、还是自由函数方式或者成员函数，只要这两个操作符能够接受两个相同的类型并且返回类型为 bool 或者能够通过隐式类型转换成 bool 即可。</p>
<p>另一个值得注意的点是模板参数被声明为 typeid，笔者建议复用该关键字来区分受约束与未受约束的模板参数。引入新的关键字 where 来提高表达力。</p>
<p>通过使用派生语法并基于已有的 concept 创建新的作法，被称为概念改良（concept refinement）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typeid</span> Iter&gt; <span class="comment">// 由多个概念组合而成，复用它们的要求</span></span><br><span class="line"><span class="keyword">concept</span> InputIterator </span><br><span class="line">    : CopyConstructible&lt;Iter&gt;, Assignable&lt;Iter&gt;</span><br><span class="line">    , EqualityComparable&lt;Iter&gt; &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>

<p>定义 concept 时，能够对函数提供默认实现，从而减少被约束的类型所需要满足的函数数量。当被约束类型仅提供 operator&#x3D;&#x3D; 时，下述代码的概念会自动满足 operator!&#x3D; 的要求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typeid</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> EqualityComparable &#123;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;); <span class="comment">// 提供 operator!= 的默认实现</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y) &#123; <span class="keyword">return</span> !(x == y); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在泛型类中有很多关联类型可供使用，例如 vector 会提供成员类型 value_type 来存储容器中每个元素的类型。同样地，定义 concept 时也可以要求一个类提供一些关联类型，并且能为某些关联类型提供默认值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typeid</span> G&gt;</span><br><span class="line"><span class="keyword">concept</span> Graph &#123; <span class="comment">// 要求模板参数 G 提供如下两个关联类型</span></span><br><span class="line">    <span class="keyword">typename</span> edge;</span><br><span class="line">    <span class="keyword">typename</span> vertex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当定义一个概念时，会要求模板参数的关联类型也满足概念的要求，这时候可以使用 require 子句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typeid</span> X&gt;</span><br><span class="line"><span class="keyword">concept</span> Container &#123; <span class="comment">// 关联类型 X::iterator 需要满足概念 InputIterator</span></span><br><span class="line">    require <span class="keyword">typename</span> X::iterator;</span><br><span class="line">    require InputIterator&lt;X::iterator&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在设计层面上，该提案提出了一个显著的问题：结构一致性与名字一致性的问题，并通过对实际类型进行显式概念建模声明（explicit model declarations）的方式来解决，这也是该提案的特点。通常来说有两种方案可以确定类型是否符合接口（概念）的要求：结构一致性与名字一致性。</p>
<p>结构一致性仅依赖接口的内容，而不关心接口的名字。例如有两个不同名字的 concept，但是它们的要求（结构）是一样的，那么它们实际上是同一个接口。这种方式无须对实际类型进行声明是否实现接口，即可满足多个的要求，只要在模板参数被替换成实际类型时能够通过约束检查。前文介绍的几个方案都是这种形式。</p>
<p>名字一致性依赖于接口的名字，因此两个不同名的接口即便内容一样，它们也是不同的。这就要求对一个类型进行显式声明是否实现了接口，C++ 中的 subtype 使用了名字一致性的方式，显式声明一个类继承了另一个接口类。在泛型编程的术语中，名字一致性意味着显式建模，表明实际类型对概念进行建模。</p>
<p>之所以会出现这个问题，原因在于一个概念不仅需要从语法层面满足要求，还需要从语义层面满足要求。一个比较明显的例子是在标准模板库中输入迭代器与前向迭代器的概念，它们的定义（结构）是一样的，但语义不一样：前者只能迭代一轮，后者可以保证多轮迭代，仅从语法角度上无法区分两者。</p>
<p>那么结构一致性存在的可能是，实际类型既匹配输入迭代器也匹配前向迭代器，从语义角度而言输入迭代器不是前向迭代器，如果使用基于 concept 重载的函数，将可能决策出错误的重载实现。</p>
<p>如果使用名字一致性并对实际类型进行显式概念建模，就能够通过名字来实现对语义上的区分。比如声明 MyFileIterator 是一个输入迭代器，那么重载决议时仅使用输入迭代器的版本，不会出现实际类型符合语法但不符合语义的情况。</p>
<p><code>model InputIterator&lt;MyFileIterator&gt; &#123;&#125;; // 对实际类型进行概念建模声明</code></p>
<p>即使该类型不包含概念所需的函数定义，也可以对实际类型进行概念建模声明，因为能够通过 model 子句补充被要求的函数定义，从而满足概念。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; <span class="type">int</span> x, y; &#125;</span><br><span class="line">model EqualityComparable&lt;Point&gt; &#123;     <span class="comment">// 对 Point 显示概念建模</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point&amp; rhs) <span class="comment">// 子句补充了所需的函数定义</span></span><br><span class="line">    &#123; <span class="keyword">return</span> x == rhs.x &amp;&amp; y == rhs.y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>名字一致性的另一个好处是提供了一种简单的机制来支持关联类型，只要用户对实际类型声明了概念建模，就无须再使用 type traits 方式访问关联类型。该方式也有利于编译器的实现。</p>
<p>结构一致性的好处在于无须开发者为每一个类型进行概念建模声明，这有助于将当前的泛型库过渡到基于概念的泛型库。可以借助编译器的帮助生成一些默认的声明来解决显式概念建模的问题。</p>
<h4 id="1-3-2-得克萨斯提案"><a href="#1-3-2-得克萨斯提案" class="headerlink" title="1.3.2 得克萨斯提案"></a>1.3.2 得克萨斯提案</h4><p>继印第安纳提案之后得克萨斯提案也诞生了，该提案对基于表达式使用方式做了进一步细化。通过列出一系列函数、操作符、关联类型的使用来定义一个 concept，如下是前向迭代器概念的定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">concept</span> ForwardIterator&lt;<span class="keyword">class</span> <span class="title class_">Iter</span>&gt; <span class="comment">// 对前向迭代器的要求</span></span><br><span class="line">&#123;</span><br><span class="line">    Iter p;                         <span class="comment">// 支持默认构造</span></span><br><span class="line">    Iter q = p;                     <span class="comment">// 支持拷贝构造</span></span><br><span class="line">    p = q;                          <span class="comment">// 支持赋值</span></span><br><span class="line">    Iter&amp; q = ++p;                  <span class="comment">// 前自增，结果能够被引用</span></span><br><span class="line">    <span class="type">const</span> Iter&amp; cq = p++;           <span class="comment">// 后自增</span></span><br><span class="line">    <span class="type">bool</span> b1 = (p == q);             <span class="comment">// 判等，结果为 bool 或者能够隐式转换成 bool</span></span><br><span class="line">    <span class="type">bool</span> b2 = (p != q);             <span class="comment">// 判不等</span></span><br><span class="line">    ValueType Iter::value_type;     <span class="comment">// 拥有成员类型 value_type</span></span><br><span class="line">    Iter::value_type v = *p;        <span class="comment">// 解引用，结果能够被赋 value_type 类型</span></span><br><span class="line">    *p = v;                         <span class="comment">// value_type 类型的值能够被赋给解引用后的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前向迭代器的概念定义直接从 C++ 标准中与前向迭代器相关的语法要求表而得。如果一个模板类型满足概念的所有要求，我们可以说该类型“匹配”对应的概念，印第安纳提案中使用的类似术语叫作“建模”。通常不使用术语“是一个”（is-a）来表达，因为这样会和类体系中的术语相混淆。</p>
<p>概念是一个编译期谓词，得克萨斯提案中通过使用静态断言可以判断具体类型是否匹配概念，若不匹配则编译报错。值得一提的是编译器可以缓存概念匹配的结果，供后续使用。</p>
<p><code>static_assert ForwardIterator&lt;int*&gt;; // 静态断言类型 int* 是否匹配前向迭代器概念</code></p>
<p>可惜的是上述断言将失败，因为指针类型没有成员类型 value_type，这不符合我们的预期。为了让基础数据类型也能够匹配概念，需要通过静态断言来对基础类型做扩展。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span> <span class="keyword">template</span>&lt;ValueType T&gt; ForwardIterator&lt;T*&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T* pointer_type; <span class="comment">// 对 T* 类型拓展，定义关联类型 value_type 为 T</span></span><br><span class="line">    <span class="keyword">typedef</span> T  pointer_type::value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在印第安纳提案中提到，如果不通过显式建模声明的方式，会出现因为语法相同、语义不同而导致决策错误的问题，因此得克萨斯提案考虑使用否定断言（Negative assertions）的方式来解决，例如断言 MyIterator 虽然从语法上匹配前向迭代器，但从语义上不匹配。</p>
<p><code>static_assert ! ForwardIterator&lt;MyIterator&gt;;</code></p>
<p>因此，得克萨斯提案的静态断言有三个语义：第一、通过及早断言给定的类型是否匹配概念来及时发现错误；第二、通过对诸如基础数据类型进行扩展；第三、通过否定断言来声明指定类型不匹配概念。这样做可以避免为每个类型都显式建模声明。</p>
<h4 id="1-3-3-ConceptGCC"><a href="#1-3-3-ConceptGCC" class="headerlink" title="1.3.3 ConceptGCC"></a>1.3.3 ConceptGCC</h4><p>2005 年下半年，印第安纳提案的修订版本中移除了 typeid 关键字，它被替换成标准的关键字 typename。</p>
<p>与此同时 GCC 编译器基于印第安纳提案衍生出一个分支：ConceptGCC，这个原型项目至关重要，因为它是首个证明该提案可行的实现。然而这个过程中遇到了很多问题：实现赶不上标准制定的进展，存在非常多的 bug 并且编译速度慢，这些都使其很难用于大型泛型库中。</p>
<h3 id="1-4-2006-年（妥协）"><a href="#1-4-2006-年（妥协）" class="headerlink" title="1.4 2006 年（妥协）"></a>1.4 2006 年（妥协）</h3><p>Alexander Stepanov 于 2006 年邀请得克萨斯提案和印第安纳提案的团队参与 Adobe 公司举行的会议，旨在解决双方提案之间存在显著差异的问题，从而进一步在设计上达成一致。一些权衡的点主要包括采用伪签名模式还是依据表达式使用模式、使用哪种手段对 concept 进行组合、关于显式建模还是隐式匹配等。</p>
<p>两个团队经过数个月的合作并公布了折中方案，后由 Stroustrup 等人汇总并正式向 C++ 标准委员会提出提案，该提案的一些要点如下：</p>
<p>基于伪签名模式与依据表达式使用模式拥有等价的语义，两种方式应该能够相互转换，只是表现形式不一样，因此需要考虑其他方面的问题。尽管依据表达式模式很贴近文档中的约束描述，但是应该采用伪签名方式，原因是它的表现形式与类和类所需的成员函数具有相似性以及与显式建模声明子句的一致性。伪签名的另一个优势是容易构造原型类（archetypes），它是提供所需函数、成员以满足概念的最小类，在提案中便于对受约束的模板参数定义进行检查。</p>
<p>对模板类或模板函数使用约束时，拥有两种表现形式，分别是应对简单的场是与应对复杂的场景，在复杂的情况下可以使用逻辑关系来组合多个概念。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Comparable T&gt; <span class="comment">// 简单的语法对应简单的场景</span></span><br><span class="line"><span class="function">T <span class="title">mymin</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b ? a : b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// concept 的逻辑组合</span></span><br><span class="line">    where &#123; Comparable&lt;T&gt; &amp;&amp; AnotherConcept&lt;T&gt; &#125;</span><br><span class="line"><span class="function">T <span class="title">mymin</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b ? a : b; &#125;</span><br></pre></td></tr></table></figure>

<p>在提案中提出了基于概念重载的规则来决策哪个可行函数更优的方式：受概念约束的重载比未受约束的更具体，同样受约束的多个概念逻辑组合关系的比较，例如 <code>A&lt;T&gt;</code> 与 <code>A&lt;T&gt; &amp;&amp; B&lt;T&gt;</code> 相比，根据规则后者将更具体。</p>
<p>关于显式建模还是隐式匹配的抉择也是个很大的问题。显式建模能够避免给定类型仅因为语义差别而导致误匹配概念的情况，但是它增加了简单场景的复杂度：需要大量的 model 声明语句，使得一个类型变得相当模糊。该提案给出的解决方案是将 concept 分成两种：一种是默认 concept 需要显式建模，而另一种是需要在 concept 定义前使用 auto 修饰来表明它可以隐式匹配。</p>
<p>由于显式建模的关键字 model 太过平凡，可能会与现存代码造成冲突，因此提案中将该关键字修改为 concept_map，它的子句中可以对不满足概念要求的指定类型进行补充扩展定义，从而满足概念要求。顾名思义，concept_map 可视作模板参数到指定类型的概念映射。</p>
<p>公理（axiom）表达了概念的语义要求，虽然编译器仅能检查语法要求，但是它可以提示编译器基于这些假设对类型做出优化。例如，某个概念要求类型的二元操作 op 符合结合律，那么编译器可能会将表达式 <code>op(x, op(y, z))</code> 等价替换成 <code>op(op(x, y), z)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">concept</span> Semigroup &lt;<span class="keyword">typename</span> Op, <span class="keyword">typename</span> T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(Op, T, T)</span></span>; <span class="comment">// axiom 公理作为语义要求</span></span><br><span class="line">    <span class="function">axiom <span class="title">Associativity</span><span class="params">(Op op, T x, T y)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">op</span>(x, <span class="built_in">op</span>(y, z)) == <span class="built_in">op</span>(<span class="built_in">op</span>(x, y), z); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-2009-年（标准化投票）"><a href="#1-5-2009-年（标准化投票）" class="headerlink" title="1.5 2009 年（标准化投票）"></a>1.5 2009 年（标准化投票）</h3><p>Stroustrup 在 2009 年写了一篇论文，总结了标准委员会对 ConceptGCC 提案的担忧，他们担心这个特性对普通的 C++ 程序员来说太复杂了，所以决定简化设计。</p>
<p>其中一点是建议将默认的显式建模改成默认隐式匹配，并提出了相关手段，这样能够减少 concept_map 声明的数量，使得对普通程序员更加友好，但这一手段需要相当大的改动。</p>
<p>同年7月的法兰克福会议上，C++ 标准委员会对该特性进行投票，有如下选项。</p>
<ol>
<li>将当前的 concept 特性提案直接写入 C++0x 标准化。</li>
<li>根据 Stroustrup 的建议进行修改，并写入 C++0x 标准化。</li>
<li>从 C++0x 标准中移除该特性。</li>
</ol>
<p>标准委员会注意到当前设计的缺点并将投票分成第二、第三个选项。然而大多数人选择了更安全的选项：从当前标准中移除该特性。因为时间相当紧张，离第一个标准 C++98 已经过去了近二十年，如果对concept特性进行修改将进一步推迟 C++ 的标准化进程。此外，更多人担心的是 ConceptGCC 的运行效率太低了，最后委员会决定延期到下一个标准中。参与到 concept 开发的成员们虽然都很失望，但他们更愿意提供一个高质量的解决方案。</p>
<h3 id="1-6-2013-年轻量级概念（conceptslite）"><a href="#1-6-2013-年轻量级概念（conceptslite）" class="headerlink" title="1.6 2013 年轻量级概念（conceptslite）"></a>1.6 2013 年轻量级概念（conceptslite）</h3><p>在 concept 特性未能进入 C++11(C++0x) 标准后，相关人员不仅简化了设计，而且改变了开发的方式。考虑到一次性将如此复杂的特性融入语言的困难程度，Stroustrup 和他的同事们专注于 concept 设计的第一部分：模板参数约束，这也在后来被称为轻量级概念，使用谓词来约束模板参数。</p>
<p>轻量级概念仅检查被约束的模板是否使用正确，而不检查模板的定义是否正确。换句话说，模板的定义可以使用概念要求之外的操作。它的目的是让程序员简单、轻松地接受并使用。它仅满足如下目标：</p>
<ol>
<li>允许程序员直接将声明一组模板参数的要求作为模板接口的一部分。</li>
<li>支持基于 concept 的函数重载与模板类特化。</li>
<li>明确模板使用时检查模板参数的诊断信息。</li>
<li>无任何运行时开销，且能提高编译速度。</li>
</ol>
<p>值得一提的是，GCC 编译器在设计报告编写时已经完成了大部分目标与实现，并且包含了配套使用 concept 的标准库。</p>
<p>轻量级概念定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">concept</span> <span class="type">bool</span> <span class="title">EqualityComparable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">requires</span>(T a, T b) &#123;</span><br><span class="line">        &#123;a == b&#125; -&gt; <span class="type">bool</span>;</span><br><span class="line">        &#123;a != b&#125; -&gt; <span class="type">bool</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现 concept 的定义发生了变化，它相当于 constexpr 谓词函数，能够在编译时求值，原型要求返回类型为 bool 的无参函数。</p>
<p>同时引入了 requires 表达式，它提供了可以简明表示表达式是否合法和关联的类型是否满足要求的能力。requires 表达式能够声明一些参数，然后罗列这些参数的表达式来判断其是否符合要求。这个例子中通过声明模板类型T的两个实例 a 和 b，并通过表达式 a&#x3D;&#x3D;b 来判断它们是否能够判等，并且最终判等的结果是否为 bool。</p>
<p>当实例化时若这些表达式无效，则 requires 表达式最终结果为 false，表明模板参数不满足要求。在这个设计报告中使用了基于表达式使用的方式而不是伪签名方式，它的一个优势在于能够根据标准库的文档代码样例简单地转换成概念的定义。此外，基于表达式使用的方式比伪签名更加抽象，它们表达更多的是如何（How）使用而不是提供什么（What）签名，这使得程序员能够写出更加通用的代码。</p>
<p>接着看看概念的使用，同样提供了两种方式分别应对简单与复杂的场景，使用 requires 子句来表达多个概念的逻辑组合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;FloatingPoint T&gt; <span class="keyword">class</span> <span class="title class_">complex</span>; <span class="comment">// 概念的简单使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 概念的复杂场景，使用 requires 子句组合</span></span><br><span class="line">    <span class="keyword">requires</span> <span class="built_in">Same</span>&lt;T, <span class="type">float</span>&gt;() || <span class="built_in">Same</span>&lt;T, <span class="type">double</span>&gt;() || <span class="built_in">Same</span>&lt;T, <span class="type">long</span> <span class="type">double</span>&gt;()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>;</span><br></pre></td></tr></table></figure>

<p>如上两种方式是等价的，前者使用概念 FloatingPoint 来约束模板参数，而后者使用 requires 对三个 Same 概念进行组合约束。</p>
<p>对于模板类型可以基于概念的特化实现，考虑如下例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Arithmetic T&gt;    <span class="keyword">class</span> <span class="title class_">complex</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;FloatingPoint T&gt; <span class="keyword">class</span> <span class="title class_">complex</span>&lt;T&gt; &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;Integral T&gt;      <span class="keyword">class</span> <span class="title class_">complex</span>&lt;T&gt; &#123; <span class="comment">/*...*/</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码声明了一个模板类型 complex，将模板参数约束为数值类型，既可以是浮点类型也可以是整数类型，接着分别对浮点类型和整数类型进行特化，当用户使用 <code>complex&lt;int&gt;</code> 时将使用 Integral 概念约束的特化版本。</p>
<p>设计报告没有使用显式建模 concept_map 方案，而是隐式匹配方案。同样地，这种方案也面临着语法相同、语义不同而导致的 concept 无法区分的情况。目前的变通方案是将语义要求的差异转换成语法上的差异，以此进行区分。</p>
<h3 id="1-7-2015-年（ConceptsTS）"><a href="#1-7-2015-年（ConceptsTS）" class="headerlink" title="1.7 2015 年（ConceptsTS）"></a>1.7 2015 年（ConceptsTS）</h3><p>C++14 的目标是完成 C++11 的特性并修复一些已知问题，concept 没有足够的时间进入 C++14 标准，标准委员会决定为该特性单独编写一份技术规范文档（TechnicalSpecification，TS）。</p>
<p>2012 年，标准委员会的工作方式发生了变化，其主要工作独立于标准制定，并行地以技术规范形式交付，随后可以纳入标准。这种工作方式允许标准委员会能够快节奏、可预测地交付。Concepts TS 形成了最终的技术规范，在 GCC 编译器中能够使用选项 -fconcepts 来使用该特性。</p>
<h3 id="1-8-2016-年（C-17）"><a href="#1-8-2016-年（C-17）" class="headerlink" title="1.8 2016 年（C++17）"></a>1.8 2016 年（C++17）</h3><p>轻量级概念本应该进入 C++17 标准，但最终未能实现。由于社区存在两种声音，有支持的也有反对的，对立双方的论点如下。</p>
<p>支持的声音是，模板参数约束（即便只检查模板的使用而不是定义）正是程序员想要的：它拥有友好的报错信息、文档、表现形式与重载。在各种各样的项目中都已经验证了轻量级概念，仅有少量问题。而且它在学术演讲中也得到了积极的响应，此外，程序员等待该特性实在太久了，由于缺乏 concept 的支持，导致各种各样的类 concept 库被开发，并产生了一系列变通方法。</p>
<p>反对的声音是，目前缺乏基于 concept 支持的标准库，仅仅拥有语言特性仍不足够。在不借助基础概念支持的情况下很难去编写一个高质量的库。甚至负责新的标准模板库开发的专家们也遇到了如何建立可靠概念体系的问题。另外，轻量级概念只是整个 concept 特性的第一部分，后续部分需要对第一部分的设计进行修改，加上最终的技术标准刚落地，目前只有 GCC 这一个编译器实现了概念特性，而语法上还存在一些问题。</p>
<p>所以标准委员会在 2016 年决定再次延后 concept 的标准化。</p>
<h3 id="1-9-2020-年（C-20）"><a href="#1-9-2020-年（C-20）" class="headerlink" title="1.9 2020 年（C++20）"></a>1.9 2020 年（C++20）</h3><p>随后，概念的语法经过了一些精简。首先，concept 为编译时概念谓词，那么指明返回类型为 bool 则有些多余。其次，concept 的定义不再是一个类 constexpr 模板函数，而是变成了模板变量的形式。标准库的一些 concept 命名风格也发生了变化，例如 View 被命名为 view。千呼万唤始出来，轻量级概念终于进入了 C++20 标准。</p>
<h3 id="1-10-小结"><a href="#1-10-小结" class="headerlink" title="1.10 小结"></a>1.10 小结</h3><p>概念的目标非常简单：提供接口约束模板参数。然而随着对概念特性的开发在这一过程中也产生了许多问题，即使通过技术规范的工作方式集中于轻量级概念，依然存在问题。这表明了语言设计师必须时刻意识到项目中可能存在的困难与风险。</p>
<p>另外，是为设计负责。在不考虑后果的情况下轻易创造、修改设计是不明智的，还有对于新特性的开发很难预见所有决策的后果。这种风险和项目类型有关，如果是小项目，那么能够接受试错成本；而在复杂的大型项目中，错误的决策将导致不可逆转的结果。语言设计师应尽最大的努力来避免这种灾难性的决定。</p>
<p>方案的多样性也是有价值的，对于印第安纳提案与得克萨斯提案而言，它们提供了不同的思路来解决同一问题，并且一起改善了提案；缺少编译器实现（最初仅 GCC 编译器实现）上的多样性导致了概念被延期进入标准。因此，面对与讨论不同的方案以及进行广泛的测试验证是有价值的。</p>
<h2 id="第-2-章-C-20-标准的概念特性"><a href="#第-2-章-C-20-标准的概念特性" class="headerlink" title="第 2 章 C++20 标准的概念特性"></a>第 2 章 C++20 标准的概念特性</h2><h3 id="2-1-定义概念"><a href="#2-1-定义概念" class="headerlink" title="2.1 定义概念"></a>2.1 定义概念</h3><p>这里正式给 concept 下定义，它是一个对类型约束的编译期谓词，给定一个类型判断其能否满足语法和语义要求，这对泛型编程而言极为重要。举个例子，给定模板参数 <code>T</code>，对它的要求如下。</p>
<ol>
<li>一种迭代器类型 <code>Iterator&lt;T&gt;</code>。</li>
<li>一种数字类型 <code>Number&lt;T&gt;</code>。</li>
</ol>
<p>符号 <code>C&lt;T&gt;</code> 中的 <code>C`` 就是概念，</code>T<code>是一个类型，它表达“如果</code>T<code>满足</code>C&#96; 的所有要求，那么为真，否则为假。”</p>
<p>类似地，我们能够指定一组模板参数来满足概念的要求，例如 <code>Same&lt;T, U&gt;</code> 概念可定义为类型 <code>T</code> 与 <code>U</code> 相等。这种多类型概念对于 STL 来说是必不可少的，同时也能应用于其他领域中。</p>
<p>concept 拥有强大的表达力并且对编译时间友好，程序员能够通过非常简单地定义一个概念，也可以借助概念库对已有的概念进行组合。概念支持重载，能够消除对变通方案（诸如 enable_if 等技巧）的依赖，因此不仅大大降低了元编程的难度，同时也简化了泛型编程。在 C++ 中定义一个 concept 的语法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;被约束的模板参数列表&gt;</span><br><span class="line"><span class="keyword">concept</span> 概念名 = 约束表达式;</span><br></pre></td></tr></table></figure>

<p>概念被定义为约束表达式（constraint-expression），也可以简单理解成布尔常量表达式。在实现一些简单的概念时可以复用在标准库 <code>&lt;type_traits&gt;</code> 中的组件，它们是编译时查询类型特征的接口，在配套的概念标准库 <code>&lt;concepts&gt;</code> 中可以看到一些和数值相关的概念被定义为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> integral = is_integral_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> floating_point = is_floating_point_v&lt;T&gt;;</span><br></pre></td></tr></table></figure>

<p>这种简单的概念定义能否不依托于 type traits 呢？答案是可能不行，根据 C++20 标准，概念不允许做特化且约束表达式在定义时处于不求值环境中，因此除了 type traits 之外没有更好的方式了。</p>
<p>概念和模板 using 的别名很类似，前者是对布尔表达式的别名，而后者是对模板类型的别名，它们都不允许自身进行实例化或特化。记住这个有助于对后文介绍的约束偏序规则的理解。</p>
<p>在判断类型是否满足概念时，编译器将会对概念定义的约束表达式进行求值，因此可以通过静态断言来检测类型是否满足。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>( floating_point&lt;<span class="type">float</span>&gt;); <span class="comment">// 对约束表达式 is_floating_point_v 进行求值</span></span><br><span class="line"><span class="built_in">static_assert</span>(!floating_point&lt;<span class="type">int</span>&gt;);</span><br></pre></td></tr></table></figure>

<p>如果在定义概念时约束表达式类型不为 bool 类型，将引发一个编译错误，而不是返回不满足（假）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// atomic constraint must be of type &#x27;bool&#x27; (found &#x27;int&#x27;)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">concept</span> Foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>约束表达式通过逻辑操作符的方式进行组合以定义更复杂的概念，这种操作符有两种：合取（conjunction）与析取（disjunction），C++ 标准中使用符号 ∧ 来代表合取操作，符号 ∨ 代表析取操作。</p>
<p>由于在 C++ 语法中并没有定义这两个符号，而是复用逻辑与（&amp;&amp;）和逻辑或（||）来分别表达合取与析取，那么它们在约束表达式中的语义相对布尔运算也就有了细微区别。</p>
<p>约束的合取表达式由两个约束组成，判断一个合取是否满足要求，首先要对第一个约束进行检查，如果它不满足，整个合取表达式也不满足；否则，当且仅当第二个约束也满足时，整个表达式满足要求。</p>
<p>约束的析取表达式同样由两个约束组成，判断一个析取是否满足要求，首先对第一个约束进行检查，如果它满足，整个析取表达式满足要求；否则，当且仅当第二个约束也满足时，整个表达式满足要求。</p>
<p>合取与析取操作与逻辑表达式中的与或运算类似，也是一个短路操作符。在依次对每个约束进行检查时，首先检查表达式是否合法，若不合法则该约束不满足，否则进一步对约束进行求值判断是否满足。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 析取表达式 is_integral_v&lt;T::type&gt; ∨ sizeof(T) &gt; 1</span></span><br><span class="line"><span class="keyword">concept</span> C = is_integral_v&lt;<span class="keyword">typename</span> T::type&gt; || (<span class="built_in">sizeof</span>(T) &gt; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(C&lt;<span class="type">double</span>&gt;);</span><br></pre></td></tr></table></figure>

<p>对 <code>C&lt;double&gt;</code> 进行求值的过程中，模板类型参数T被替换为 double，整个约束表达式为 <code>is_integral_v&lt;double::type&gt; ∨ sizeof(double) &gt; 1</code>，显然第一个约束的表达式非法，结果为不满足要求，然而第二个表达式满足要求，因此整个结果为真。</p>
<p>对于可变参数模板形成的约束表达式，既不是约束合取也不是约束析取。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TS&gt;</span><br><span class="line"><span class="keyword">concept</span> C = (is_integral_v&lt;<span class="keyword">typename</span> Ts::type&gt; || ...);</span><br></pre></td></tr></table></figure>

<p>上述代码不是析取表达式，因此没有短路操作，它首先检查整个表达式是否合法，只要有一个模板参数没有类型成员 <code>type</code>，整个表达式将为假。若要表达“至少一个模板参数存在类型成员 <code>type</code> 且类型成员为整数”，则可以添加一层间接层解决：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 额外的间接层</span></span><br><span class="line"><span class="keyword">concept</span> IntegralWithNestType = is_integral_v&lt;<span class="keyword">typename</span> T::type&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">concept</span> C = (IntegralWithNestType&lt;Ts&gt; || ...);</span><br></pre></td></tr></table></figure>

<p>由于约束表达式使用的合取与析取操作符分别与逻辑表达式的逻辑与和逻辑或相同，若要表达“逻辑表达式”的合法性，而不是被当成析取或合取表达式处理则需要额外的工作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="comment">// 约束析取表达式</span></span><br><span class="line"><span class="keyword">concept</span> C1 = is_integral_v&lt;<span class="keyword">typename</span> T::type&gt; || is_integral_v&lt;<span class="keyword">typename</span> U::type&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;typanme T, <span class="keyword">typename</span> U&gt; <span class="comment">// 原子约束</span></span><br><span class="line"><span class="keyword">concept</span> C2 = <span class="built_in">bool</span>(is_integral_v&lt;<span class="keyword">typename</span> T::type&gt; || is_integral_v&lt;<span class="keyword">typename</span> U::type&gt;);</span><br></pre></td></tr></table></figure>

<p>概念 <code>C1</code> 中的约束表达式为析取表达式，它具有短路性质，表达“要求存在一个模板参数拥有类型成员 <code>type</code> 且类型成员为整数”，而 <code>C2</code> 表达了一条完整的逻辑表达式：“要求两个模板参数存在类型成员 <code>type</code> 且其中一个为整数”。</p>
<p>另一个比较特殊的是逻辑否定（negation），在对概念进行求值的过程中，若约束中的模板参数替换发生错误（表达式非法），则该约束的结果为不满足。考虑如下情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">concept</span> C1 =  is_integral_v&lt;<span class="keyword">typename</span> T::type&gt;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">concept</span> C2 = !is_integral_v&lt;<span class="keyword">typename</span> T::type&gt;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(!C1&lt;<span class="type">int</span>&gt;);</span><br><span class="line"><span class="built_in">static_assert</span>(!C2&lt;<span class="type">int</span>&gt;);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123; <span class="keyword">using</span> type = <span class="type">float</span>; &#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(C2&lt;Foo&gt;);</span><br></pre></td></tr></table></figure>

<p>其中 <code>C1</code> 表达式“要求类型 <code>T</code> 存在关联类型 <code>type</code>，且关联类型为整数类型”，<code>C1</code> 的否定“要求类型 <code>T</code> 不存在关联类型 <code>type</code>，或关联类型不为整数”。</p>
<p>根据约束否定的特殊性质，<code>C2</code> 并不是 <code>C1</code> 的否定，它表达的是“要求类型 <code>T</code> 存在关联类型 <code>type</code>，且关联类型不为整数类型”，在断言 <code>C2&lt;Foo&gt;</code> 和 <code>C2&lt;int&gt;</code> 时我们可以确认这一点。</p>
<p>如果需要表达 <code>C1</code> 的否定“要求类型 <code>T</code> 不存在关联类型 <code>type</code>，或关联类型不为整数”，应该定义为如下形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">concept</span> C3 = !C1&lt;T&gt;;</span><br><span class="line"><span class="built_in">static_assert</span>(C3&lt;Foo&gt;);</span><br><span class="line"><span class="built_in">static_assert</span>(C3&lt;<span class="type">int</span>&gt;);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-requires-表达式"><a href="#2-2-requires-表达式" class="headerlink" title="2.2 requires 表达式"></a>2.2 requires 表达式</h3><p>除了使用 type traits 来定义概念之外，requires 表达式也提供了一种简明的方式来表达对模板参数及其对象的特征要求：成员函数、自由函数、关联类型等。在 C++ 中定义 requires 表达式的语法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">requires</span> (可选的形参列表) &#123; <span class="comment">// 表达式体，提出要求</span></span><br><span class="line">    一系列表达式（要求）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>requires 表达式的结果为 bool 类型，即编译时谓词。表达式体应至少提出一条要求，同样地在表达式体中处于不求值环境。当对 requires 表达式进行求值时，按照表达式体中声明的先后顺序依次检查表达式的合法性，当遇到一条非法的表达式时，返回结果为不满足（假），与短路类似的后续表达式也无须进一步检查；当所有表达式都合法时，返回的结果为满足（真）。</p>
<p>可选的形参列表声明了一系列局部变量，这些局部变量不允许提供默认参数，它们对整个表达式体可见。这些变量没有链接性、存储性与生命周期，仅仅用作提出要求时的符号。如果在表达式体中引用了未声明的符号，则视作语法错误。</p>
<p>requires 表达式提供了四种形式的要求：简单要求、类型要求、复合要求与嵌套要求，它们分别应对不同场景。</p>
<h4 id="2-2-1-简单要求"><a href="#2-2-1-简单要求" class="headerlink" title="2.2.1 简单要求"></a>2.2.1 简单要求</h4><p>对于简单的要求，仅仅通过表达式就能表达。考虑定义一个机器的概念，能够上电与下电。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> M&gt;</span><br><span class="line"><span class="keyword">concept</span> Machine = <span class="built_in">requires</span>(M m) &#123;</span><br><span class="line">    m.<span class="built_in">powerUp</span>();   <span class="comment">// 需要存在的成员函数</span></span><br><span class="line">    m.<span class="built_in">powerDown</span>(); <span class="comment">// powerUp/powerDown</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及两个特性，首先通过 concept 定义机器概念，其次约束表达式为 requires 表达式，它声明了模板参数 <code>M</code> 的局部对象 <code>m</code>，然后在表达式体中提出了两个要求，分别是能够使用对象的上下电接口。</p>
<p>对约束表达式求值的过程中并不会去创建对象，因此我们可以使用简单的值语义，而无须添加额外的引用或者指针形式，这样代码更简洁。此外也不会进行接口调用，仅仅是依据表达式是否合法来确认是否满足要求。</p>
<p>有时候我们要求模板参数的对象含有相关的自由函数，以及含有静态成员函数，或者成员变量，这些要求都可以通过下面这种形式来表达。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Animal = <span class="built_in">requires</span>(T a, T b, T c) &#123;</span><br><span class="line">    <span class="built_in">play</span>(animal);      <span class="comment">// 要求存在自由函数 play</span></span><br><span class="line">    T::count;          <span class="comment">// 存在静态成员 count</span></span><br><span class="line">    animal.age;        <span class="comment">// 要求存在成员变量 age</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>又或者需要进行复杂的操作符运算时，可以声明几个对象，并在提出要求的同时表达对象之间的操作。目的只是检查表达式的合法性，不会去进行真正的计算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Number = <span class="built_in">requires</span>(T a, T b, T c) &#123;</span><br><span class="line">    a == a;     <span class="comment">// 要求对象能进行判等操作</span></span><br><span class="line">    a + b * c;  <span class="comment">// 要求对象能够进行加、乘操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-类型要求"><a href="#2-2-2-类型要求" class="headerlink" title="2.2.2 类型要求"></a>2.2.2 类型要求</h4><p>简单要求虽然可以表达对象的成员函数、成员变量，但无法表达对象的类成员。类型要求可以表达一个类型是否含有成员类型，该类型是否能够和其他模板类型组合等。考虑如下情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> C = <span class="keyword">requires</span> &#123;</span><br><span class="line">    <span class="keyword">typename</span> T::type;    <span class="comment">// 要求存在类型成员 type</span></span><br><span class="line">    <span class="keyword">typename</span> vector&lt;T&gt;;  <span class="comment">// 要求能够与 vector 组合，能够模板实例化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123; <span class="keyword">using</span> type = first; &#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(C&lt;Foo&gt;);</span><br></pre></td></tr></table></figure>

<p>这段代码中的 requires 表达式无须引入局部变量，直接对类型提出要求即可。表达式体中使用关键字 typename 来表达它是一个类型要求。</p>
<h4 id="2-2-3-复合要求"><a href="#2-2-3-复合要求" class="headerlink" title="2.2.3 复合要求"></a>2.2.3 复合要求</h4><p>有时候我们会希望一个表达式的类型也能够符合要求，例如要求函数的返回类型为 int，希望表达式不会抛异常等，这时候可以使用复合要求来表达。复合要求的语法如下。</p>
<p><code>&#123; 表达式 &#125; 可选的 noexcept，可选的返回类型概念要求</code></p>
<p>复合要求需要用大括号将表达式括起来，最简单的复合要求和简单要求几乎没什么区别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> M&gt;</span><br><span class="line"><span class="keyword">concept</span> Machine = <span class="built_in">requires</span>(M m) &#123;</span><br><span class="line">    &#123; m.<span class="built_in">powerUp</span>() &#125;;   <span class="comment">// 需要存在成员函数</span></span><br><span class="line">    &#123; m.<span class="built_in">powerDown</span>() &#125;; <span class="comment">// powerUp/powerDown</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果要求表达式不能抛异常，这时候 <code>noexcept</code> 关键字便派上了用场。考虑定义一个概念 <code>Movable</code>，要求对象之间的移动禁止抛异常。当用户自定义移动赋值操作符而忘记声明 <code>noexcept</code> 时，将无法通过约束的检查。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Movable = <span class="built_in">requires</span>(T a, T b) &#123;</span><br><span class="line">    &#123; a = std::<span class="built_in">move</span>(b) &#125; <span class="keyword">noexcept</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们对一个表达式的类型提出要求时，有两个问题需要考虑。首先，是明确要求为某个确定的类型；其次，是由于在 C++ 中允许类型转换，对表达式的类型要求可以稍微放宽，只要能隐式转换到要求的类型即可。</p>
<p>C++ 标准库 <code>&lt;concepts&gt;</code> 提供了两个概念 <code>same_as</code> 和 <code>convertible_to</code> 来分别表达这两种情况，它们的声明如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">concept</span> same_as = <span class="comment">/*...*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _From, <span class="keyword">typename</span> _To&gt;</span><br><span class="line"><span class="keyword">concept</span> convertible_to = <span class="comment">/*...*/</span>;</span><br></pre></td></tr></table></figure>

<p>借助这两个概念的帮助，我们可以定义如下的概念。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> C = <span class="built_in">requires</span>(T x) &#123;</span><br><span class="line">    &#123; <span class="built_in">f</span>(x) &#125; -&gt; same_as&lt;T&gt;;             <span class="comment">// 要求 f(x) 的返回类型与 x 类型一致</span></span><br><span class="line">    &#123; <span class="built_in">g</span>(x) &#125; -&gt; convertible_to&lt;<span class="type">double</span>&gt;; <span class="comment">// 要求 g(x) 的返回类型能够转换成 double</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用箭头“-&gt;”来表达对表达式类型的要求，后面紧接着的是需要满足的概念。值得注意的是，这两个概念本应该接受两个模板类型参数，为何这里只需要提供一个？其实这是 concept 的性质，它会将表达式的类型补充到概念的第一个参数，如果读者将 <code>same_as</code> 替换成元函数 <code>is_same_v</code> 那么编译时将提示需要提供两个类型参数。上述代码等价于如下形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> C = <span class="built_in">requires</span>(T x) &#123;</span><br><span class="line">    <span class="built_in">f</span>(x); <span class="keyword">requires</span> same_as&lt;<span class="keyword">decltype</span>((<span class="built_in">f</span>(x))), T&gt;;</span><br><span class="line">    <span class="built_in">g</span>(x); <span class="keyword">requires</span> convertible_to&lt;<span class="keyword">decltype</span>((<span class="built_in">g</span>(x))), <span class="type">double</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>细心的读者会发现 requires 表达式体中又出现了 requires 关键字，这正是下一小节将介绍的嵌套要求。</p>
<h4 id="2-2-4-嵌套要求"><a href="#2-2-4-嵌套要求" class="headerlink" title="2.2.4 嵌套要求"></a>2.2.4 嵌套要求</h4><p>除了前面几种要求，最后一种是嵌套要求，它在表达式体中通过 requires 连接一个编译时常量谓词来表达额外的约束。根据定义，嵌套要求的额外约束有如下几种形式。</p>
<ul>
<li>type traits。</li>
<li>concept。</li>
<li>requires 表达式。</li>
<li>constexpr 值或函数。</li>
</ul>
<p>requires 表达式体通常只检查表达式的合法性，而嵌套要求的谓词约束则通过对表达式求值来确认是否满足要求。在 2.2.3 节中我们不仅要求 <code>f(x)</code> 表达式有效，还通过 <code>requires same_as&lt;decltype（f(x)）, T&gt;</code> 嵌套要求 <code>same_as</code> 的概念为真。</p>
<p>通过嵌套要求定义一个概念，它要求给定的类型大小大于指针大小，并且是平凡的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> C = <span class="keyword">requires</span> &#123; <span class="comment">// 使用嵌套要求连接编译期谓词</span></span><br><span class="line">    <span class="keyword">requires</span> <span class="built_in">sizeof</span>(T) &gt; <span class="built_in">sizeof</span>(<span class="type">void</span>*);</span><br><span class="line">    <span class="keyword">requires</span> is_trivial_v&lt;T&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-注意事项"><a href="#2-2-5-注意事项" class="headerlink" title="2.2.5 注意事项"></a>2.2.5 注意事项</h4><p>本小节介绍 requires 表达式的一些特殊性质，以及使用的时候需要注意的地方。requires 表达式为编译时谓词，它不一定需要在 concept 定义的时候出现，只要是能够接受布尔表达式的地方都允许它的存在。</p>
<p>最容易想到的是在定义变量模板的时候，判断给定类型是否存在成员函数 swap。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> has_member_swap = <span class="built_in">requires</span>(T a, T b) &#123;</span><br><span class="line">    a.<span class="built_in">swap</span>(b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>requires 表达式难道只能对模板参数或者其对象提出要求么？如果对具体类型提出要求又会怎么样？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> has_int_member_swap = <span class="built_in">requires</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    a.<span class="built_in">swap</span>(b); <span class="comment">// member reference base type &#x27;int&#x27; is not a structure or union</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从设计角度来看。requires 表达式是服务于模板参数约束的，结果是编译错误而不是返回不满足（假）。除了支持类模板参数外，它还支持非类型模板参数，考虑定义一个偶数概念，要求输入的模板参数为偶数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">concept</span> Even = <span class="keyword">requires</span> &#123;</span><br><span class="line">    <span class="built_in">requires</span> (N % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在模板函数 <code>if constexpr</code> 中，也有可能出现 requires 表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clever_swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">requires</span>(T a, T b) &#123; a.swap(b); &#125;)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了以上场景外，还有很多地方能够接受布尔表达式，例如非类型模板参数中，定义 constexpr 谓词函数时，<code>static_assert</code> 中，实现 type traits 时，还有后面将介绍的 requires 子句等。一个容易混淆的地方是简单要求与嵌套要求中对布尔表达式的约束，考虑如下两种形式的差异。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">requires</span> &#123;</span><br><span class="line">    布尔表达式; <span class="comment">// 只检查表达式的合法性</span></span><br><span class="line">    <span class="keyword">requires</span> 布尔表达式; <span class="comment">// 在合法性基础上求值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用户写了如下代码，那么很可能违背约束条件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">requires</span> &#123; <span class="comment">// 永远满足</span></span><br><span class="line">    <span class="built_in">sizeof</span>(T) &lt;= <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户可能要求模板类型 T 的大小不应该超过 int 的大小，然而从编译器的角度来看，这仅仅是检查表达式的合法性，对 sizeof 的结果进行比较是永远满足的。想达成用户的意图应该是用嵌套要求，让编译器进一步对这个布尔表达式进行求值判断以查看其是否满足。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">requires</span> &#123; <span class="comment">// 对布尔表达式进行求值</span></span><br><span class="line">    <span class="function"><span class="keyword">requires</span> <span class="title">sizeof</span><span class="params">(T)</span> &lt;</span>= <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个容易出错的地方在于嵌套要求可以接受一个 requires 表达式，考虑如下代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">requires</span> (T v) &#123; <span class="comment">// 仅仅检查如下 requires 表达式是否合法</span></span><br><span class="line">    <span class="built_in">requires</span> (<span class="keyword">typename</span> T::value_type x) &#123; ++x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过分析会发现，以上代码表达式体中的 requires 并不是表达嵌套要求，而是简单要求形式，仅仅检查了表达式体中的 requires 表达式是否合法。好在 C++ 标准不接受这种代码，只要是以 requires 开头的代码都会被当作嵌套要求处理，其后还紧接着一个编译时谓词；现有的编译器实现也会对该代码报错。这时需要通过添加 requires 前缀进一步表达嵌套要求，具体代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">requires</span> (T v) &#123; <span class="comment">// 嵌套要求，接受一个 requires 表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">requires</span> <span class="title">requires</span> <span class="params">(<span class="keyword">typename</span> T::value_type x)</span> </span>&#123; ++x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一个需要注意的地方是，requires 表达式的可选形参列表中可能涉及非法表达式的问题，考虑如下代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 若不存在关联类型 value_type 则编译错误</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> P = <span class="built_in">requires</span>(<span class="keyword">typename</span> T::value_type v) &#123; ++v; &#125;;</span><br></pre></td></tr></table></figure>

<p>形参 v 是否有效取，决于类型 T 是否含有类型成员 value_type，在形参无效的情况下，requires 表达式是否应该返回不满足（假）？根据 C++ 标准提到，编译器仅检查 requires 表达式体中的表达式要求是否合法，如果形参列表中的表达式非法，那么程序非良构，所以上述代码将产生一个编译错误。</p>
<p>如果使用 concept 定义，那么在可选的形参无效的情况下，requires 表达式将返回假，不过这是 concept 的特殊性质，和 requires 表达式无关。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 若不存在关联类型 value_type 则编译错误</span></span><br><span class="line"><span class="keyword">concept</span> P = <span class="built_in">requires</span>(<span class="keyword">typename</span> T::value_type v) &#123; ++v; &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-requires子句"><a href="#2-3-requires子句" class="headerlink" title="2.3 requires子句"></a>2.3 requires子句</h3><p>我们通过 concept、requires 表达式、constexpr 谓词常量或函数及 type traits 能够定义对类型的谓词，本节将介绍如何应用这些编译期谓词对模板参数添加约束，所有可以用来实例化这个模板的参数都必须满足这些约束。</p>
<p>使用 requires 子句可以为一个模板类或者模板函数添加约束，考虑如下代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> is_integral_v&lt;T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">gcd</span><span class="params">(T a, T b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">gcd</span>(<span class="number">1.0</span>, <span class="number">2.0</span>); <span class="comment">// use of function &#x27;T gcd(T, T) [with T = double]&#x27;</span></span><br><span class="line">               <span class="comment">// with unsatisfied constraints</span></span><br><span class="line"><span class="built_in">gcd</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>模板头中额外的 requires 子句表达了模板参数应该在什么条件下工作，同样地，它还可以接受一个约束表达式。当我们错误地使用受约束的 gcd 函数，编译器将产生一个友好的错误信息。设计 requires 子句的意图是判断它所约束的声明在某些上下文中是否可行。对于函数模板而言，上下文是在执行重载决议中进行的；对于模板类而言，是在决策合适的特化版本中；对于模板类中的成员函数而言，是决策当显式实例化时是否生成该函数。</p>
<p>我们讨论第一个场景，在重载决议中，考虑如下代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 受约束版本</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> is_trivial_v&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 通用版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(vector&lt;<span class="type">int</span>&gt;&#123;&#125;); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>这里提供了两个模板函数f，前者要求类型是平凡的，后者则没有任何约束。当对函数进行调用时，传递一个非平凡对象 <code>vector&lt;int&gt;</code>，由于候选集中的第一个可行函数的类型不满足要求，将其从候选集中删除，只剩下一个不受约束的版本，因此重载决议没有产生歧义，最终输出的结果为 2。</p>
<p>这里的关键在于违反约束本身并不是一个错误，除非候选集中没有可行函数了，但那是另一回事。上述情况也可以被看作 SFINAE，但我们不需要继续使用诸如 enable_if 等变通方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 曾经的元编程技巧：enable_if</span></span><br><span class="line"><span class="type">enable_if_t</span>&lt;is_trivial_v&lt;T&gt;&gt; <span class="built_in">f</span>(T) &#123; std::cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 否定条件</span></span><br><span class="line"><span class="type">enable_if_t</span>&lt;!is_trivial_v&lt;T&gt;&gt; <span class="built_in">f</span>(T) &#123; std::cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; std::endl; &#125;</span><br></pre></td></tr></table></figure>

<p>enable_if 提供的可行函数之间的条件必须两两互斥，以避免重载决策上的歧义。而 concept 本身存在优先级机制，这一机制能避免上述问题，这是重大的改进。</p>
<p>在概念标准化之前，除了 enable_if 之外，人们常常使用 decltype 操作符与表达式进行组合来决策重载函数，考虑如下代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 如果类型提供了成员函数 OnInit，决策这个版本</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">initialize</span><span class="params">(T&amp; obj)</span> -&gt; <span class="title">decltype</span><span class="params">(obj.OnInit())</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> obj.<span class="built_in">OnInit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 决策什么也不做的版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">(...)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; std::endl; &#125;</span><br></pre></td></tr></table></figure>

<p>如果用户提供的类型拥有成员函数 <code>OnInit</code>，那么候选集中的这两个函数都可行，根据重载决议的规则，不定参数函数的优先级较低，编译器将选择正确的第一个版本；若用户提供的类型没有该成员函数，那么第一个版本将触发 SFINAE 机制，候选集中仅剩下第二个版本的函数，最终将什么也不做。</p>
<p>如果使用 requires 子句结合 requires 表达式来实现将更加合理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 使用 requires 子句，连接一个 requires 表达式</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> <span class="title">requires</span><span class="params">(T obj)</span> </span>&#123; obj.<span class="built_in">OnInit</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; obj)</span> </span>&#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    obj.<span class="built_in">OnInit</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 什么也不做的版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; std::endl; &#125;</span><br></pre></td></tr></table></figure>

<p>如果用户提供的类型拥有成员函数 <code>OnInit</code>，那么候选集中这两个函数都可行，根据标准，受约束的函数比未受约束的更优，编译器将选择正确的第一个版本；若用户提供的类型没有该成员函数，第一个版本不符合要求，候选集中仅剩下第二个版本的函数，同理最终将什么也不做。</p>
<p>从这两个例子中我们能够看到 concept 特性所带来的优势，它不需要那么多元编程技巧，让新人也能够容易接受、上手，而无须理解变通技巧中涉及的一些隐晦问题。</p>
<p>requires 子句拥有和 concept 类似的性质，考虑如下代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> is_integral_v&lt;<span class="keyword">typename</span> T::type&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当用户对该函数进行调用时，首先检查表达式是否合法，如果模板参数类型没有类型成员 <code>type</code>，将不满足要求；否则进一步判断类型成员是否为整数类型，如果是则满足要求，函数能够被正常调用，否则不满足要求，产生编译错误。</p>
<p>当对 requires 子句中的约束使用否定时需要额外注意，它可能并不是在表达否定的意思，回忆在 2.1 节提到的一个例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">requires</span>(!is_integral_v&lt;<span class="keyword">typename</span> T::type&gt;)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span></span>;</span><br></pre></td></tr></table></figure>

<p>程序员可能把这个否定理解为“要求模板参数类型没有类型成员 <code>type</code> 或类型成员不为整数”，而它真正的语义为“要求模板参数类型拥有类型成员 <code>type</code> 且类型成员不为整数”，如果需要表达前者语义，可以参考 2.1 节提到的方式，这里不再赘述。</p>
<p>可能有读者注意到了 requires 子句中对约束的否定使用了圆括号，这是因为编译器对代码进行解析的过程中存在困难，考虑如下代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">P</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> <span class="title">P</span><span class="params">(<span class="number">0</span>)</span> <span class="comment">// 语法错误，P(0) 需要通过括号括起来</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T )</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>编译器在解析这段代码时，遇到约束 <code>P(0)</code> 会认为这是一个类型转换表达式，将数值类型转换成其他类型 <code>P</code>，然而实际上表达的是一个谓词函数调用，这时候需要通过括号将 <code>P(0)</code> 括起来。好在编译器又足够智能，能通过错误信息提醒用户更正这个错误。</p>
<p>requires 子句中的约束表达式也支持对约束进行合取与析取操作。除了通过 requires 子句引入约束之外，在简单情况下还可以通过更简洁的语法来引入约束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;integral T, integral U&gt;</span><br><span class="line"><span class="comment">// requires(integral&lt;T&gt; &amp;&amp; integral&lt;U&gt;)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T, U)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们可以看到关键字 typename 被替换成了概念 <code>integral</code>，对多个模板参数添加概念约束，将产生一个约束合取表达式，正如注释中提到的一样。此外，不需要填充概念中的模板参数，根据 concept 的性质它会自动将模板参数补充到概念中第一个参数位置，这是 type traits 做不到的。</p>
<p>另一方面也说明了，不需要通过 requires 子句也能施加约束。约束的合取比较容易得到，而约束的析取需要通过 requires 子句才能得到。</p>
<p>如不关心模板参数类型，则 C++20 模板函数的参数可以使用 auto 来简化，并同时支持添加约束。如下函数原型和上面一样。</p>
<p><code>void f(integral auto a, integral auto b);</code></p>
<p>此外，泛型 lambda 也能够通过使用概念进行约束。</p>
<p><code>auto f = [](integral auto lhs, integral auto rhs) &#123; return lhs + rhs; &#125;;</code></p>
<p>前面提到模板类与它的特化版本能够通过 requires 子句施加约束，根据约束比较规则可以决策出约束最强的版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Optional</span> &#123; <span class="comment">// 主模板</span></span><br><span class="line">    <span class="keyword">union</span> &#123; T val; <span class="type">char</span> dummy; &#125; storage_;</span><br><span class="line">    <span class="type">bool</span> initialized_&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> is_trivial_v&lt;T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Optional</span>&lt;T&gt; &#123; <span class="comment">// 受约束的特化版本</span></span><br><span class="line">    T storage_;</span><br><span class="line">    <span class="type">bool</span> initialized_&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用 <code>Optional&lt;int&gt;</code>，因为 int 类型为平凡类型，符合特化版本中的约束要求，那么将决策特化版本而不是更一般的版本，这样能够有针对性地进行优化。在传统的元编程技巧中，常常使用 <code>enable_if_t</code> 与 <code>void_t</code> 进行特化版本的决策，通过使用约束方式降低了程序员学习的难度。</p>
<p>当对模板类型进行显式实例化时，若受约束的成员函数不符合要求，编译器将不为这个函数生成代码，这是 <code>enable_if_t</code> 做不到的地方。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    T value_;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">requires</span> is_invocable_v&lt;T&gt;</span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">value_</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T v)</span> </span>&#123; value_ = v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化，由于不满足约束，不生成成员函数 operator()()</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">Wrapper</span>&lt;<span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>这里的 requires 子句写在了函数声明后，当对该模板类进行实例化时，由于成员函数 <code>operator()()</code> 不满足要求，编译器将不为它生成代码。</p>
<h3 id="2-4-约束的偏序规则"><a href="#2-4-约束的偏序规则" class="headerlink" title="2.4 约束的偏序规则"></a>2.4 约束的偏序规则</h3><p>在前一节我们看到了通过给模板施加约束，受约束的版本比未受约束的版本更优，如果两个版本同样含有约束且都满足，哪个最优呢？</p>
<p>之所以会有这个问题，要回到 C++ 最初的标准模板库中的设计，迭代器是算法与容器之间的桥梁，并且分为几类。同一个算法针对不同类的迭代器中拥有不同的高效实现：如 rotate 旋转算法在随机访问迭代器、双向迭代器、单向迭代器中拥有不同的实现，其中随机访问迭代器的效率最高。</p>
<p>如果一个随机访问迭代器使用了单向迭代器的算法，那么效率不是最优。在 C++11 之前。使用标签分发技术来决策最优算法，迭代器种类标签之间存在继承关系，重载决议时通过比较规则决策出正确的版本；在 C++17 中，可以使用 if constexpr 来决策最优算法；进入 C++20 后，则使用概念约束进行决策。</p>
<p>在 C++ 的概念特性发展历史中，它曾经支持以继承形式扩展，这被称为概念改良。概念继承形式能够比较自然地表达合取关系，但在表达析取关系就不那么自然了。因此在 C++20 标准中废除了这一形式，而是采用更加自然的合取与析取关系。</p>
<p>在模板函数重载决议与类模板特化决策中，约束的合取与析取关系以及 concept 扮演至关重要的角色，对于两个约束都满足的模板，可以通过约束的偏序规则决策出谁最优。</p>
<h4 id="2-4-1-约束表达式归一化"><a href="#2-4-1-约束表达式归一化" class="headerlink" title="2.4.1 约束表达式归一化"></a>2.4.1 约束表达式归一化</h4><p>对于受约束的模板函数、模板类而言，施加的约束表达式被称为关联约束（associated constraint），为了进一步判断是否满足约束以及谁更优，需要将关联约束分解成原子约束的合取与析取形式，这个过程被称为归一化（normalization）。</p>
<p>前面提到 concept 只是约束表达式的别名，在归一化过程中会对 concept 进行展开，展开后的约束表达式若包含 concept，则会进一步递归展开。直到所有的约束都无法进一步展开，这些约束即为原子约束，那么最终的形式就是原子约束的合取与析取表达式。每个原子约束既不是合取也不是析取形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">concept</span> C1 = <span class="built_in">sizeof</span>(T) == <span class="number">1</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">concept</span> C2 = C1&lt;T&gt; &amp;&amp; <span class="number">1</span> == <span class="number">2</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">concept</span> C3 = <span class="built_in">requires</span> (T x) &#123; ++x; &#125; || C2&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;C2 T&gt; <span class="type">void</span> <span class="title">f1</span><span class="params">(T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;C3 T&gt; <span class="type">void</span> <span class="title">f2</span><span class="params">(T)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数 f1 的关联约束为 <code>C2&lt;T&gt;</code>，为了判断关联约束是否满足要求，将对它进行归一化，展开过程如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C2 =&gt; C1&lt;T&gt; ∧ <span class="number">1</span> == <span class="number">2</span> <span class="comment">// 再次递归展开</span></span><br><span class="line">   =&gt; (<span class="built_in">sizeof</span>(T) == <span class="number">1</span>) ∧ (<span class="number">1</span> ==<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>最终形式是原子约束 <code>sizeof(T)==1</code> 与原子约束 <code>1==2</code> 的合取形式，归一化过程在模板参数替换时没有产生非法表达式，这时进行最终的求值，可以发现约束不满足。函数 <code>f2</code> 的关联约束为 <code>C3&lt;T&gt;</code>，归一化过程类似。需要注意 requires 表达式、约束的否定是原子约束，最终结果为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C3&lt;T&gt; =&gt; <span class="built_in">requires</span> (T x) &#123; ++x; &#125; ∨ ((<span class="built_in">sizeof</span>(T) == <span class="number">1</span>) ∧ (<span class="number">1</span> == <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-简单约束的包含关系"><a href="#2-4-2-简单约束的包含关系" class="headerlink" title="2.4.2 简单约束的包含关系"></a>2.4.2 简单约束的包含关系</h4><p>对于同样满足要求的两个约束表达式的关系，C++ 标准中拥有更正式的规则来描述，本小节首先考虑简单的合取与析取表达式。</p>
<p>约束表达式 <code>P</code> 与 <code>Q</code> 的偏序关系也被称为包含关系（subsumption），如果它们拥有包含关系，若 <code>P</code> 包含 <code>Q</code> 而 <code>Q</code> 不包含 <code>P</code>，则 <code>P</code> 比 <code>Q</code> 更优；反之，<code>Q</code> 比 <code>P</code> 更优。<code>P</code> 和 <code>Q</code> 可能没有包含关系，那么将产生决议歧义的编译错误。</p>
<p>约束表达式 <code>P</code> 包含 <code>Q</code>，当且仅当 <code>P</code> 满足要求时 <code>Q</code> 也满足；<code>Q</code> 不包含 <code>P</code>，则当 <code>Q</code> 满足时 <code>P</code> 不一定满足。考虑如下两个约束表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> EqualityComparable = <span class="comment">/*...*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> TotallyOrdered = EqualityComparable&lt;T&gt; &amp;&amp; PartiallyOrderedWith&lt;T, T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;EqualityComparable T&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span></span>; <span class="comment">// #1</span></span><br><span class="line"><span class="keyword">template</span> &lt;TotallyOrdered T&gt;     <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span></span>; <span class="comment">// #2</span></span><br></pre></td></tr></table></figure>

<p>当 <code>TotallyOrdered&lt;T&gt;</code> 所指的约束合取表达式满足要求时，意味着它的两个约束都为真，可以得出 <code>EqualityComparable&lt;T&gt;</code> 满足要求，因此 <code>TotallyOrdered&lt;T&gt;</code> 包含 <code>EqualityComparable&lt;T&gt;</code>。</p>
<p>当 <code>EqualityComparable&lt;T&gt;</code> 所指的约束表达式满足要求时，不能得出 <code>TotallyOrdered&lt;T&gt;</code> 也满足要求，因此 <code>EqualityComparable&lt;T&gt;</code> 不包含 <code>TotallyOrdered&lt;T&gt;</code>（见图 3.1）。</p>
<p>图3.1约束的合取包含关系</p>
<p>在对两个都满足约束的函数 f 决议中，将决出更优的第二个版本。</p>
<p>再来看看约束析取表达式，同样给出两个约束表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> FloatingPoint = is_floating_point_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Arithmetic = FloatingPoint&lt;T&gt; || Integral&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;FloatingPoint T&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span></span>; <span class="comment">// #1</span></span><br><span class="line"><span class="keyword">template</span> &lt;Arithmetic T&gt;    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span></span>; <span class="comment">// #2</span></span><br></pre></td></tr></table></figure>

<p>当 <code>Arithmetic&lt;T&gt;</code> 所指的约束表达式满足要求时，意味着它的两个约束中至少有一个为真，不能得出 <code>FloatingPoint&lt;T&gt;</code> 也满足要求，因此 <code>Arithmetic&lt;T&gt;</code> 不包含 <code>FloatingPoint&lt;T&gt;</code>。</p>
<p>当 <code>FloatingPoint&lt;T&gt;</code> 所指的约束合取表达式满足要求时，得出 <code>Arithmetic&lt;T&gt;</code> 满足要求，因此 <code>FloatingPoint&lt;T&gt;</code> 包含 <code>Arithmetic&lt;T&gt;</code>（见图 3.2）。</p>
<p>图 3.2 约束的析取包含关系<br>在对两个都满足约束的函数 <code>f</code> 的决议中，将决策出第一个版本更优。</p>
<p>通过这两个例子我们可以发现，约束的合取形式 <code>R∧S</code> 要比 <code>R</code> 更优，而析取形式 <code>R</code> 要比 <code>R∨S</code> 更优。</p>
<h4 id="2-4-3一般约束的包含关系"><a href="#2-4-3一般约束的包含关系" class="headerlink" title="2.4.3一般约束的包含关系"></a>2.4.3一般约束的包含关系</h4><p>上一小节介绍了简单约束表达式的包含关系，这一节将介绍更为通用的规则，当编译器面临复杂的约束表达式时，是如何决策出最优的。</p>
<p>首先，考虑如下两个约束表达式，谁更优？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// P</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span> <span class="keyword">requires</span> is_integral_v&lt;T&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// Q</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span> <span class="keyword">requires</span> is_integral_v&lt;T&gt; &amp;&amp; is_signed_v&lt;T&gt;</span>; <span class="comment">// #2</span></span><br></pre></td></tr></table></figure>

<p>当模板参数 <code>T</code> 为 <code>int</code> 时，这两个函数都满足要求，那么它们究竟谁更优呢？答案是由于编译错误，它们没有任何关系，无法决策出最优版本。2.4.2 节提到“约束的合取形式 <code>R∧S</code> 要比 <code>R</code> 更优”，为什么结论在这里不成立了？</p>
<p>其实不然，之前为了简化讨论，忽略了对约束表达式进行归一化的过程：约束表达式中的 concept（如果存在）会递归展开成最终原子约束的合取与析取形式。判断两个约束表达式之间 是否存在关系，需要进一步判断它们归一化后的原子约束之间是否存在相同（identical）关系。</p>
<p>原子约束 <code>Ai</code> 和 <code>Aj</code> 的相同关系被定义为：它们是否词法上相等且来自于同一个 concept。这个例子中的两个约束表达式都没有 concept，归一化后的原子约束表达式分别为：</p>
<p>原子约束表达式 <code>P</code> 和 <code>Q</code> 存在词法上相等的原子约束 <code>is_integral_v&lt;T&gt;</code>，但它们不是来自于同一个 concept ，因此这两个原子约束其实不相同，最终两个表达式没有包含关系，它们相当于“ <code>R∧S</code> 与 <code>T</code> 没有关系”，因此无法决策出谁最优。</p>
<p>使用 concept 改写这个例子，代码如下。</p>
<p>同样地，当模板参数 <code>T</code> 为 <code>int</code> 时，两个版本都满足要求，但是这次编译器选择了第二个版本作为更优的版本。对这两个原子约束表达式进行归一化，过程如下。</p>
<p>归一化后的结果和前面一样，唯一不同的是这期间 <code>Integral</code> 概念进行了展开：两个原子约束 <code>is_integral_v&lt;T&gt;</code> 来自于同一个概念 <code>Integral</code>。上一节的结论再次成立。</p>
<p>虽然我们能够一眼看出来谁更优，但是编译器却不那样认为。当使用 concept 时，编译器才会在需要的时候尝试计算它们之间的关系，这也是 concept 具有的独特性质。</p>
<p>更一般地，C++ 标准通过如下的规则来计算约束表达式 <code>P</code> 与 <code>Q</code> 之间的偏序关系。<code>P</code> 包含 <code>Q</code>，当且仅当 <code>P</code> 的析取范式中的每个析取子句Pi包含Q的合取范式的每个合取子句 <code>Qj</code>，那么 <code>P</code> 包含 <code>Q</code>。原子约束归一化后可以标准化为析取范式与合取范式，其中析取范式的析取子句为约束合取表达式，合取范式的合取子句为约束析取表达式。</p>
<p>考虑原子约束 A、B、C，归一化后的约束表达式 <code>A∧(B∨C)</code> ，将它写成析取范式时需要进一步转换成 <code>(A∧B)∨(A∧C)</code> ，它的两个析取子句分别为合取表达式 <code>A∧B</code> 和 <code>A∧C</code>；将它写成合取范式时为它本身，两个合取子句分别为析取表达式 <code>A</code> 和 <code>B∨C</code>。</p>
<p>析取子句 <code>Pi</code> 包含合取子句 <code>Qj</code> 当且仅当 <code>Pi</code> 存在一个原子约束 <code>Pia</code> 且 <code>Pia</code> 与 <code>Qj</code> 中的一个原子约束 <code>Qjb</code> 相同。</p>
<p>这些规则相当抽象，我们可以结合具体的例子来分析一下。</p>
<p>考虑归一化后约束表达式 <code>P=R∧S</code> 与 <code>Q=R</code>，首先判断 <code>P</code> 是否包含 <code>Q</code>，将 <code>P</code> 写成析取范式，它只有一个析取子句 <code>P0=R∧S</code>，将 <code>Q</code> 写成合取范式，同样只有一个合取子句 <code>Q0=R</code>，<code>P0</code> 和 <code>Q0</code> 存在相同的原子约束 <code>R</code>，因此 <code>P</code> 包含 <code>Q</code>；接下来判断 <code>Q</code> 是否包含 <code>P</code>，将 <code>Q</code> 写成析取范式，它只有一个析取子句 <code>Q0=R</code>，将 <code>P</code> 写成合取范式，它有两个合取子句 <code>P0=R</code> 与 <code>P1=S</code>，显然 <code>Q0</code> 包含 <code>P0</code>（因为存在相同的原子约束 <code>R</code>），而 <code>Q0</code> 不包含 <code>P1</code>（因为不存在相同的原子约束），最后得到 <code>Q</code> 不包含 <code>P</code>。综上所述，<code>R∧S</code> 要比 <code>R</code> 更优。</p>
<p>考虑归一化后约束表达式 <code>P=R∨S</code> 与 <code>Q=R</code>，首先判断 <code>P</code> 是否包含 <code>Q</code>，将 <code>P</code> 写成析取范式，它有两个析取子句 <code>P0=R</code> 与 <code>P1=S</code>，将 <code>Q</code> 写成合取范式，它只有一个合取子句 <code>Q0=R</code>，<code>P0</code>和 <code>Q0</code> 存在相同的原子约束 <code>R</code>，因此 <code>P0</code> 包含 <code>Q0</code>，而 <code>P1</code> 不包含 <code>Q0</code>（由于不存在相同的原子约束），因此 <code>P</code> 不包含 <code>Q</code>；接下来判断 <code>Q</code> 是否包含 <code>P</code>，将 <code>Q</code> 写成析取范式，它只有一个析取子句 <code>Q0=R</code>，将 <code>P</code> 写成合取范式，同样只有一个合取子句 <code>P0=R∨S</code>，显然 <code>Q0</code> 包含 <code>P0</code>（因为存在相同的原子约束 <code>R</code>），最后得到 <code>Q</code> 包含 <code>P</code>。综上所述，<code>R</code> 比 <code>R∨S</code> 要更优。</p>
<p>接下来考虑更为复杂的情况，考虑为一个假想的数学库提供概念设计，例如标量概念中要求为整数或者浮点类型。</p>
<p>该数学库考虑为用户提供的类型进行扩展，提供一个叫作 <code>MathematicalTraits</code> 的元函数，用户需要通过特化实现该元函数，以便让数学库识别。</p>
<p>同时，数学库提供了一个概念 <code>CustomMath</code> 用于识别给定类型是否为用户扩展的类型。最后，需要用一个概念 <code>Mathematical</code> 来表达要么为内置的标量类型，要么为用户扩展的自定义类型，即通过两个概念的析取来表达。</p>
<p>数学库提供了一个计算函数 <code>calculate</code>，它接受两个模板参数类型，对类型的约束为 <code>Mathematical</code>，关联约束为合取表达式。</p>
<p>这个计算函数要求的两个类型不一定一样，其中一个有可能属于标量类型，另一个属于自定义类型。该数学库可能会提供一个性能更优的计算函数的重载版本，只要给定的两个类型属于同一个概念：要么都属于标量概念 <code>Scalar</code>，要么都属于自定义概念 <code>CustomMath</code>。</p>
<p>当用户使用两个标量类型对该函数进行调用时，可发现两个候选函数都满足要求，那么究竟哪个更优呢？</p>
<p>首先，我们判断第二个重载版本的关联约束 <code>P</code> 是否包含第一个版本中的关联约束 <code>Q</code>。将 <code>P</code> 和 <code>Q</code> 分别写成析取范式与合取范式。</p>
<p>于是我们需要进一步判断P的每个析取子句 <code>Pi</code> 是否包含 <code>Q</code> 的每个合取子句 <code>Qj</code>，也就是证明如下命题都为真。</p>
<ul>
<li><code>P0</code> 包含 <code>Q0</code>。</li>
<li><code>P0</code> 包含 <code>Q1</code>。</li>
<li><code>P1</code> 包含 <code>Q0</code>。</li>
<li><code>P1</code> 包含 <code>Q1</code>。</li>
</ul>
<p>为了进一步证明 <code>Pi</code> 是否包含 <code>Qj</code>，需要在 <code>Pi</code> 中找到一个原子约束 <code>Pia</code> 使得，它与 <code>Qj</code> 中的原子约束 <code>Qjb</code> 相同。显然，我们可以找出它们共同的原子约束：</p>
<ul>
<li>对于 <code>P0</code> 与 <code>Q0</code> 而言，存在相同的原子约束 <code>Scalar&lt;T&gt;</code>。</li>
<li>对于 <code>P0</code> 与 <code>Q1</code> 而言，存在相同的原子约束 <code>Scalar&lt;U&gt;</code>。</li>
<li>对于 <code>P1</code> 与 <code>Q0</code> 而言，存在相同的原子约束 <code>CustomMath&lt;T&gt;</code>。</li>
<li>对于 <code>P1</code> 与 <code>Q1</code> 而言，存在相同的原子约束 <code>CustomMath&lt;U&gt;</code>。</li>
</ul>
<p>因此可以得出 <code>P</code> 包含 <code>Q</code> 的结论，为了证明 <code>P</code> 比 <code>Q</code> 更优而不是重载歧义，我们需要证明 <code>Q</code> 不包含 <code>P</code>。类似地，将 <code>Q</code> 和 <code>P</code> 分别写成析取范式与合取范式。</p>
<p>析取范式与合取范式互相转换，每个子句间的原子约束将两两分配，最终子句数量最多为原范式子句数量的指数级别。</p>
<p>在这个例子中 <code>Q</code> 的合取范式只有两个子句，每个子句由两个原子约束组成，转换成析取范式后各子句中的原子约束两两分配产生 $2^2&#x3D;4$ 个子句。</p>
<p><code>P</code> 的析取范式转换成合取范式也是类似的过程。</p>
<p>需要进一步判断 <code>Q</code> 的每个析取子句 <code>Qi</code> 是否包含 <code>P</code> 的每个合取子句 <code>Pj</code>，这需要证明 <code>16</code> 个命题，只要我们能够找到一个 <code>Qj</code> 不包含 <code>Pi</code> 即可证明 <code>Q</code> 不包含 <code>P</code>。仔细观察可以发现，<code>Q1</code> 与 <code>P2</code> 之间、<code>Q2</code> 与 <code>P1</code> 之间都不存在相同的原子约束，这就证明了 <code>Q</code> 不包含 <code>P</code>。</p>
<p>最后的结果符合我们的预期，第二个重载 <code>calculate</code> 函数为最优的候选函数，最终输出的结果为 <code>P</code>。</p>
<p>从这个过程中我们也能够发现，当涉及复杂的约束表达式时，编译器的计算量将大幅增加。约束合取表达式是难以避免的，因为可以通过多种方式引入，而约束析取表达式则没那么多。如果可能的话，应尽可能避免使用析取表达式，这将有助于减少编译器的计算量。</p>
<h4 id="2-4-4-using-类型别名与-concept-表达式别名"><a href="#2-4-4-using-类型别名与-concept-表达式别名" class="headerlink" title="2.4.4 using 类型别名与 concept 表达式别名"></a>2.4.4 using 类型别名与 concept 表达式别名</h4><p>前面提到 concept 作为表达式别名，其机制和 using 作为类型别名类似。C++ 中判断两个类型别名是否相同也是通过展开后判断词法与位置是否相等。考虑如下两个类型。</p>
<p>这里的类型别名 <code>A</code> 和 <code>B</code> 其实是一个类型，它们都为 <code>Point</code>。而如下两个类型却是不相同的类型，尽管它们词法上相等。</p>
<p>两个原子约束是否存在包含关系仅取决于它们是否相同，这就要求原子约束在词法上相等，并且来源于同一个 concept。</p>
<h3 id="2-5-概念标准库"><a href="#2-5-概念标准库" class="headerlink" title="2.5 概念标准库 &lt;concepts&gt;"></a>2.5 概念标准库 <code>&lt;concepts&gt;</code></h3><p>C++20 标准库 <code>&lt;concepts&gt;</code> 提供了一些基本的概念，用于在编译期对模板参数进行校验和基于概念的函数重载。标准库中的许多概念都有语法和语义上的要求，如果一个模板参数符合语法上的约束，那么它通常被称为“满足（satisfy）要求”。更进一步，如果模板参数符合语义上的约束，则被称为“对该概念进行建模（model）”。通常编译器只能检查语法上的要求，对于语义上的要求需要程序员自行检查。</p>
<p>本节将介绍一些常用的 concept，基于这些 concept 能够组合出更为强大的概念。</p>
<h4 id="2-5-1-same-as（与某类相同）"><a href="#2-5-1-same-as（与某类相同）" class="headerlink" title="2.5.1 same_as（与某类相同）"></a>2.5.1 same_as（与某类相同）</h4><p><code>same_as</code> 概念要求输入两个类型参数，借此判断这两个类型是否满足相同的约束。一个可能的实现如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">concept</span> same_as = is_same_v&lt;T, U&gt;;</span><br></pre></td></tr></table></figure>

<p>上述实现是有问题的，所以考虑要求两个模板参数类型一致的函数，并提供一个特别的重载版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">requires</span> same_as&lt;T, U&gt; <span class="comment">// P</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T, U)</span></span>; <span class="comment">// 一般的版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">requires</span> same_as&lt;U, T&gt; &amp;&amp; is_integral_v&lt;T&gt; <span class="comment">// Q</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T, U)</span></span>; <span class="comment">// 提个一个特别的版本</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，特别版本中的 requires 子句中的约束 <code>same_as</code> 的类型参数正好与一般的版本相反，前者为 <code>same_as&lt;U, T&gt;</code>，后者为 <code>same_as&lt;T, U&gt;</code>，根据 <code>same_as</code> 的对称性可知，两者应该<br>是一样的，当使用 <code>f(1, 1)</code> 时，预期应该决策使用特别的版本。</p>
<p>然而在编译器决策的时候发生了重载歧义，无法决策出最优的实现。分别将两个版本的约束表达式进行正规化后，得到如下结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P =&gt; same_as&lt;T, U&gt; =&gt; is_same_v&lt;T, U&gt;</span><br><span class="line">Q =&gt; same_as&lt;U, T&gt; ∧ is_integral_v&lt;T&gt; =&gt; is_same_v&lt;U, T&gt; ∧ is_integral_v&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>虽然这两个表达式最终的原子表达式 <code>is_same_v</code> 都来自于同一个概念 <code>same_as</code>，但是它们在词法上不相等，因此这两个原子约束不相同，也就没法进一步判断它们之间的偏序关系了。</p>
<p>为了解决这个问题，标准中通过添加一层间接层来解决，即引入额外的 concept。最后，<code>same_as</code> 的正确实现如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">concept</span> _same_as = is_same_v&lt;T, U&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">concept</span> same_as = _same_as&lt;T, U&gt; &amp;&amp; _same_as&lt;U, T&gt;;</span><br></pre></td></tr></table></figure>

<p>这表达了一种对称关系：<code>same_as&lt;T，U&gt;</code> 包含 <code>same_as&lt;U，T&gt;</code>，反之亦然。</p>
<h4 id="2-5-2-derived-from（派生自某类）"><a href="#2-5-2-derived-from（派生自某类）" class="headerlink" title="2.5.2 derived_from（派生自某类）"></a>2.5.2 derived_from（派生自某类）</h4><p><code>derived_from</code> 用于表达两个类之间是否存在 is-a 的关系，也就是判断两个类之间是否存在公有继承关系。在元编程场景中，通常定义一个空标签类来代表某一族类，然后同一族类派生自该特征标签，后续只需要判断某个类是否派生自该特征类即可判断是否为所需。</p>
<p><code>derived_from</code> 的实现比较简单，需要注意的是，同样的类在忽略 cv 修饰符的情况下也满足派生关系，这通过给类型都加上 cv 属性来保证。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> Base&gt;</span><br><span class="line"><span class="keyword">concept</span> derived_from = is_base_of_v&lt;Base, Derived&gt; &amp;&amp;</span><br><span class="line">                       is_convertible_v&lt;<span class="type">const</span> <span class="keyword">volatile</span> Derived*, </span><br><span class="line">                                        <span class="type">const</span> <span class="keyword">volatile</span> Base*&gt;;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-convertible-to（可转换为某类）"><a href="#2-5-3-convertible-to（可转换为某类）" class="headerlink" title="2.5.3 convertible_to（可转换为某类）"></a>2.5.3 convertible_to（可转换为某类）</h4><p>除了要求表达式的类型严格相同之外，另一个常见的场景是，只要一个表达式的类型能够通过隐式或显式转换成目标类型即可。语义上要求这两种转换方式的结果应该是相等的，这种情况可以使用<code>convertible_to</code> 来表达。</p>
<p><code>convertible_to</code> 的实现如下，通过约束合取来表达。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> From, <span class="keyword">typename</span> To&gt;</span><br><span class="line"><span class="keyword">concept</span> convertible_to = is_convertible_v&lt;From, To&gt; &amp;&amp; <span class="comment">// 隐式类型转换</span></span><br><span class="line">                         <span class="built_in">requires</span>(<span class="built_in">add_rvalue_reference_t</span>&lt;From&gt;(&amp;f)())</span><br><span class="line">                         &#123; <span class="built_in">static_cast</span>&lt;To&gt;(<span class="built_in">f</span>()); &#125;;    <span class="comment">// 显式类型转换</span></span><br></pre></td></tr></table></figure>

<p>第一个约束要求类型 <code>From</code> 能够通过隐式类型转换成 <code>To</code>，第二个约束根据 requires 表达式要求进行显式类型转换。</p>
<p>requires 表达式的形参列表中声明了一个无参函数类型，其返回类型为 <code>From&amp;&amp;</code>，通过符号 <code>f</code> 来指代这个函数。在表达式体中使用 <code>static_cast</code> 将函数调用的结果显式类型转换成 <code>To</code>，由于 requires 表达式为不求值环境，所以不会发生真正的函数调用。</p>
<p>为何需要进一步要求类型能够通过显式转换？什么类型能够通过隐式转换成目标类型但又无法通过显式转换？虽然在实际场景中几乎不可能出现这种类型，但是在 C++ 中，允许用户定义这种“奇怪”的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">To</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FROM&gt; <span class="comment">// 删除显式构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">To</span><span class="params">(FROM)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">From</span> &#123; <span class="comment">// 类型 From 能够隐式转换成 To</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">To</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们构造的这种“奇怪”类型 <code>To</code> 删除了显式类型转换构造函数，而另一个类型 <code>From</code> 拥有类型转换操作符，由于没有使用 <code>explicit</code> 修饰，所以能够隐式地转换成类型 <code>To</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>( is_convertible_v&lt;From, To&gt;);</span><br><span class="line"><span class="built_in">static_assert</span>(!is_convertible_v&lt;From, To&gt;);</span><br></pre></td></tr></table></figure>

<p>C++ 标准中正是考虑了这种能够通过隐式类型转换而无法通过显式类型转换的奇怪场景，才使用 <code>convertible_to</code> 的概念，这样我们在编写泛型代码时就无须考虑这种奇怪场景，它们将无法通过概念检查。</p>
<h4 id="2-5-4-算术概念"><a href="#2-5-4-算术概念" class="headerlink" title="2.5.4 算术概念"></a>2.5.4 算术概念</h4><p>在我们初学编程时常常会涉及一些基本的数据类型，这些数据类型被分为整数类和浮点类，整数类包含了 <code>char</code>、<code>short</code>、<code>int</code> 等，进一步可划分成有符号类和无符号类；浮点类包含了 <code>float</code>、<code>double</code> 等。它们统称为算术类型，根据这些概念不难定义出与之对应的 concept。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> integral = is_integral_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> signed_integral = integral&lt;T&gt; &amp;&amp; is_signed_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> unsigned_integral = integral&lt;T&gt; &amp;&amp; !is_signed_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> floating_point = is_floating_v&lt;T&gt;;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-5-值概念"><a href="#2-5-5-值概念" class="headerlink" title="2.5.5 值概念"></a>2.5.5 值概念</h4><p>在面向值语义编程与泛型编程时，常常会涉及一些相当重要的概念：<code>regular</code>（正则）与 <code>semiregular</code>（半正则）。</p>
<p><code>regular</code>（正则）的概念指的是一些类型看上去可以像基础数据（如 <code>int</code>）一样，能够进行默认构造、移动构造与赋值、拷贝构造与赋值，并且能够进行判等操作。标准库中的容器设计就使用了这个概念，这样对容器进行的一些操作与对基础数据类型进行的操作没什么区别，都能够以一致的形式编写泛型代码。</p>
<p><code>semiregular</code> 与 <code>regular</code> 类似，但放松了限制，无须支持判等操作。</p>
<h4 id="2-5-6-invocable（可调用的）"><a href="#2-5-6-invocable（可调用的）" class="headerlink" title="2.5.6 invocable（可调用的）"></a>2.5.6 invocable（可调用的）</h4><p>除了值和对象之外，还有一些编程元素如函数和函数对象，它们都属于 <code>invocable</code>（可调用）概念。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="keyword">concept</span> invocable = <span class="built_in">requires</span>(F&amp;&amp; f, Args&amp;&amp;...args) &#123;</span><br><span class="line">    <span class="built_in">invoke</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>若可调用类返回类型为 <code>bool</code>，那么也满足 <code>predicate</code>（谓词）的概念。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Fn, <span class="keyword">typename</span>..._Args&gt;</span><br><span class="line"><span class="keyword">concept</span> predicate = regular_invocable&lt;_Fn, _Args...&gt; &amp;&amp;</span><br><span class="line">                    _boolean_testable&lt;<span class="type">invoke_result_t</span>&lt;_Fn, _Args...&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>若一个谓词入参仅接受两个参数，那么也满足 <code>relation</code>（关系）的概念。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">concept</span> relation = predicate&lt;R, T, T&gt; &amp;&amp; predicate&lt;R, U, U&gt; &amp;&amp;</span><br><span class="line">                   predicate&lt;R, T, U&gt; &amp;&amp; predicate&lt;R, U, T&gt;;</span><br></pre></td></tr></table></figure>

<p>通过关系（relation）可以进一步定义等价关系（equivalence_relation）和弱序关系（strict_weak_order），这在 2.3.1 节中介绍过，这里不再赘述。虽然它们从语法定义上一样，但语义不同，正如程序员使用接口时需要关注它们的语义一样，使用概念同样也要关注语义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">concept</span> equivalence_relation = relation&lt;R, T, U&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">concept</span> strict_weak_order = relation&lt;R, T, U&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-综合运用之扩展-transform-变换算法"><a href="#2-6-综合运用之扩展-transform-变换算法" class="headerlink" title="2.6 综合运用之扩展 transform 变换算法"></a>2.6 综合运用之扩展 transform 变换算法</h3><p>C++ 标准库中的 <code>transform</code> 算法接受 1 到 2 个输入迭代器、一个输出迭代器与单元或二元函数对象，它在对这 1 到 2 输入迭代器迭代的过程中，将解引用后的值作为单元或二元函数对象的入参，并将二元函数的结果写到输出迭代器上。以下代码实现的功能是将字符串小写转换成大写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(), <span class="comment">// 一个输入迭代器与输出迭代器、单参函数</span></span><br><span class="line">          [](<span class="type">unsigned</span> <span class="type">char</span> c) -&gt; <span class="type">unsigned</span> <span class="type">char</span> &#123; <span class="keyword">return</span> std::<span class="built_in">toupper</span>(c); &#125;);</span><br></pre></td></tr></table></figure>

<p>本节的任务是扩展该算法，使其接受任意多个输入迭代器、一个输出迭代器并接受同等输入个数的函数对象，允许输入迭代器的长度不一致，这将以最短的迭代器作为结束。这个算法的名字也应该被命名为 <code>zip_transform</code>，它的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... InputIt, <span class="keyword">typename</span> Operation, <span class="keyword">typename</span> OutputIt&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">zip_transform</span><span class="params">(OutputIt out, Operation op,</span></span></span><br><span class="line"><span class="params"><span class="function">                       pair&lt;InputIt, InputIt&gt;... inputs)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里简单地使用 pair 类将输入迭代器的起始与终止部分打包，考虑可变参数必须作为函数最后的参数，它们也被放到了最后。但该模板函数没有任何约束，用户仅靠模板参数名来人为地遵守语义上的要求。通过使用 <code>&lt;concepts&gt;</code> 标准库中预定义的概念，添加约束如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    std::input_iterator...InputIt, <span class="comment">// 对 InputIt 进行输入迭代器约束</span></span><br><span class="line">    std::invocable&lt;std::<span class="type">iter_reference_t</span>&lt;InputIt&gt;...&gt; Operation, <span class="comment">// 对函数对象约束</span></span><br><span class="line">    std::output_iterator&lt;std::<span class="type">invoke_result_t</span>&lt;Operation, <span class="comment">// 对输出迭代器进行约束</span></span><br><span class="line">                                              std::<span class="type">iter_reference_t</span>&lt;InputIt&gt;...&gt;&gt; OutputIt</span><br><span class="line">&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">zip_transform</span><span class="params">(OutputIt out, Operation op, pair&lt;InputIt, InputIt&gt;...inputs)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这要求用户输入的参数必须满足输入迭代器的要求，并且函数对象的参数类型、个数、输入迭代器的解引用类型及个数都能够对应得上，同时还对输出迭代器进行了约束，要求其能够接受函数对象的返回类型。实现部分使用折叠表达式进行代码生成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OutputIt <span class="title">zip_transform</span><span class="params">(OutputIt out, Operation op, </span></span></span><br><span class="line"><span class="params"><span class="function">                       pair&lt;InputIt, InputIt&gt;... inputs)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (((inputs.first != inputs.second) &amp;&amp; ...))</span><br><span class="line">        *out++ = <span class="built_in">op</span>(*inputs.first++...);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个可能的用例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::vector v1 &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">std::vector v2 &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">std::vector v3 &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; v4 <span class="title">result</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">zip_transform</span>(result.<span class="built_in">begin</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) &#123; <span class="keyword">return</span> a + b + c; &#125;,</span><br><span class="line">              <span class="built_in">make_pair</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>()),</span><br><span class="line">              <span class="built_in">make_pair</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>()),</span><br><span class="line">              <span class="built_in">make_pair</span>(v3.<span class="built_in">begin</span>(), v3.<span class="built_in">end</span>())</span><br><span class="line">              );</span><br></pre></td></tr></table></figure>

<h3 id="2-7-注意事项"><a href="#2-7-注意事项" class="headerlink" title="2.7 注意事项"></a>2.7 注意事项</h3><p>如今已经有了很多惯用的手段来表达模板参数的接口，例如 Boost 专门有个 concept check 的库，语言提供了 <code>static_assert</code>、<code>constexpr</code> 函数与值、<code>if constexpr</code>，还有标准库提供的 <code>typetraits</code>，那么 concept 特性存在的必要性是什么？</p>
<p>这些技巧有些涉及模板的实例化阶段，而不是仅仅去检查模板参数的声明，这或多或少不够理想。此外，这些手段相当低级，有点类似于元编程世界中的汇编代码。但读者不要就此认为这些低级手段就足够用了，这就好比我们自认为只要拥有了 <code>if</code> 和 <code>goto</code> 语句后就不需要 <code>for</code>、<code>while</code> 语句。类似地，只要有了函数指针，虚函数与 <code>lambda</code> 就变得不再那么重要。C++ 不仅仅支持这些低级手段，它还是一门足够抽象的语言，因此：</p>
<ul>
<li>concept 并不是专门针对泛型编程的专家才能使用的高级特性。</li>
<li>concept 不仅仅是 <code>type traits</code>、<code>enable_if</code> 和标签分发等变通方法的语法糖。</li>
<li>concept 是最基础的语言特性，最好在最初模板特性出现的时候就使用它。</li>
</ul>
<p>如果 concept 在 20 世纪 90 年代就已经出现，那么今日的模板与模板库将会简单很多。好在最初的模板特性关键字为 <code>typename</code>：它仅要求模板参数为类型，因此一些老的模板库可以很容易与 concept 特性集成。</p>
<p>concept 仅对所约束的模板参数声明部分进行检查，而不会去检查函数体中该模板参数是否使用了未被约束的操作，考虑如下代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;integral T&gt;</span><br><span class="line"><span class="function">T <span class="title">mod2</span><span class="params">(T v)</span> </span>&#123; <span class="keyword">return</span> v % <span class="number">2</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>模板函数 <code>mod2</code> 仅检查模板参数 <code>T</code> 是否为整数概念 <code>integral</code>，而这个概念的定义并没有要求模板参数能够使用求余 <code>%</code> 操作，但在函数定义中使用未被约束的操作是允许的。</p>
<p>这也体现了一个设计层面的问题，是否应该将实现细节暴露给 concept？需要记住的是，实现并不是接口规范，如果有一天你发现一个更高效的实现，理想情况下是通过重构实现，而不是去影响它的接口，这样可以避免破坏用户的代码。若概念设计的要求太宽泛则起不到约束的作用，若设计得太细则难以应对各种变化，因此应该在保证语义一致性的前提下定义与使用 concept。</p>
<p>如果使用了概念中未被约束的操作，即使通过了约束检查，当该参数不支持这些操作时也会进一步导致模板实例化错误。不根据模板概念去检查模板的定义是一个深思熟虑的决定，而不是一个技术上不可行的问题。</p>
<p>concept 特性的贡献者们已经分析并尝试过，最终慎重地决定在 concept 的标准化中不包含这个功能，主要原因有以下几点。</p>
<ul>
<li>减轻最初设计的复杂度，不想进一步延期标准化，因为延期意味着一些反馈与库的建设将会进一步延后。</li>
<li>concept 的好处在于模板参数的接口规范化与模板使用之处检查。</li>
<li>能够在较早阶段发现错误而不是延迟到实例化阶段。</li>
<li>如果检查模板定义的话，将很难把未受约束的模板与模板库重构成基于 concept 的模板。</li>
<li>如果检查模板定义的话，很难在不修改 concept 接口的情况下对模板定义部分添加调试辅助、日志、性能打点等代码。</li>
<li>模板之间的调用会相当困难，一个受约束的模板只能调用另一个受约束的模板，这意味着新的基于 concept 的模板库将无法使用老的库，这是个非常严重的问题，原因在于不同的库是由不同组织开发的，而使用 concept 是一个渐进的过程。</li>
</ul>
<p>从上可见 C++ 是一门工程性非常强的语言，所有的特性引入都需要考虑是否破坏了已有代码，老代码能否容易迁移到新特性上，在以上问题未被恰当解决之前是不会去考虑那样做的。concept 曾经考虑通过定义检查将模板的声明与实现分离，而这会导致很多函数的间接调用，并严重影响最终代码的性能。一个可能的解决方案是将模板作为模块（module）特性的一部分，通过半编译形式实现。</p>
<p>concept 的设计提供了几种语法形式，从简洁到复杂的 requires 子句，因为简单的形式不可避免地限制了它的表达力，而通过复杂的形式表达简单的场景又增加了冗余的噪声。</p>
<p>在极少会出现两个概念语法一样而语义不同的情况，这就需要程序员手动将语义上的差别转换成语法上的差别：例如通过定义额外的方法或类型成员作为特征以便区分。此外，可以使用 <code>static_assert</code> 显式声明给定类型以满足概念上的要求。</p>
<p>concept 非常容易定义与使用，这极大改善了模板与泛型编程的代码质量。它就和基础的语言特性（诸如函数、类）一样，需要理解才能高效使用。与未受约束的模板相比，它们没有引入额外的运行时开销。这也符合 C++ 的设计原则：不要强迫程序员去做那些机器能做得更好的事，并且简单的事简单做，以及零成本抽象的哲学。</p>
<p>concept 解决了模板与泛型编程的很多痛点，它达到了最初所设想的 C++ 模板系统应有的样子，而不是语言特性的扩展。</p>
<p><em>本文摘自《C++20 高级编程》罗能&#x2F;著</em></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://qidianmaker.github.io">奇点创客</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://qidianmaker.github.io/2024/10/01/14%20C++%20%E6%A6%82%E5%BF%B5%E6%8E%A2%E7%A9%B6/">https://qidianmaker.github.io/2024/10/01/14%20C++%20%E6%A6%82%E5%BF%B5%E6%8E%A2%E7%A9%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://qidianmaker.github.io" target="_blank">奇点创客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E7%89%B9%E6%80%A7/">特性</a><a class="post-meta__tags" href="/tags/%E6%A8%A1%E6%9D%BF/">模板</a></div><div class="post-share"><div class="social-share" data-image="/img/14/cover.png" data-sites="wechat,qq,weibo,twitter,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/01/15%20C++%20%E5%80%BC%E7%B1%BB%E5%88%AB%E6%8E%A2%E7%A9%B6/" title="C++ 值类别探究"><img class="cover" src="/img/15/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C++ 值类别探究</div></div><div class="info-2"><div class="info-item-1">C++ 在演进过程中逐渐增强和拓展了对类型的处理能力。 由于表达式产生的中间结果会产生导致多余的拷贝，因而在 C++11 中引入了移动语义来解决这个问题，同时对值类别的左值、右值进行重新定义。需要注意的是，值类别指的是表达式结果的类别，并不是值对象、变量或者类型的类别。 对值类别的准确理解，是掌握移动语义的关键，能够帮我我们写出更优雅高效的代码，那么今天让我们一起来探究一下值类别。 1. 引用引用是 C 语言所没有的概念。而这个概念，比它表面看起来要复杂一些。 1.1 值与对象为了理解引用，我们需要首先搞清楚什么叫左值与右值 。 简而言之，左值是一种对象，而不是值。其与右值的关键区别在于，是否明确在内存中有其可访问的位置。即，其是否存在一个可访问的地址。如果有，那么它就是一个对象，也就是一个左值 ，否则，它就只是一个值，即右值。 比如：你不可能对整数 10 取地址，因而这个表达式是一个右值。但是如果你定义了一个变量： int a = 10; 变量 a 则代表一个对象，即左值。如果我们再进一步，表达式 a + 1 则是一个右值表达式，因为你无法对这个表达式取地址。 任何可以取地址的...</div></div></div></a><a class="pagination-related" href="/2024/09/01/13%20Boost%20%E5%BA%93%E6%A6%82%E8%A7%88/" title="Boost 库概览"><img class="cover" src="/img/13/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Boost 库概览</div></div><div class="info-2"><div class="info-item-1"> Boost 提供免费的同行评审的可移植 C++ 源代码库。 我们强调与 C++ 标准库配合良好的库。Boost 库旨在具有广泛的用途，并且可在广泛的应用程序中使用。Boost 许可证鼓励 所有用户以最小的限制使用 Boost 库。 我们的目标是建立“现有实践”并提供参考实现，以便 Boost 库适合最终标准化。从库技术报告(TR1) 中包含的 10 个 Boost 库开始，一直到 2011 年以来 C++ ISO 标准的每个版本，C++ 标准委员会一直依赖 Boost 作为标准 C++ 库补充的宝贵来源。 作为一个组织的 Boost Boost 组织和更广泛的 Boost 社区支持对 C++ 及其开发的库的最佳用途的研究和教育，特别是但不限于 Boost 库中包含的那些内容。 该组织和社区支持邮件列表和聊天室，为 Boost Libraries 和 C++ 用户提供有关最佳实践和尖端技术的教育。 本文档基于 Boost 1.83.0 按类别排序字符串和文本处理 Convert：一个可扩展且可配置的类型转换框架。 Format：格式化库，提供了一种类型安全机制，用于根据类似 pr...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/09/01/01%20C++%20%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%95%85%E4%BA%8B/" title="C++ 初始化的故事"><img class="cover" src="/img/01/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-01</div><div class="info-item-2">C++ 初始化的故事</div></div><div class="info-2"><div class="info-item-1">关于本书在 C++ 中，初始化是一个热门话题！互联网上充满了关于最佳实践的讨论，甚至还有关于这个主题的有趣的表情包。这种情况并不奇怪，因为有十几种方法可以初始化一个简单的整数值、有自动类型推断的复杂规则、数据成员和对象生命周期的细微差别。 于是，出现了这本书。 通过本文，你将学习在现代 C++ 中初始化各种类型的变量和数据成员的实用选项。具体来说，本书教授了多种类型的初始化、构造函数、非静态数据成员初始化、内联变量、指定初始化器等。此外，你将看到从 C++11 到 C++20 的变化和新技术，以及大量的示例来加强你的理解。 计划是解释初始化的大部分(如果不是全部的话)，学习许多优秀的 C++ 技术，并了解底层到底发生了什么。   为什么你需要阅读本书？使用现代 C++（从 C++11 开始），我们有许多新特性来简化工作和代码。改进的一个方面是初始化。现代 C++ 增加了新的初始化规则，试图在保持旧行为（主要来自 C 语言）兼容性的同时简化初始化。然而，有时规则可能看起来令人困惑和复杂，甚至 ISO 委员会也可能需要在此过程中纠正一些事情。这本书将帮助你浏览这些原则，以更好地理解这...</div></div></div></a><a class="pagination-related" href="/2023/10/01/02%20C++%20Lambda%20%E6%95%85%E4%BA%8B/" title="C++ Lambda 的故事"><img class="cover" src="/img/02/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-01</div><div class="info-item-2">C++ Lambda 的故事</div></div><div class="info-2"><div class="info-item-1"> C++98&#x2F;03 中的 Lambda作为开始，了解一些关于我们所讨论的主题的背景知识是很有必要的。为此，我们会转而回顾过去，看看那些不使用任何现代 C++ 技术的代码——即 C++98&#x2F;03 规范下的代码。 在本章中，我们将会学习：  如何将旧式的函数对象传给 C++ 标准库中的各种算法。 函数对象类型的限制。 为什么辅助函数不够好。 C++0x&#x2F;C++11 中引入 Lambda 的动机。  C++98&#x2F;03 中的可调用对象标准库的一个基本设计思想是：对于像 std::sort，std::for_each，std::transform 等这样的泛型函数，能够接受任何可调用对象然后对输入容器中的每个元素依次调用它。然而，在 C++98&#x2F;03 中，可调用对象只包括函数指针和重载了调用操作符的类类型（通常被称为“函子”）。 举例来说，我们有一个打印一个向量中所有元素的应用程序。在第一个版本中，我们使用普通的函数来实现： 123456789101112131415// Ex1_1: 一个基础的函数对象.#include &lt;algo...</div></div></div></a><a class="pagination-related" href="/2024/11/01/15%20C++%20%E5%80%BC%E7%B1%BB%E5%88%AB%E6%8E%A2%E7%A9%B6/" title="C++ 值类别探究"><img class="cover" src="/img/15/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-01</div><div class="info-item-2">C++ 值类别探究</div></div><div class="info-2"><div class="info-item-1">C++ 在演进过程中逐渐增强和拓展了对类型的处理能力。 由于表达式产生的中间结果会产生导致多余的拷贝，因而在 C++11 中引入了移动语义来解决这个问题，同时对值类别的左值、右值进行重新定义。需要注意的是，值类别指的是表达式结果的类别，并不是值对象、变量或者类型的类别。 对值类别的准确理解，是掌握移动语义的关键，能够帮我我们写出更优雅高效的代码，那么今天让我们一起来探究一下值类别。 1. 引用引用是 C 语言所没有的概念。而这个概念，比它表面看起来要复杂一些。 1.1 值与对象为了理解引用，我们需要首先搞清楚什么叫左值与右值 。 简而言之，左值是一种对象，而不是值。其与右值的关键区别在于，是否明确在内存中有其可访问的位置。即，其是否存在一个可访问的地址。如果有，那么它就是一个对象，也就是一个左值 ，否则，它就只是一个值，即右值。 比如：你不可能对整数 10 取地址，因而这个表达式是一个右值。但是如果你定义了一个变量： int a = 10; 变量 a 则代表一个对象，即左值。如果我们再进一步，表达式 a + 1 则是一个右值表达式，因为你无法对这个表达式取地址。 任何可以取地址的...</div></div></div></a><a class="pagination-related" href="/2023/11/01/03%20Effective%20C++/" title="Effective C++"><img class="cover" src="/img/03/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-01</div><div class="info-item-2">Effective C++</div></div><div class="info-2"><div class="info-item-1">有人说 C++ 程序员可以分为两类，读过 Effective C++ 的和没读过的。世界级 C++ 大师 Scott Meyers 成名之作的第三版的确当得起这样的评价。当您读过本书之后，就获得了迅速提升自己 C++ 功力的一个契机。 在国际上，本书所引起的反响，波及整个计算机的出版领域，余音至今未绝。几乎在所有 C++ 书籍的推荐名单上，本书都会位于前三名。作者高超的技术把握力、独特的视角、诙谐轻松的写作风格、独具匠心的内容组织，都受到极大的推崇和效仿。这种奇特的现象，只能解释为人们对这本书衷心的赞美和推崇。 这本书不是读完一遍就可以束之高阁的快餐读物，也不是用于解决手边问题的参考手册，而是需要您去反复阅读体会的，C++ 是真正程序员的语言，背后有着精深的思想与无与伦比的表达能力，这使得它具有类似宗教般的魅力。希望这本书能够帮助您跨越 C++ 的重重险阻，领略高处才有的壮美风光，做一个成功而快乐的 C++ 程序员。 1. 让自己习惯 C++不论你的编程背景是什么，C++ 都可能让你觉得有点熟悉。它是一个威力强大的语言，带着众多特性，但是在你可以驾驭其威力并有效运用其特性之前，你...</div></div></div></a><a class="pagination-related" href="/2024/01/01/05%20Effective%20STL/" title="Effective STL"><img class="cover" src="/img/05/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-01</div><div class="info-item-2">Effective STL</div></div><div class="info-2"><div class="info-item-1">本书是 Effective C++ 的第 3 卷，被评为“值得所有 C++ 程序员阅读的 C++ 书籍之一”。本书详细讲述了使用 STL 的 50 条指导原则，并提供了透彻的分析和深刻的实例，实用性极强，是 C++ 程序员必备的基础书籍。C++ 的标准模板库（STL）是革命性的，要用好 STL 并不容易。本书作者 Scott Meyers 揭示了专家总结的一些关键规则，包括专家们总是采用的做法，以及专家们总是避免的做法。通过这些规则，STL 程序员可以最大限度地使用 STL。  </div></div></div></a><a class="pagination-related" href="/2024/02/01/06%20Effective%20Modern%20C++/" title="Effective Modern C++"><img class="cover" src="/img/06/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-01</div><div class="info-item-2">Effective Modern C++</div></div><div class="info-2"><div class="info-item-1">一份宏大的作品，能够带动一个领域的蓬勃发展。C++ 社群在相对沉寂数十年之后迎来新一波浪潮，原因是，作为一门编程工具的最核心，C++ 的语言和标准库都出现巨大的拓展和强化。这一番大变革始自 2011，并分别于 2014、2017 持续进化。业界习惯性地将这些新版本统称为 Modern C++，用以区别“传统” C++。 作为知名书系的最新作品，《Effective Modern C++》的佳质和佳评一如其早期同门作品《Effective C++》和《More Effective C++》。本书延续作者 Scott Meyers 的一贯风格和质量，其最大特质就是，不但告诉我们 How，更用巨大而精良的篇幅告诉我们 Why。作者穷追猛打讲究再三的劲儿，常让我筋疲力尽，痛并快乐地爬行于某个条款之际拍案而叹：“天哪，还有下一页！” 而我，是一个在 C++ 领域已经生活了 25 年的老兵。 是的，我是一个在 C++ 领域已经生活了 25 年的老兵，这意味着我具备相当的 C++ 能力。尽管如此，面对号称全新语言的 Modern C++，我时或也有力不能逮、掩卷长叹的焦躁，特别是面对 Rval...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/website/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">奇点创客</div><div class="author-info-description">一枚爱智求真的理工男</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:144057175@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://github.com/QiDianMaker" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/53822487?spm_id_from=333.1007.0.0" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili" style="color: #fb7299;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-1-%E7%AB%A0-%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="toc-text">第 1 章 概念和约束的历史</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1994-%E5%B9%B4%EF%BC%88%E6%97%A9%E6%9C%9F%E6%83%B3%E6%B3%95%EF%BC%89"><span class="toc-text">1.1 1994 年（早期想法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E7%BB%A7%E6%89%BF%E6%96%B9%E6%A1%88"><span class="toc-text">1.1.1 继承方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E5%9F%BA%E4%BA%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8"><span class="toc-text">1.1.2 基于表达式使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2003-%E5%B9%B4%EF%BC%88%E5%88%9D%E6%AD%A5%E8%AE%BE%E8%AE%A1%EF%BC%89"><span class="toc-text">1.2 2003 年（初步设计）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E8%99%9A%E5%9F%BA%E7%B1%BB%E6%96%B9%E5%BC%8F"><span class="toc-text">1.2.1 虚基类方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D%E6%96%B9%E6%A1%88"><span class="toc-text">1.2.2 函数匹配方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E5%9F%BA%E4%BA%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8"><span class="toc-text">1.2.3 基于表达式使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E5%9F%BA%E4%BA%8E%E4%BC%AA%E7%AD%BE%E5%90%8D%E6%96%B9%E6%A1%88"><span class="toc-text">1.2.4 基于伪签名方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-text">1.2.5 设计目标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2004-%E5%B9%B4%EF%BC%88%E5%8D%B0%E7%AC%AC%E5%AE%89%E7%BA%B3%E6%8F%90%E6%A1%88%E4%B8%8E%E5%BE%97%E5%85%8B%E8%90%A8%E6%96%AF%E6%8F%90%E6%A1%88%EF%BC%89"><span class="toc-text">1.3 2004 年（印第安纳提案与得克萨斯提案）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E5%8D%B0%E7%AC%AC%E5%AE%89%E7%BA%B3%E6%8F%90%E6%A1%88"><span class="toc-text">1.3.1 印第安纳提案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E5%BE%97%E5%85%8B%E8%90%A8%E6%96%AF%E6%8F%90%E6%A1%88"><span class="toc-text">1.3.2 得克萨斯提案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-ConceptGCC"><span class="toc-text">1.3.3 ConceptGCC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2006-%E5%B9%B4%EF%BC%88%E5%A6%A5%E5%8D%8F%EF%BC%89"><span class="toc-text">1.4 2006 年（妥协）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2009-%E5%B9%B4%EF%BC%88%E6%A0%87%E5%87%86%E5%8C%96%E6%8A%95%E7%A5%A8%EF%BC%89"><span class="toc-text">1.5 2009 年（标准化投票）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2013-%E5%B9%B4%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A6%82%E5%BF%B5%EF%BC%88conceptslite%EF%BC%89"><span class="toc-text">1.6 2013 年轻量级概念（conceptslite）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-2015-%E5%B9%B4%EF%BC%88ConceptsTS%EF%BC%89"><span class="toc-text">1.7 2015 年（ConceptsTS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-2016-%E5%B9%B4%EF%BC%88C-17%EF%BC%89"><span class="toc-text">1.8 2016 年（C++17）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-2020-%E5%B9%B4%EF%BC%88C-20%EF%BC%89"><span class="toc-text">1.9 2020 年（C++20）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-%E5%B0%8F%E7%BB%93"><span class="toc-text">1.10 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-C-20-%E6%A0%87%E5%87%86%E7%9A%84%E6%A6%82%E5%BF%B5%E7%89%B9%E6%80%A7"><span class="toc-text">第 2 章 C++20 标准的概念特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%9A%E4%B9%89%E6%A6%82%E5%BF%B5"><span class="toc-text">2.1 定义概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-requires-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2.2 requires 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E7%AE%80%E5%8D%95%E8%A6%81%E6%B1%82"><span class="toc-text">2.2.1 简单要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E7%B1%BB%E5%9E%8B%E8%A6%81%E6%B1%82"><span class="toc-text">2.2.2 类型要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E5%A4%8D%E5%90%88%E8%A6%81%E6%B1%82"><span class="toc-text">2.2.3 复合要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E5%B5%8C%E5%A5%97%E8%A6%81%E6%B1%82"><span class="toc-text">2.2.4 嵌套要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">2.2.5 注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-requires%E5%AD%90%E5%8F%A5"><span class="toc-text">2.3 requires子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%81%8F%E5%BA%8F%E8%A7%84%E5%88%99"><span class="toc-text">2.4 约束的偏序规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E7%BA%A6%E6%9D%9F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BD%92%E4%B8%80%E5%8C%96"><span class="toc-text">2.4.1 约束表达式归一化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E7%AE%80%E5%8D%95%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%8C%85%E5%90%AB%E5%85%B3%E7%B3%BB"><span class="toc-text">2.4.2 简单约束的包含关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3%E4%B8%80%E8%88%AC%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%8C%85%E5%90%AB%E5%85%B3%E7%B3%BB"><span class="toc-text">2.4.3一般约束的包含关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-using-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E4%B8%8E-concept-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%AB%E5%90%8D"><span class="toc-text">2.4.4 using 类型别名与 concept 表达式别名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%A6%82%E5%BF%B5%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-text">2.5 概念标准库 &lt;concepts&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-same-as%EF%BC%88%E4%B8%8E%E6%9F%90%E7%B1%BB%E7%9B%B8%E5%90%8C%EF%BC%89"><span class="toc-text">2.5.1 same_as（与某类相同）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-derived-from%EF%BC%88%E6%B4%BE%E7%94%9F%E8%87%AA%E6%9F%90%E7%B1%BB%EF%BC%89"><span class="toc-text">2.5.2 derived_from（派生自某类）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-convertible-to%EF%BC%88%E5%8F%AF%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9F%90%E7%B1%BB%EF%BC%89"><span class="toc-text">2.5.3 convertible_to（可转换为某类）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-4-%E7%AE%97%E6%9C%AF%E6%A6%82%E5%BF%B5"><span class="toc-text">2.5.4 算术概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-5-%E5%80%BC%E6%A6%82%E5%BF%B5"><span class="toc-text">2.5.5 值概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-6-invocable%EF%BC%88%E5%8F%AF%E8%B0%83%E7%94%A8%E7%9A%84%EF%BC%89"><span class="toc-text">2.5.6 invocable（可调用的）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8%E4%B9%8B%E6%89%A9%E5%B1%95-transform-%E5%8F%98%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">2.6 综合运用之扩展 transform 变换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">2.7 注意事项</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/01/15%20C++%20%E5%80%BC%E7%B1%BB%E5%88%AB%E6%8E%A2%E7%A9%B6/" title="C++ 值类别探究"><img src="/img/15/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ 值类别探究"/></a><div class="content"><a class="title" href="/2024/11/01/15%20C++%20%E5%80%BC%E7%B1%BB%E5%88%AB%E6%8E%A2%E7%A9%B6/" title="C++ 值类别探究">C++ 值类别探究</a><time datetime="2024-11-01T03:46:07.000Z" title="发表于 2024-11-01 11:46:07">2024-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/01/14%20C++%20%E6%A6%82%E5%BF%B5%E6%8E%A2%E7%A9%B6/" title="C++ 概念简介"><img src="/img/14/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ 概念简介"/></a><div class="content"><a class="title" href="/2024/10/01/14%20C++%20%E6%A6%82%E5%BF%B5%E6%8E%A2%E7%A9%B6/" title="C++ 概念简介">C++ 概念简介</a><time datetime="2024-10-01T14:58:52.000Z" title="发表于 2024-10-01 22:58:52">2024-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/01/13%20Boost%20%E5%BA%93%E6%A6%82%E8%A7%88/" title="Boost 库概览"><img src="/img/13/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Boost 库概览"/></a><div class="content"><a class="title" href="/2024/09/01/13%20Boost%20%E5%BA%93%E6%A6%82%E8%A7%88/" title="Boost 库概览">Boost 库概览</a><time datetime="2024-09-01T06:16:26.000Z" title="发表于 2024-09-01 14:16:26">2024-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/01/12%20Range%20%E5%BA%93%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/" title="Range-v3 库官方文档"><img src="/img/12/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Range-v3 库官方文档"/></a><div class="content"><a class="title" href="/2024/08/01/12%20Range%20%E5%BA%93%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/" title="Range-v3 库官方文档">Range-v3 库官方文档</a><time datetime="2024-08-01T08:39:31.000Z" title="发表于 2024-08-01 16:39:31">2024-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/11%20Eigen%20%E5%BA%93%E6%95%99%E7%A8%8B/" title="Eigen 库官方文档"><img src="/img/11/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Eigen 库官方文档"/></a><div class="content"><a class="title" href="/2024/07/01/11%20Eigen%20%E5%BA%93%E6%95%99%E7%A8%8B/" title="Eigen 库官方文档">Eigen 库官方文档</a><time datetime="2024-07-01T00:57:17.000Z" title="发表于 2024-07-01 08:57:17">2024-07-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/14/top.png);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2023 - 2025 By 奇点创客</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const abcjsInit = () => {
    const abcjsFn = () => {
      setTimeout(() => {
        const sheets = document.querySelectorAll(".abc-music-sheet")
        for (let i = 0; i < sheets.length; i++) {
          const ele = sheets[i]
          if (ele.children.length > 0) continue

          // Parse parameters from data-params attribute
          let params = {}
          const dp = ele.getAttribute("data-params")
          if (dp) {
            try {
              params = JSON.parse(dp)
            } catch (e) {
              console.error("Failed to parse data-params:", e)
            }
          }

          // Merge parsed parameters with the responsive option
          // Ensures params content appears before responsive
          const options = { ...params, responsive: "resize" }

          // Render the music score using ABCJS.renderAbc
          ABCJS.renderAbc(ele, ele.innerHTML, options)
        }
      }, 100)
    }

    if (typeof ABCJS === "object") {
      abcjsFn()
    } else {
      btf.getScript("https://cdn.jsdelivr.net/npm/abcjs/dist/abcjs-basic-min.min.js").then(abcjsFn)
    }
  }

  if (window.pjax) {
    abcjsInit()
  } else {
    window.addEventListener("load", abcjsInit)
  }

  btf.addGlobalFn("encrypt", abcjsInit, "abcjs")
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: '6xahBDKE9bVdQzuufG4r0SrN-gzGzoHsz',
      appKey: 'aS53wAMJ32RwAJRsefQAsX9P',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>