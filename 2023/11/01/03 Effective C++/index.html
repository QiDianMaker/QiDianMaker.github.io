<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Effective C++ | 奇点创客</title><meta name="author" content="奇点创客"><meta name="copyright" content="奇点创客"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="有人说 C++ 程序员可以分为两类，读过 Effective C++ 的和没读过的。世界级 C++ 大师 Scott Meyers 成名之作的第三版的确当得起这样的评价。当您读过本书之后，就获得了迅速提升自己 C++ 功力的一个契机。 在国际上，本书所引起的反响，波及整个计算机的出版领域，余音至今未绝。几乎在所有 C++ 书籍的推荐名单上，本书都会位于前三名。作者高超的技术把握力、独特的视角、诙谐">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++">
<meta property="og:url" content="https://qidianmaker.github.io/2023/11/01/03%20Effective%20C++/index.html">
<meta property="og:site_name" content="奇点创客">
<meta property="og:description" content="有人说 C++ 程序员可以分为两类，读过 Effective C++ 的和没读过的。世界级 C++ 大师 Scott Meyers 成名之作的第三版的确当得起这样的评价。当您读过本书之后，就获得了迅速提升自己 C++ 功力的一个契机。 在国际上，本书所引起的反响，波及整个计算机的出版领域，余音至今未绝。几乎在所有 C++ 书籍的推荐名单上，本书都会位于前三名。作者高超的技术把握力、独特的视角、诙谐">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qidianmaker.github.io/img/03/cover.png">
<meta property="article:published_time" content="2023-11-01T03:32:12.000Z">
<meta property="article:modified_time" content="2025-07-23T07:18:29.225Z">
<meta property="article:author" content="奇点创客">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="经验">
<meta property="article:tag" content="准则">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qidianmaker.github.io/img/03/cover.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Effective C++",
  "url": "https://qidianmaker.github.io/2023/11/01/03%20Effective%20C++/",
  "image": "https://qidianmaker.github.io/img/03/cover.png",
  "datePublished": "2023-11-01T03:32:12.000Z",
  "dateModified": "2025-07-23T07:18:29.225Z",
  "author": [
    {
      "@type": "Person",
      "name": "奇点创客",
      "url": "https://qidianmaker.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/website/favicon.png"><link rel="canonical" href="https://qidianmaker.github.io/2023/11/01/03%20Effective%20C++/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Effective C++',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><style type="text/css">#toggle-sidebar {bottom: 200px}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/website/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 精神家园</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 读书</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 影视</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/travel/"><i class="fa-fw fa-solid fa-umbrella-beach"></i><span> 旅行</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa-solid fa-message"></i><span> 说说</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-tools"></i><span> 工具</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/03/top.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/website/favicon.png" alt="Logo"><span class="site-name">奇点创客</span></a><a class="nav-page-title" href="/"><span class="site-name">Effective C++</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 精神家园</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 读书</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 影视</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/travel/"><i class="fa-fw fa-solid fa-umbrella-beach"></i><span> 旅行</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa-solid fa-message"></i><span> 说说</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-tools"></i><span> 工具</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Effective C++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-01T03:32:12.000Z" title="发表于 2023-11-01 11:32:12">2023-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-23T07:18:29.225Z" title="更新于 2025-07-23 15:18:29">2025-07-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/C/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>有人说 C++ 程序员可以分为两类，读过 Effective C++ 的和没读过的。世界级 C++ 大师 Scott Meyers 成名之作的第三版的确当得起这样的评价。当您读过本书之后，就获得了迅速提升自己 C++ 功力的一个契机。</p>
<p>在国际上，本书所引起的反响，波及整个计算机的出版领域，余音至今未绝。几乎在所有 C++ 书籍的推荐名单上，本书都会位于前三名。作者高超的技术把握力、独特的视角、诙谐轻松的写作风格、独具匠心的内容组织，都受到极大的推崇和效仿。这种奇特的现象，只能解释为人们对这本书衷心的赞美和推崇。</p>
<p>这本书不是读完一遍就可以束之高阁的快餐读物，也不是用于解决手边问题的参考手册，而是需要您去反复阅读体会的，C++ 是真正程序员的语言，背后有着精深的思想与无与伦比的表达能力，这使得它具有类似宗教般的魅力。希望这本书能够帮助您跨越 C++ 的重重险阻，领略高处才有的壮美风光，做一个成功而快乐的 C++ 程序员。</p>
<h2 id="1-让自己习惯-C"><a href="#1-让自己习惯-C" class="headerlink" title="1. 让自己习惯 C++"></a>1. 让自己习惯 C++</h2><p>不论你的编程背景是什么，C++ 都可能让你觉得有点熟悉。它是一个威力强大的语言，带着众多特性，但是在你可以驾驭其威力并有效运用其特性之前，你必须先习惯 C++ 的办事方式。本书谈的便是这个。总有某些东西比其他更基础些，本章就是最基本的一些东西。</p>
<h3 id="条款-01：视-C-为一个语言联邦"><a href="#条款-01：视-C-为一个语言联邦" class="headerlink" title="条款 01：视 C++ 为一个语言联邦"></a>条款 01：视 C++ 为一个语言联邦</h3><p>今天的 C++ 已经是一个多重范式的编程语言（muti-paradigm programming language），一个同时支持过程形式（procedural），面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）的语言。</p>
<p>将 C++ 视为一个由相关语言组成的联邦而非单一语言。在其某个次语言（sublanguage）中，各种守则与通例都倾向简单、直观易懂、并且容易记住。然而，当你从一个次语言移往另一个次语言，守则可能改变。为了理解 C++，你必须认识其主要的次语言。</p>
<ul>
<li>C</li>
<li>Object Oriented C++</li>
<li>Template C++</li>
<li>STL</li>
</ul>
<p>因此说，C++ 并不是一个带有一组守则的一体语言：它是从四个次语言组成的联邦政府，每个次语言都有自己的规约。记住这四个次语言你就会发现 C++ 容易了解得多。</p>
<div class="note success flat"><ul>
<li>C++ 高效编程守则视状况而变化，取决于你使用 C++ 的哪一部分。</li>
</ul>
</div>

<h3 id="条款-02：尽量以-const，enum，inline-替换-define"><a href="#条款-02：尽量以-const，enum，inline-替换-define" class="headerlink" title="条款 02：尽量以 const，enum，inline 替换 #define"></a>条款 02：尽量以 const，enum，inline 替换 #define</h3><p>宏定义只会被预处理器看到，而不会被编译器看到；但是常量却可以。<br>可以定义一个类的专属常量，却无法利用 <code>#define</code> 来实现相同的功能，因为宏定义并不重视作用域。<br>无法取地址的常量可以用类内枚举取代。</p>
<p>宏函数变量必须加小括号，而且其行为并不完全与函数相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 a 和 b 中较大值调用 f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b);    <span class="comment">// a 被累加两次</span></span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b+<span class="number">10</span>); <span class="comment">// a 被累加一次</span></span><br></pre></td></tr></table></figure>

<p>在这里，调用 <code>f</code> 之前，<code>a</code> 的递增次数竟然取决于“它被拿来和谁比较”！</p>
<p>使用内联模板函数替换宏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">callWithMax</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<div class="note success flat"><ul>
<li>对于单纯常量，最好使用 <code>const</code> 对象或 <code>enums</code> 替换 <code>#defines</code>。</li>
<li>对于形似函数的宏（macros），最好改用 <code>inline</code> 函数替换 <code>#defines</code>。</li>
</ul>
</div>

<h3 id="条款-03：尽可能使用-const"><a href="#条款-03：尽可能使用-const" class="headerlink" title="条款 03：尽可能使用 const"></a>条款 03：尽可能使用 const</h3><p><code>const</code> 修饰指针需要区分顶层 <code>const</code> 与底层 <code>const</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;       <span class="comment">// 底层 const，顶层 const</span></span><br><span class="line"><span class="type">char</span>       *       p = greeting; <span class="comment">// 数据不是常量，指针不是常量</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> *       p = greeting; <span class="comment">// 数据是常量，指针不是常量</span></span><br><span class="line"><span class="type">char</span>       * <span class="type">const</span> p = greeting; <span class="comment">// 数据不是常量，指针是常量</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> * <span class="type">const</span> p = greeting; <span class="comment">// 数据是常量，指针是常量</span></span><br></pre></td></tr></table></figure>

<p>STL 迭代器的 <code>const</code> 语义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator  iter = vec.<span class="built_in">begin</span>();  <span class="comment">// T * const</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator cIter = vec.<span class="built_in">begin</span>();  <span class="comment">// T const *</span></span><br></pre></td></tr></table></figure>

<p>对函数的返回值添加 <code>const</code> 有助于防止用户将返回值按左值使用。</p>
<h4 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h4><p>将 <code>const</code> 实施于成员函数有两大好处：</p>
<ol>
<li>它们使类接口比较容易被理解。这是因为，得知哪个函数可以改动对象内容而哪个函数不行，很是重要。</li>
<li>它们使“操作 <code>const</code> 对象”成为可能。这对编写高效代码是个关键，因为如<a href="#%E6%9D%A1%E6%AC%BE-20%E5%AE%81%E4%BB%A5%E4%BC%A0%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E6%9B%BF%E6%8D%A2%E4%BC%A0%E5%80%BC">条款 20</a> 所言，改善 C++ 程序效率的一个根本办法是以常引用的方式传递对象，而此技术可行的前提是，我们有 <code>const</code> 成员函数可用来处理取得（并经修饰而成）的 <code>const</code> 对象。</li>
</ol>
<p>两个成员函数，如果只是常量性不同，可以被重载。</p>
<p>对于成员函数的常量性判定，需要区分<strong>物理常量性</strong>和<strong>逻辑常量性</strong>：</p>
<ul>
<li>物理常量性是指，成员函数只有在不更改对象之任何成员变量（<code>static</code> 除外）时才可以说是 <code>const</code>。也就是说它不更改对象内的任何一个比特。<br>  不幸的是许多成员函数虽然不十足具备 <code>const</code> 性质却能通过物理常量性测试。更具体地说，一个更改了”指针所指物”的成员函数虽然不能算是 <code>const</code>，但如果只有指针（而非其所指物）隶属于对象，那么称此函数为物理常量性不会引发编译器异议。这导致反直观结果。</li>
<li>逻辑常量性是指，一个 <code>const</code> 成员函数可以修改它所处理的对象内的某些比特，但只有在客户端侦测不出的情况下才得如此。对于与物理常量性冲突的字段，需要用 <code>mutable</code> 关键字修饰。<code>mutable</code> 可以释放掉非静态成员函数的按比特常量约束。</li>
</ul>
<h4 id="在-const-和非-const-成员函数中避免重复"><a href="#在-const-和非-const-成员函数中避免重复" class="headerlink" title="在 const 和非 const 成员函数中避免重复"></a>在 const 和非 const 成员函数中避免重复</h4><p>对于在 <code>const</code> 和非 <code>const</code> 成员函数中有都会出现的重复逻辑，推荐使用非 <code>const</code> 版本调用 <code>const</code> 版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...  <span class="comment">// 边界检查</span></span><br><span class="line">        ...  <span class="comment">// 标志数据访问</span></span><br><span class="line">        ...  <span class="comment">// 校验数据完整性</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(                        <span class="comment">// 将 op[] 返回值的 const 移除</span></span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)  <span class="comment">// 为 *this 加上 const</span></span><br><span class="line">                    [position]                        <span class="comment">// 调用 const op[]</span></span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>反向做法——令 <code>const</code> 版本调用非 <code>const</code> 版本是不应该做的。因为 <code>const</code> 成员函数承诺绝不改变其对象的逻辑状态, 非 <code>const</code> 成员函数却没有这般承诺。如果在 <code>const</code> 函数内调用非 <code>const</code> 函数，就是冒了这样的风险：你曾经承诺不改动的那个对象被改动了。</p>
<div class="note success flat"><ul>
<li>将某些东西声明为 <code>const</code> 可帮助编译器侦测出错误用法。<code>const</code> 可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li>
<li>编译器强制实施“物理上的常量性”（bitwise constness），但你编写程序时应使用“概念上的常量性”（conceptual constness）。</li>
<li>当 const 和非 const 成员函数有着实质等价的实现时，令非 const 版本调用 const 版本可避免代码重复。</li>
</ul>
</div>

<h3 id="条款-04：确定对象被使用前已先被初始化"><a href="#条款-04：确定对象被使用前已先被初始化" class="headerlink" title="条款 04：确定对象被使用前已先被初始化"></a>条款 04：确定对象被使用前已先被初始化</h3><p>永远在使用对象之前先将它初始化。对于无任何成员的内置类型，你必须手工完成此事。</p>
<p>对于内置类型以外的任何其他类型，初始化责任落在构造函数身上。规则很简单：确保每一个构造函数都将对象的每一个成员初始化。</p>
<p>推荐使用成员初值列来初始化每个成员，避免先构造再赋值的开销，且确保初始化顺序与成员声明的顺序相同。</p>
<p>对于有多个构造函数，出现重复初始化的代码，C++11 之后推荐使用委托构造函数，消除重复的初始化代码。</p>
<p>对于多个编译单元间的具有依赖关系的静态非局部变量的初始化问题，由于 C++ 对“定义于不同编译单元内的非局部静态对象”的初始化次序并无明确定义，推荐的做法是：将每个非局部静态对象搬到自己的专属函数内（该对象在此函数内被声明为静态）。这些函数返回一个引用指向它所含的对象。（单例模式的常见实现手法）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">Directory::<span class="built_in">Directory</span>(params)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success flat"><ul>
<li>为内置型对象进行手工初始化，因为 C++ 不保证初始化它们。</li>
<li>构造函数最好使用成员初值列（member initialization list），而不要在构造函数本体内使用赋值操作（assignment）。初值列列出的成员函数，其排列次序应该和它们在类中的声明次序相同。</li>
<li>为免除“跨编译单元之初始化次序”问题，请以局部静态对象替换非局部静态对象。</li>
</ul>
</div>

<h2 id="2-构造-析构-赋值运算"><a href="#2-构造-析构-赋值运算" class="headerlink" title="2. 构造&#x2F;析构&#x2F;赋值运算"></a>2. 构造&#x2F;析构&#x2F;赋值运算</h2><h3 id="条款-05：了解-C-默默编写并调用哪些函数"><a href="#条款-05：了解-C-默默编写并调用哪些函数" class="headerlink" title="条款 05：了解 C++ 默默编写并调用哪些函数"></a>条款 05：了解 C++ 默默编写并调用哪些函数</h3><div class="note success flat"><ul>
<li>编译器可以暗自为类创建默认构造函数、复制构造函数、复制赋值操作符，以及析构函数。</li>
</ul>
</div>

<h3 id="条款-06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款-06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款 06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款 06：若不想使用编译器自动生成的函数，就该明确拒绝</h3><div class="note success flat"><ul>
<li>为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为私有并且不予实现。使用像 <code>Uncopyable</code> 这样的基类也是一种做法。</li>
</ul>
</div>

<h3 id="条款-07：为多态基类声明虚析构函数"><a href="#条款-07：为多态基类声明虚析构函数" class="headerlink" title="条款 07：为多态基类声明虚析构函数"></a>条款 07：为多态基类声明虚析构函数</h3><div class="note success flat"><ul>
<li>带多态性质的（polymorphic）基类应该声明一个虚析构函数。如果类带有任何虚函数，它就应该拥有一个虚析构函数。</li>
<li>一个类的设计目的如果不是作为基类使用，或不是为了具备多态性（polymorphically），就不该声明虚析构函数。</li>
</ul>
</div>

<h3 id="条款-08：别让异常逃离析构函数"><a href="#条款-08：别让异常逃离析构函数" class="headerlink" title="条款 08：别让异常逃离析构函数"></a>条款 08：别让异常逃离析构函数</h3><div class="note success flat"><ul>
<li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕获任何异常，然后吞下它们（不传播）或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么类应该提供一个普通函数（而非在析构函数中）执行该操作。</li>
</ul>
</div>

<h3 id="条款-09：绝不在构造和析构过程中调用虚函数"><a href="#条款-09：绝不在构造和析构过程中调用虚函数" class="headerlink" title="条款 09：绝不在构造和析构过程中调用虚函数"></a>条款 09：绝不在构造和析构过程中调用虚函数</h3><div class="note success flat"><ul>
<li>在构造和析构期间不要调用虚函数，因为这类调用从不下降至派生类（比起当前执行构造函数和析构函数的那层）。</li>
</ul>
</div>

<h3 id="条款-10：令-operator-返回一个-this-的引用"><a href="#条款-10：令-operator-返回一个-this-的引用" class="headerlink" title="条款 10：令 operator&#x3D; 返回一个 *this 的引用"></a>条款 10：令 operator&#x3D; 返回一个 *this 的引用</h3><div class="note success flat"><ul>
<li>令赋值（assignment）操作符返回一个 <code>*this</code> 的引用，以支持连锁赋值。</li>
</ul>
</div>

<h3 id="条款-11：在-operator-中处理“自我赋值”"><a href="#条款-11：在-operator-中处理“自我赋值”" class="headerlink" title="条款 11：在 operator&#x3D; 中处理“自我赋值”"></a>条款 11：在 operator&#x3D; 中处理“自我赋值”</h3><div class="note success flat"><ul>
<li>确保当对象自我赋值时 <code>operator=</code> 有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及复制并交换。</li>
<li>确定任何函数如果操作一个以上的对象，其中多个对象是同一个对象时，其行为依然正确。</li>
</ul>
</div>

<h3 id="条款-12：复制对象时勿忘其每一个成分"><a href="#条款-12：复制对象时勿忘其每一个成分" class="headerlink" title="条款 12：复制对象时勿忘其每一个成分"></a>条款 12：复制对象时勿忘其每一个成分</h3><div class="note success flat"><ul>
<li>复制函数应该确保复制“对象内的所有成员变量”以及“所有基类成分”。</li>
<li>不要尝试以某个复制函数实现另一个复制函数。应该将共同机能放进第三个函数中，并由两个复制函数共同调用。</li>
</ul>
</div>

<h2 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3. 资源管理"></a>3. 资源管理</h2><h3 id="条款-13：以对象管理资源"><a href="#条款-13：以对象管理资源" class="headerlink" title="条款 13：以对象管理资源"></a>条款 13：以对象管理资源</h3><div class="note success flat"><ul>
<li>为防止资源泄露，请使用 RAII 对象，它们在构造函数中获得资源并在析构函数中释放资源。</li>
<li>两个常被使用的 RAII 类分别是 <code>tr1::shared_ptr</code> 和 <code>auto_ptr</code>。前者常是较佳的选择，因为其复制行为比较直观。若选择 <code>auto_ptr</code>，复制动作会使它（被复制物）指向 <code>null</code>。</li>
</ul>
</div>

<h3 id="条款-14：在资源管理类中小心拷贝行为"><a href="#条款-14：在资源管理类中小心拷贝行为" class="headerlink" title="条款 14：在资源管理类中小心拷贝行为"></a>条款 14：在资源管理类中小心拷贝行为</h3><div class="note success flat"><ul>
<li>复制 RAII 对象必须一并复制它所管理的资源，所以资源的复制行为决定 RAII 对象的复制行为。</li>
<li>普遍而常见的 RAII 类的复制行为是：抑制复制、试行引用计数（reference counting）。不过其他行为也都可能被实现。</li>
</ul>
</div>

<h3 id="条款-15：在资源管理类中提供对原始资源的访问"><a href="#条款-15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15：在资源管理类中提供对原始资源的访问"></a>条款 15：在资源管理类中提供对原始资源的访问</h3><div class="note success flat"><ul>
<li>API 往往要求访问原始资源（raw resources），所以每一个 RAII 类应该提供一个“取得其所管理之资源”的办法。</li>
<li>对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。</li>
</ul>
</div>

<h3 id="条款-16：成对使用-new-和-delete-时要采取相同形式"><a href="#条款-16：成对使用-new-和-delete-时要采取相同形式" class="headerlink" title="条款 16：成对使用 new 和 delete 时要采取相同形式"></a>条款 16：成对使用 new 和 delete 时要采取相同形式</h3><div class="note success flat"><ul>
<li>如果你在 <code>new</code> 表达式中使用 []，必须在相应的 <code>delete</code> 表达式中也使用 []。如果你在 <code>new</code> 表达式中不使用 []，一定不要在相应的 delete 表达式中使用 []。</li>
</ul>
</div>

<h3 id="条款-17：以独立语句将-newed-对象置入智能指针"><a href="#条款-17：以独立语句将-newed-对象置入智能指针" class="headerlink" title="条款 17：以独立语句将 newed 对象置入智能指针"></a>条款 17：以独立语句将 newed 对象置入智能指针</h3><div class="note success flat"><ul>
<li>以独立语句将 <code>new</code> 生成的对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。</li>
</ul>
</div>

<h2 id="4-设计与声明"><a href="#4-设计与声明" class="headerlink" title="4. 设计与声明"></a>4. 设计与声明</h2><h3 id="条款-18：让接口容易被正确使用，不易被误用"><a href="#条款-18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款 18：让接口容易被正确使用，不易被误用"></a>条款 18：让接口容易被正确使用，不易被误用</h3><div class="note success flat"><ul>
<li>好的接口很容易被使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。</li>
<li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li>
<li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以消除客户的资源管理责任。</li>
<li><code>tr1::shared_ptr</code> 支持定制型删除器（custom deleter）。这可防范 DLL 问题，可被用来自动解除互斥锁等等。</li>
</ul>
</div>

<h3 id="条款-19：设计类犹如设计类型"><a href="#条款-19：设计类犹如设计类型" class="headerlink" title="条款 19：设计类犹如设计类型"></a>条款 19：设计类犹如设计类型</h3><div class="note success flat"><ul>
<li>类的设计就是类型的设计。在定义一个新类型之前，请确保你已经考虑过本条款覆盖的所有讨论主题。</li>
</ul>
</div>

<h3 id="条款-20：宁以传常量引用替换传值"><a href="#条款-20：宁以传常量引用替换传值" class="headerlink" title="条款 20：宁以传常量引用替换传值"></a>条款 20：宁以传常量引用替换传值</h3><div class="note success flat"><ul>
<li>尽量以传递常量引用替换传值。前者通常比较高效，并可避免对象切割问题。</li>
<li>以上规则并不适用于内置类型，以及 STL 的迭代器和函数对象。对它们而言，传值往往比较适当。</li>
</ul>
</div>

<h3 id="条款-21：必须返回对象时，别妄想返回其引用"><a href="#条款-21：必须返回对象时，别妄想返回其引用" class="headerlink" title="条款 21：必须返回对象时，别妄想返回其引用"></a>条款 21：必须返回对象时，别妄想返回其引用</h3><div class="note success flat"><ul>
<li>绝不要返回指针或引用指向一个局部栈对象，或返回引用指向一个堆分配对象，或返回指针或引用指向一个局部静态对象而言有可能同时需要多个这样的对象。条款 4 已经为“在单线程中合理返回一个局部静态对象”提供一份设计实例。</li>
</ul>
</div>

<h3 id="条款-22：将成员变量声明为私有"><a href="#条款-22：将成员变量声明为私有" class="headerlink" title="条款 22：将成员变量声明为私有"></a>条款 22：将成员变量声明为私有</h3><div class="note success flat"><ul>
<li>切记将成员变量声明为私有。这可赋予客户访问数据的一致性、可细微划分访问控制、允许约束条件获得保证，并提供类作者以充分的实现弹性。</li>
<li><code>protected</code> 并不比 <code>public</code> 更具封装性。</li>
</ul>
</div>

<h3 id="条款-23：宁以非成员、非友元替换成员函数"><a href="#条款-23：宁以非成员、非友元替换成员函数" class="headerlink" title="条款 23：宁以非成员、非友元替换成员函数"></a>条款 23：宁以非成员、非友元替换成员函数</h3><div class="note success flat"><ul>
<li>如果你需要为某个函数的所有参数（包括 <code>this</code> 指针所指的那个隐藏参数）进行类型转换，那么这个函数必须是个非成员函数。</li>
<li>宁可拿非成员非友元函数替换成员函数。这样做可以增加封装性、包裹弹性和机能扩充性。</li>
</ul>
</div>

<h3 id="条款-24：若所有参数皆需类型转换，请为此采用非成员函数"><a href="#条款-24：若所有参数皆需类型转换，请为此采用非成员函数" class="headerlink" title="条款 24：若所有参数皆需类型转换，请为此采用非成员函数"></a>条款 24：若所有参数皆需类型转换，请为此采用非成员函数</h3><div class="note success flat"><ul>
<li>如果你需要为某个函数的所有参数（包括被 <code>this</code> 指针所指的那个隐藏参数）进行类型转换，那么这个函数必须是个非成员函数。</li>
</ul>
</div>

<h3 id="条款-25：考虑写出一个不抛异常的-swap-函数"><a href="#条款-25：考虑写出一个不抛异常的-swap-函数" class="headerlink" title="条款 25：考虑写出一个不抛异常的 swap 函数"></a>条款 25：考虑写出一个不抛异常的 swap 函数</h3><div class="note success flat"><ul>
<li>当 <code>std::swap</code> 对你的类型效率不高时，提供一个 <code>swap</code> 成员函数，并确定这个函数不抛出异常。</li>
<li>如果你提供一个成员函数版 <code>swap</code>，也该提供一个非成员版 <code>swap</code> 用来调用前者。对于类（而非模板），也请特化 <code>std::swap</code>。</li>
<li>调用 <code>swap</code> 时应针对 <code>std::swap</code> 使用 <code>using</code> 声明式，然后调用 <code>swap</code> 并且不带任何“命名空间资格修饰”。</li>
<li>为“用户定义类型”进行 <code>std templates</code> 全特化是好的，但千万不要尝试在 <code>std</code> 内加入某些对 <code>std</code> 而言全新的东西。</li>
</ul>
</div>

<h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><h3 id="条款-26：尽可能延后变量定义式的出现时间"><a href="#条款-26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款 26：尽可能延后变量定义式的出现时间"></a>条款 26：尽可能延后变量定义式的出现时间</h3><div class="note success flat"><ul>
<li>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</li>
</ul>
</div>

<h3 id="条款-27：尽量少做转型动作"><a href="#条款-27：尽量少做转型动作" class="headerlink" title="条款 27：尽量少做转型动作"></a>条款 27：尽量少做转型动作</h3><div class="note success flat"><ul>
<li>如果可以，尽量避免转型，特别是在注重效率的代码中避免 <code>dynamic_cast</code>。如果有个设计需要转型动作，试着发展无需转型的替代设计。</li>
<li>如果转型是必须的，试着将它隐藏于某个函数背后。客户随时可以调用该函数，而不需要将转型放进他们自己的代码内。</li>
<li>宁可使用 C++ 风格（新式）转型，不要使用旧式转型。前者很容易辨别出来，而且也比较有着分门别类的职掌。</li>
</ul>
</div>

<h3 id="条款-28：避免返回指向对象内部成分的句柄"><a href="#条款-28：避免返回指向对象内部成分的句柄" class="headerlink" title="条款 28：避免返回指向对象内部成分的句柄"></a>条款 28：避免返回指向对象内部成分的句柄</h3><div class="note success flat"><ul>
<li>避免返回句柄（包括引用、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助 <code>const</code> 成员函数的行为像个 <code>const</code>，并将发生“虚吊号码牌”（dangling handles）的可能性降至最低。</li>
</ul>
</div>

<h3 id="条款-29：为“异常安全”而努力是值得的"><a href="#条款-29：为“异常安全”而努力是值得的" class="headerlink" title="条款 29：为“异常安全”而努力是值得的"></a>条款 29：为“异常安全”而努力是值得的</h3><div class="note success flat"><ul>
<li>异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。</li>
<li>“强烈保证”往往能够以复制并交换实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。</li>
<li>函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</li>
</ul>
</div>

<h3 id="条款-30：透彻了解内联的里里外外"><a href="#条款-30：透彻了解内联的里里外外" class="headerlink" title="条款 30：透彻了解内联的里里外外"></a>条款 30：透彻了解内联的里里外外</h3><div class="note success flat"><ul>
<li>将大多数内联限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li>
<li>不要只因为函数模板出现在头文件，就将它们声明为内联。</li>
</ul>
</div>

<h3 id="条款-31：将文件的编译依存关系降至最低"><a href="#条款-31：将文件的编译依存关系降至最低" class="headerlink" title="条款 31：将文件的编译依存关系降至最低"></a>条款 31：将文件的编译依存关系降至最低</h3><div class="note success flat"><ul>
<li>支持“编译依存性最小化”的一般构想是：相依与声明式，不要相依于定义式。基于此构想的两个手段是句柄类（Handle classes）和接口类（Interface classes）。</li>
<li>程序库头文件应该以“完全仅有声明式”的形式存在。这种做法不论是否涉及模板都适用。</li>
</ul>
</div>

<h2 id="6-继承与面向对象设计"><a href="#6-继承与面向对象设计" class="headerlink" title="6. 继承与面向对象设计"></a>6. 继承与面向对象设计</h2><h3 id="条款-32：确定你的公有继承塑模出“是一个”关系"><a href="#条款-32：确定你的公有继承塑模出“是一个”关系" class="headerlink" title="条款 32：确定你的公有继承塑模出“是一个”关系"></a>条款 32：确定你的公有继承塑模出“是一个”关系</h3><div class="note success flat"><ul>
<li>“公有继承”意味着“是一个”。适用于基类身上的每一件事情一定也适用于派生类身上，因为每一个派生类对象也都是一个基类对象。</li>
</ul>
</div>

<h3 id="条款-33：避免遮掩继承而来的名称"><a href="#条款-33：避免遮掩继承而来的名称" class="headerlink" title="条款 33：避免遮掩继承而来的名称"></a>条款 33：避免遮掩继承而来的名称</h3><div class="note success flat"><ul>
<li>派生类内的名称会遮掩基类内的名称。在共有继承下从来没有人希望如此。</li>
<li>为了让被遮掩的名称再见天日，可使用 using 声明式或转交函数(forwarding functions)。</li>
</ul>
</div>

<h3 id="条款-34：区分接口继承和实现继承"><a href="#条款-34：区分接口继承和实现继承" class="headerlink" title="条款 34：区分接口继承和实现继承"></a>条款 34：区分接口继承和实现继承</h3><div class="note success flat"><ul>
<li>接口继承和实现继承不同。在共有继承下，派生类总是继承基类的接口。</li>
<li>纯虚函数只具体指定接口继承。</li>
<li>简朴的非纯虚函数具体指定接口继承及缺省实现继承。</li>
<li>非虚函数具体指定接口继承以及强制性实现继承。</li>
</ul>
</div>

<h3 id="条款-35：考虑虚函数以外的其他选择"><a href="#条款-35：考虑虚函数以外的其他选择" class="headerlink" title="条款 35：考虑虚函数以外的其他选择"></a>条款 35：考虑虚函数以外的其他选择</h3><div class="note success flat"><ul>
<li>虚函数的替代方案包括 NVI 手法以及策略设计模式的多种形式。NVI 手法自身是一个特殊形式的模板方法设计模式。</li>
<li>将机能从成员函数移到类外部函数，带来的一个缺点是，非成员函数无法访问类的非公有成员。</li>
<li>tr1::function 对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式兼容”的所有可调用物。</li>
</ul>
</div>

<h3 id="条款-36：绝不重新定义继承而来的非虚函数"><a href="#条款-36：绝不重新定义继承而来的非虚函数" class="headerlink" title="条款 36：绝不重新定义继承而来的非虚函数"></a>条款 36：绝不重新定义继承而来的非虚函数</h3><div class="note success flat"><ul>
<li>绝对不要重新定义继承而来的非虚函数。</li>
</ul>
</div>

<h3 id="条款-37：绝不重新定义继承而来的缺省参数值"><a href="#条款-37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款 37：绝不重新定义继承而来的缺省参数值"></a>条款 37：绝不重新定义继承而来的缺省参数值</h3><div class="note success flat"><ul>
<li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定的，而虚函数 – 你唯一应该覆写的东西 – 却是动态绑定的。</li>
</ul>
</div>

<h3 id="条款-38：通过复合塑模出“有一个”或“根据某物实现出”"><a href="#条款-38：通过复合塑模出“有一个”或“根据某物实现出”" class="headerlink" title="条款 38：通过复合塑模出“有一个”或“根据某物实现出”"></a>条款 38：通过复合塑模出“有一个”或“根据某物实现出”</h3><div class="note success flat"><ul>
<li>复合的意义与共有继承完全不同。</li>
<li>在应用域，复合意味着有一个。在实现域，复合意味着根据某物实现出。</li>
</ul>
</div>

<h3 id="条款-39：明智而审慎地使用私有继承"><a href="#条款-39：明智而审慎地使用私有继承" class="headerlink" title="条款 39：明智而审慎地使用私有继承"></a>条款 39：明智而审慎地使用私有继承</h3><div class="note success flat"><ul>
<li>私有继承意味着根据某物实现出。它通常比复合的级别低。但是当派生类需要访问基类的保护成员，或需要重新定义继承而来的虚函数时，这么设计是合理的。</li>
<li>和复合不同，私有继承可以造成空基类优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。</li>
</ul>
</div>

<h3 id="条款-40：明智而审慎地使用多重继承"><a href="#条款-40：明智而审慎地使用多重继承" class="headerlink" title="条款 40：明智而审慎地使用多重继承"></a>条款 40：明智而审慎地使用多重继承</h3><div class="note success flat"><ul>
<li>多重继承比单一继承复杂。它可能导致新的歧义，以及对虚继承的需要。</li>
<li>虚继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果虚基类不带任何数据，将是最具实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个情节涉及“共有继承某个接口类”和“私有继承某个协助实现的类”的两相组合。</li>
</ul>
</div>

<h2 id="7-模板与泛型编程"><a href="#7-模板与泛型编程" class="headerlink" title="7. 模板与泛型编程"></a>7. 模板与泛型编程</h2><h3 id="条款-41：了解隐式接口和编译期多态"><a href="#条款-41：了解隐式接口和编译期多态" class="headerlink" title="条款 41：了解隐式接口和编译期多态"></a>条款 41：了解隐式接口和编译期多态</h3><div class="note success flat"><ul>
<li>类（classes）和模板（templates）都支持接口（interfaces）和多态（polymorphism）。</li>
<li>对类而言接口是显式的（explicit），以函数签名为中心。多态则是通过虚函数发生于运行期。</li>
<li>对模板参数而言，接口是隐式的（implicit），奠基于有效表达式。多态则是通过模板具现化和函数重载解析（function overloading resolution）发生于编译期。</li>
</ul>
</div>

<h3 id="条款-42：了解-typename-的双重意义"><a href="#条款-42：了解-typename-的双重意义" class="headerlink" title="条款 42：了解 typename 的双重意义"></a>条款 42：了解 typename 的双重意义</h3><div class="note success flat"><ul>
<li>声明模板参数时，前缀关键字 <code>class</code> 和 <code>typename</code> 可互换。</li>
<li>请使用关键字 <code>typename</code> 标识嵌套从属类型名称；但不得在基类列或成员初值列内以它作为基类修饰符。</li>
</ul>
</div>

<h3 id="条款-43：学习处理模板化基类内的名称"><a href="#条款-43：学习处理模板化基类内的名称" class="headerlink" title="条款 43：学习处理模板化基类内的名称"></a>条款 43：学习处理模板化基类内的名称</h3><div class="note success flat"><ul>
<li>可在派生类模板内通过 “this-&gt;” 指涉基类模板内的成员名称，或籍由一个明白写出的“基类资格修饰符”完成。</li>
</ul>
</div>

<h3 id="条款-44：将与参数无关的代码抽离模板"><a href="#条款-44：将与参数无关的代码抽离模板" class="headerlink" title="条款 44：将与参数无关的代码抽离模板"></a>条款 44：将与参数无关的代码抽离模板</h3><div class="note success flat"><ul>
<li>模板生成多个类或多个函数，所以任何模板代码都不该与某个造成膨胀的模板参数产生相依关系关系。</li>
<li>因非类型模板参数而造成的代码膨胀，往往可以消除，做法是以函数参数或类成员变量替换模板参数。</li>
<li>因类型参数而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述的具现类型共享实现码。</li>
</ul>
</div>

<h3 id="条款-45：运用成员函数模板接受所有兼容类型"><a href="#条款-45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款 45：运用成员函数模板接受所有兼容类型"></a>条款 45：运用成员函数模板接受所有兼容类型</h3><div class="note success flat"><ul>
<li>请使用成员函数模板生成“可接收所有兼容类型”的函数。</li>
<li>如果你声明成员模板用于“泛化复制构造”或“泛化赋值操作”，你还是需要声明正常的复制构造和复制赋值操作符。</li>
</ul>
</div>

<h3 id="条款-46：需要类型转换时请为模板定义非成员函数"><a href="#条款-46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款 46：需要类型转换时请为模板定义非成员函数"></a>条款 46：需要类型转换时请为模板定义非成员函数</h3><div class="note success flat"><ul>
<li>当我们编写一个类模板，而它所提供之“与此模板相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“类模板内部的友元函数”。</li>
</ul>
</div>

<h3 id="条款-47：请使用萃取类表现类型信息"><a href="#条款-47：请使用萃取类表现类型信息" class="headerlink" title="条款 47：请使用萃取类表现类型信息"></a>条款 47：请使用萃取类表现类型信息</h3><div class="note success flat"><ul>
<li>Traits 类使得“类型相关信息”在编译期可用。它们以模板和模板特化完成实现。</li>
<li>整合重载技术后，traits 类有可能在编译期对类型执行 <code>if...else</code> 测试。</li>
</ul>
</div>

<h3 id="条款-48：认识模板元编程"><a href="#条款-48：认识模板元编程" class="headerlink" title="条款 48：认识模板元编程"></a>条款 48：认识模板元编程</h3><div class="note success flat"><ul>
<li>模板元编程（Template Meta Programming, TMP）可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率。</li>
<li>TMP 可被用来生成“基于策略选择组合”的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li>
</ul>
</div>

<h2 id="8-定制-new-和-delete"><a href="#8-定制-new-和-delete" class="headerlink" title="8. 定制 new 和 delete"></a>8. 定制 new 和 delete</h2><h3 id="条款-49：了解-new-handler-的行为"><a href="#条款-49：了解-new-handler-的行为" class="headerlink" title="条款 49：了解 new-handler 的行为"></a>条款 49：了解 new-handler 的行为</h3><div class="note success flat"><ul>
<li><code>set_new_handler</code> 允许客户指定一个函数，在内存分配无法获得满足时被调用。</li>
<li>Nothrow new 是一个颇为局限的工具，因为它只适用于内存分配；后续的构造函数调用还是可能抛出异常。</li>
</ul>
</div>

<h3 id="条款-50：了解-new-和-delete-的合理替换时机"><a href="#条款-50：了解-new-和-delete-的合理替换时机" class="headerlink" title="条款 50：了解 new 和 delete 的合理替换时机"></a>条款 50：了解 new 和 delete 的合理替换时机</h3><div class="note success flat"><ul>
<li>有许多理由需要写个自定义 <code>new</code> 和 <code>delete</code>，包括改善效能、对堆栈运用错误进行调试、收集堆栈使用信息。</li>
</ul>
</div>

<h3 id="条款-51：编写-new-和-delete-时需固守常规"><a href="#条款-51：编写-new-和-delete-时需固守常规" class="headerlink" title="条款 51：编写 new 和 delete 时需固守常规"></a>条款 51：编写 new 和 delete 时需固守常规</h3><div class="note success flat"><ul>
<li><code>operator new</code> 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用 new-handler。它也应该有能力处理零字节申请。类专属版本则还应该处理“比正确大小更大的（错误）申请”。</li>
<li><code>operator delete</code> 应该在收到空指针时不做任何事。类专属版本则还应该处理“比正确大小更大的（错误）申请”。</li>
</ul>
</div>

<h3 id="条款-52：写了原位-new-也要写原位-delete"><a href="#条款-52：写了原位-new-也要写原位-delete" class="headerlink" title="条款 52：写了原位 new 也要写原位 delete"></a>条款 52：写了原位 new 也要写原位 delete</h3><div class="note success flat"><ul>
<li>当你写一个 <code>placement operator new</code>，请确定也写了对应的 <code>placement operator delete</code>。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄露。</li>
<li>当你声明 <code>placement new</code> 和 <code>placement delete</code>，请确定不要无意思（非故意）地遮掩了它们的正常版本。</li>
</ul>
</div>

<h2 id="9-杂项讨论"><a href="#9-杂项讨论" class="headerlink" title="9. 杂项讨论"></a>9. 杂项讨论</h2><h3 id="条款-53：不要轻易忽视编译器的警告"><a href="#条款-53：不要轻易忽视编译器的警告" class="headerlink" title="条款 53：不要轻易忽视编译器的警告"></a>条款 53：不要轻易忽视编译器的警告</h3><div class="note success flat"><ul>
<li>严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取“无任何警告”的荣誉。</li>
<li>不要过度依赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失。</li>
</ul>
</div>

<h3 id="条款-54：让自己熟悉包括-TR1-在内的标准程序库"><a href="#条款-54：让自己熟悉包括-TR1-在内的标准程序库" class="headerlink" title="条款 54：让自己熟悉包括 TR1 在内的标准程序库"></a>条款 54：让自己熟悉包括 TR1 在内的标准程序库</h3><div class="note success flat"><ul>
<li>C++ 标准库的主要机能由 STL、iostreams、locales 组成。并包含 C99 标准程序库。</li>
<li>TR1 添加了智能指针（例如 <code>tr1::shared_ptr</code>）、一般化函数指针（<code>tr1::function</code>）、基于哈希的（hash-based）容器、正则表达式（regular expression）、以及另外 10 个组件的支持。</li>
<li>TR1 自身只是一份规范。未获得 TR1 提供的好处，你需要一份实物。一个好的实物来源是 Boost。</li>
</ul>
</div>

<h3 id="条款-55：让自己熟悉-Boost"><a href="#条款-55：让自己熟悉-Boost" class="headerlink" title="条款 55：让自己熟悉 Boost"></a>条款 55：让自己熟悉 Boost</h3><div class="note success flat"><ul>
<li>Boost 是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的 C++ 程序库开发。Boost 在 C++ 标准化过程中扮演深具影响力的角色。</li>
<li>Boost 提供许多 TR1 组件实现品，以及其他许多程序库。</li>
</ul>
</div>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://qidianmaker.github.io">奇点创客</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://qidianmaker.github.io/2023/11/01/03%20Effective%20C++/">https://qidianmaker.github.io/2023/11/01/03%20Effective%20C++/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://qidianmaker.github.io" target="_blank">奇点创客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E7%BB%8F%E9%AA%8C/">经验</a><a class="post-meta__tags" href="/tags/%E5%87%86%E5%88%99/">准则</a></div><div class="post-share"><div class="social-share" data-image="/img/03/cover.png" data-sites="wechat,qq,weibo,twitter,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/website/wechat_sponsor_code.png" target="_blank"><img class="post-qr-code-img" src="/img/website/wechat_sponsor_code.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/website/aliplay_sponsor_code.png" target="_blank"><img class="post-qr-code-img" src="/img/website/aliplay_sponsor_code.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/10/25/02_6%20C++%20Lambda%20%E7%9A%84%E6%95%85%E4%BA%8B%E4%B9%8B%E9%99%84%E5%BD%95/" title="C++ Lambda 的故事——附录"><img class="cover" src="/img/02/cover6.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C++ Lambda 的故事——附录</div></div><div class="info-2"><div class="info-item-1">附录 A - 技术列表C++11 章节C++14 章节C++17 章节C++20 章节附录 B - C++ Lambda 表达式的六大优势​Lambda 使代码更可读Lambda 编译比 std::bind 快 7 倍！Lambda 增强了代码的局部性Lambda 允许轻松存储状态Lambda 允许多个重载在同一的地方Lambda 随着 C++ 的每一次修订而变得更好！参考文献</div></div></div></a><a class="pagination-related" href="/2023/12/01/04%20More%20Effective%20C++/" title="More Effective C++"><img class="cover" src="/img/04/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">More Effective C++</div></div><div class="info-2"><div class="info-item-1">继 Effective C++ 之后，Scott Meyers 于 1996 年推出这本“续集”。条款变得比较少，页数倒是多了一些，原因是这次选材比“第一集”更高阶。尤其是第 5 章。Meyers 将此章命名为技术（techniques），并明白告诉你，其中都是一些 patterns（模式），例如 virtual contructors（虚构造函数），smart pointers（智能指针），reference counting（引用计数），proxy classes（策略类），double dispatching（双重派发）……这一章的每个条款篇幅都长达 15~30 页之多，实在让人有“山重水复疑无路，柳暗花明又一村”之叹。   基础议题条款 1：仔细区分指针和引用条款 2：最好使用 C++ 转型操作符条款 3：绝对不要以多态反诗处理数组条款 4：非必要不提供默认构造函数操作符条款 5：对定制的“类型转换函数”保持警觉条款 6：区分自增&#x2F;自减操作符的前置和后置形式条款 7：千万不要重载 &amp;&amp;，|| 和 , 操作符条款 8：了解各种不同意义的 new 和...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/01/01/05%20Effective%20STL/" title="Effective STL"><img class="cover" src="/img/05/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-01</div><div class="info-item-2">Effective STL</div></div><div class="info-2"><div class="info-item-1">本书是 Effective C++ 的第 3 卷，被评为“值得所有 C++ 程序员阅读的 C++ 书籍之一”。本书详细讲述了使用 STL 的 50 条指导原则，并提供了透彻的分析和深刻的实例，实用性极强，是 C++ 程序员必备的基础书籍。C++ 的标准模板库（STL）是革命性的，要用好 STL 并不容易。本书作者 Scott Meyers 揭示了专家总结的一些关键规则，包括专家们总是采用的做法，以及专家们总是避免的做法。通过这些规则，STL 程序员可以最大限度地使用 STL。  </div></div></div></a><a class="pagination-related" href="/2023/12/01/04%20More%20Effective%20C++/" title="More Effective C++"><img class="cover" src="/img/04/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-01</div><div class="info-item-2">More Effective C++</div></div><div class="info-2"><div class="info-item-1">继 Effective C++ 之后，Scott Meyers 于 1996 年推出这本“续集”。条款变得比较少，页数倒是多了一些，原因是这次选材比“第一集”更高阶。尤其是第 5 章。Meyers 将此章命名为技术（techniques），并明白告诉你，其中都是一些 patterns（模式），例如 virtual contructors（虚构造函数），smart pointers（智能指针），reference counting（引用计数），proxy classes（策略类），double dispatching（双重派发）……这一章的每个条款篇幅都长达 15~30 页之多，实在让人有“山重水复疑无路，柳暗花明又一村”之叹。   基础议题条款 1：仔细区分指针和引用条款 2：最好使用 C++ 转型操作符条款 3：绝对不要以多态反诗处理数组条款 4：非必要不提供默认构造函数操作符条款 5：对定制的“类型转换函数”保持警觉条款 6：区分自增&#x2F;自减操作符的前置和后置形式条款 7：千万不要重载 &amp;&amp;，|| 和 , 操作符条款 8：了解各种不同意义的 new 和...</div></div></div></a><a class="pagination-related" href="/2024/02/01/06%20Effective%20Modern%20C++/" title="Effective Modern C++"><img class="cover" src="/img/06/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-01</div><div class="info-item-2">Effective Modern C++</div></div><div class="info-2"><div class="info-item-1">一份宏大的作品，能够带动一个领域的蓬勃发展。C++ 社群在相对沉寂数十年之后迎来新一波浪潮，原因是，作为一门编程工具的最核心，C++ 的语言和标准库都出现巨大的拓展和强化。这一番大变革始自 2011，并分别于 2014、2017 持续进化。业界习惯性地将这些新版本统称为 Modern C++，用以区别“传统” C++。 作为知名书系的最新作品，《Effective Modern C++》的佳质和佳评一如其早期同门作品《Effective C++》和《More Effective C++》。本书延续作者 Scott Meyers 的一贯风格和质量，其最大特质就是，不但告诉我们 How，更用巨大而精良的篇幅告诉我们 Why。作者穷追猛打讲究再三的劲儿，常让我筋疲力尽，痛并快乐地爬行于某个条款之际拍案而叹：“天哪，还有下一页！” 而我，是一个在 C++ 领域已经生活了 25 年的老兵。 是的，我是一个在 C++ 领域已经生活了 25 年的老兵，这意味着我具备相当的 C++ 能力。尽管如此，面对号称全新语言的 Modern C++，我时或也有力不能逮、掩卷长叹的焦躁，特别是面对 Rval...</div></div></div></a><a class="pagination-related" href="/2023/09/01/01%20C++%20%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%95%85%E4%BA%8B/" title="C++ 初始化的故事"><img class="cover" src="/img/01/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-01</div><div class="info-item-2">C++ 初始化的故事</div></div><div class="info-2"><div class="info-item-1">关于本书在 C++ 中，初始化是一个热门话题！互联网上充满了关于最佳实践的讨论，甚至还有关于这个主题的有趣的表情包。这种情况并不奇怪，因为有十几种方法可以初始化一个简单的整数值、有自动类型推断的复杂规则、数据成员和对象生命周期的细微差别。 于是，出现了这本书。 通过本文，你将学习在现代 C++ 中初始化各种类型的变量和数据成员的实用选项。具体来说，本书教授了多种类型的初始化、构造函数、非静态数据成员初始化、内联变量、指定初始化器等。此外，你将看到从 C++11 到 C++20 的变化和新技术，以及大量的示例来加强你的理解。 计划是解释初始化的大部分(如果不是全部的话)，学习许多优秀的 C++ 技术，并了解底层到底发生了什么。 为什么你需要阅读本书？使用现代 C++（从 C++11 开始），我们有许多新特性来简化工作和代码。改进的一个方面是初始化。现代 C++ 增加了新的初始化规则，试图在保持旧行为（主要来自 C 语言）兼容性的同时简化初始化。然而，有时规则可能看起来令人困惑和复杂，甚至 ISO 委员会也可能需要在此过程中纠正一些事情。这本书将帮助你浏览这些原则，以更好地理解这个主...</div></div></div></a><a class="pagination-related" href="/2023/10/05/02_2%20C++%20Lambda%20%E7%9A%84%E6%95%85%E4%BA%8B%E4%B9%8BC++11/" title="C++ Lambda 的故事——C++11"><img class="cover" src="/img/02/cover2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-05</div><div class="info-item-2">C++ Lambda 的故事——C++11</div></div><div class="info-2"><div class="info-item-1"> C++11 中的 Lambda万岁！C++ 委员会听取了开发人员的意见，在 C++11 标准中加入了 Lambda 表达式！ Lambda 表达式很快就成为现代 C++ 中最具辨识度的一个特性。 你可以在 N3337（C++11 的最终草案）中阅读其完整规范，以及关于 Lambda 的单独部分：[express .prim.lambda]。 我认为委员会以一种聪明的方式在语言中添加了 Lambda。他们设计了新的语法，但随后编译器将其“展开”为一个未命名的“隐藏的”函数对象类型。这样我们就拥有了真正强类型语言的所有优点（以及缺点），使代码理解起来更加容易。 在本章，你将会学习到：  Lambda 的基础语法。 如何捕获一个变量。 如何捕获一个类的非静态成员变量。 Lambda 的返回类型。 什么是闭包类型。 怎样将 Lambda 表达式转换成一个函数指针从而能够去使用 C 风格的 API. 什么是 IIFE 以及为什么它是的有用的。 如何继承一个 Lambda 表达式。  让我们出发吧！ Lambda 表达式的语法下图说明了 C++11 中 Lambda 的语法： 现在让我们通...</div></div></div></a><a class="pagination-related" href="/2023/10/01/02_1%20C++%20Lambda%20%E7%9A%84%E6%95%85%E4%BA%8B%E4%B9%8BC++98_03/" title="C++ Lambda 的故事——C++98&#x2F;03"><img class="cover" src="/img/02/cover1.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-01</div><div class="info-item-2">C++ Lambda 的故事——C++98&#x2F;03</div></div><div class="info-2"><div class="info-item-1"> C++98&#x2F;03 中的 Lambda作为开始，了解一些关于我们所讨论的主题的背景知识是很有必要的。为此，我们会转而回顾过去，看看那些不使用任何现代 C++ 技术的代码——即 C++98&#x2F;03 规范下的代码。 在本章中，我们将会学习：  如何将旧式的函数对象传给 C++ 标准库中的各种算法。 函数对象类型的限制。 为什么辅助函数不够好。 C++0x&#x2F;C++11 中引入 Lambda 的动机。  C++98&#x2F;03 中的可调用对象标准库的一个基本设计思想是：对于像 std::sort，std::for_each，std::transform 等这样的泛型函数，能够接受任何可调用对象然后对输入容器中的每个元素依次调用它。然而，在 C++98&#x2F;03 中，可调用对象只包括函数指针和重载了调用操作符的类类型（通常被称为“函子”）。 举例来说，我们有一个打印一个向量中所有元素的应用程序。在第一个版本中，我们使用普通的函数来实现： 123456789101112131415// Ex1_1: 一个基础的函数对象.#include &lt;algo...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/website/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">奇点创客</div><div class="author-info-description">一枚爱智求真的理工男</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:144057175@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://github.com/QiDianMaker" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/53822487?spm_id_from=333.1007.0.0" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili" style="color: #fb7299;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AF-C"><span class="toc-text">1. 让自己习惯 C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-01%EF%BC%9A%E8%A7%86-C-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6"><span class="toc-text">条款 01：视 C++ 为一个语言联邦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5-const%EF%BC%8Cenum%EF%BC%8Cinline-%E6%9B%BF%E6%8D%A2-define"><span class="toc-text">条款 02：尽量以 const，enum，inline 替换 #define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8-const"><span class="toc-text">条款 03：尽可能使用 const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">const 成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-const-%E5%92%8C%E9%9D%9E-const-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D"><span class="toc-text">在 const 和非 const 成员函数中避免重复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">条款 04：确定对象被使用前已先被初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0-%E6%9E%90%E6%9E%84-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="toc-text">2. 构造&#x2F;析构&#x2F;赋值运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-05%EF%BC%9A%E4%BA%86%E8%A7%A3-C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-text">条款 05：了解 C++ 默默编写并调用哪些函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="toc-text">条款 06：若不想使用编译器自动生成的函数，就该明确拒绝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">条款 07：为多态基类声明虚析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">条款 08：别让异常逃离析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">条款 09：绝不在构造和析构过程中调用虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-10%EF%BC%9A%E4%BB%A4-operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-this-%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-text">条款 10：令 operator&#x3D; 返回一个 *this 的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-11%EF%BC%9A%E5%9C%A8-operator-%E4%B8%AD%E5%A4%84%E7%90%86%E2%80%9C%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9D"><span class="toc-text">条款 11：在 operator&#x3D; 中处理“自我赋值”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-12%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86"><span class="toc-text">条款 12：复制对象时勿忘其每一个成分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-text">3. 资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-text">条款 13：以对象管理资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%E6%8B%B7%E8%B4%9D%E8%A1%8C%E4%B8%BA"><span class="toc-text">条款 14：在资源管理类中小心拷贝行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">条款 15：在资源管理类中提供对原始资源的访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-16%EF%BC%9A%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8-new-%E5%92%8C-delete-%E6%97%B6%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="toc-text">条款 16：成对使用 new 和 delete 时要采取相同形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-17%EF%BC%9A%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86-newed-%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">条款 17：以独立语句将 newed 对象置入智能指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="toc-text">4. 设计与声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-18%EF%BC%9A%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="toc-text">条款 18：让接口容易被正确使用，不易被误用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-19%EF%BC%9A%E8%AE%BE%E8%AE%A1%E7%B1%BB%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%9E%8B"><span class="toc-text">条款 19：设计类犹如设计类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-20%EF%BC%9A%E5%AE%81%E4%BB%A5%E4%BC%A0%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E6%9B%BF%E6%8D%A2%E4%BC%A0%E5%80%BC"><span class="toc-text">条款 20：宁以传常量引用替换传值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6%E5%BC%95%E7%94%A8"><span class="toc-text">条款 21：必须返回对象时，别妄想返回其引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BA%E7%A7%81%E6%9C%89"><span class="toc-text">条款 22：将成员变量声明为私有</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-23%EF%BC%9A%E5%AE%81%E4%BB%A5%E9%9D%9E%E6%88%90%E5%91%98%E3%80%81%E9%9D%9E%E5%8F%8B%E5%85%83%E6%9B%BF%E6%8D%A2%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">条款 23：宁以非成员、非友元替换成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">条款 24：若所有参数皆需类型转换，请为此采用非成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-25%EF%BC%9A%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84-swap-%E5%87%BD%E6%95%B0"><span class="toc-text">条款 25：考虑写出一个不抛异常的 swap 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AE%9E%E7%8E%B0"><span class="toc-text">5. 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-26%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4"><span class="toc-text">条款 26：尽可能延后变量定义式的出现时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C"><span class="toc-text">条款 27：尽量少做转型动作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-28%EF%BC%9A%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86%E7%9A%84%E5%8F%A5%E6%9F%84"><span class="toc-text">条款 28：避免返回指向对象内部成分的句柄</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-29%EF%BC%9A%E4%B8%BA%E2%80%9C%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="toc-text">条款 29：为“异常安全”而努力是值得的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-30%EF%BC%9A%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3%E5%86%85%E8%81%94%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="toc-text">条款 30：透彻了解内联的里里外外</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-31%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E"><span class="toc-text">条款 31：将文件的编译依存关系降至最低</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="toc-text">6. 继承与面向对象设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-32%EF%BC%9A%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BA%E2%80%9C%E6%98%AF%E4%B8%80%E4%B8%AA%E2%80%9D%E5%85%B3%E7%B3%BB"><span class="toc-text">条款 32：确定你的公有继承塑模出“是一个”关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-33%EF%BC%9A%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-text">条款 33：避免遮掩继承而来的名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-34%EF%BC%9A%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-text">条款 34：区分接口继承和实现继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-35%EF%BC%9A%E8%80%83%E8%99%91%E8%99%9A%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="toc-text">条款 35：考虑虚函数以外的其他选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-36%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E9%9D%9E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">条款 36：绝不重新定义继承而来的非虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-37%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-text">条款 37：绝不重新定义继承而来的缺省参数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-38%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BA%E2%80%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E2%80%9D%E6%88%96%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D"><span class="toc-text">条款 38：通过复合塑模出“有一个”或“根据某物实现出”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-39%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-text">条款 39：明智而审慎地使用私有继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-40%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">条款 40：明智而审慎地使用多重继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">7. 模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-41%EF%BC%9A%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81"><span class="toc-text">条款 41：了解隐式接口和编译期多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-42%EF%BC%9A%E4%BA%86%E8%A7%A3-typename-%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="toc-text">条款 42：了解 typename 的双重意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-43%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-text">条款 43：学习处理模板化基类内的名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-44%EF%BC%9A%E5%B0%86%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text">条款 44：将与参数无关的代码抽离模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-45%EF%BC%9A%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="toc-text">条款 45：运用成员函数模板接受所有兼容类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-46%EF%BC%9A%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%AF%B7%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">条款 46：需要类型转换时请为模板定义非成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-47%EF%BC%9A%E8%AF%B7%E4%BD%BF%E7%94%A8%E8%90%83%E5%8F%96%E7%B1%BB%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-text">条款 47：请使用萃取类表现类型信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-48%EF%BC%9A%E8%AE%A4%E8%AF%86%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-text">条款 48：认识模板元编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%AE%9A%E5%88%B6-new-%E5%92%8C-delete"><span class="toc-text">8. 定制 new 和 delete</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-49%EF%BC%9A%E4%BA%86%E8%A7%A3-new-handler-%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text">条款 49：了解 new-handler 的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-50%EF%BC%9A%E4%BA%86%E8%A7%A3-new-%E5%92%8C-delete-%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="toc-text">条款 50：了解 new 和 delete 的合理替换时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-51%EF%BC%9A%E7%BC%96%E5%86%99-new-%E5%92%8C-delete-%E6%97%B6%E9%9C%80%E5%9B%BA%E5%AE%88%E5%B8%B8%E8%A7%84"><span class="toc-text">条款 51：编写 new 和 delete 时需固守常规</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-52%EF%BC%9A%E5%86%99%E4%BA%86%E5%8E%9F%E4%BD%8D-new-%E4%B9%9F%E8%A6%81%E5%86%99%E5%8E%9F%E4%BD%8D-delete"><span class="toc-text">条款 52：写了原位 new 也要写原位 delete</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA"><span class="toc-text">9. 杂项讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-53%EF%BC%9A%E4%B8%8D%E8%A6%81%E8%BD%BB%E6%98%93%E5%BF%BD%E8%A7%86%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%AD%A6%E5%91%8A"><span class="toc-text">条款 53：不要轻易忽视编译器的警告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-54%EF%BC%9A%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89%E5%8C%85%E6%8B%AC-TR1-%E5%9C%A8%E5%86%85%E7%9A%84%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93"><span class="toc-text">条款 54：让自己熟悉包括 TR1 在内的标准程序库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-55%EF%BC%9A%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89-Boost"><span class="toc-text">条款 55：让自己熟悉 Boost</span></a></li></ol></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>Effective 系列</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/01/03%20Effective%20C++/" title="Effective C++"><img src="/img/03/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective C++"></a><div class="content"><a class="title" href="/2023/11/01/03%20Effective%20C++/" title="Effective C++">Effective C++</a><time datetime="2023-11-01T03:32:12.000Z" title="发表于 2023-11-01 11:32:12">2023-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/01/04%20More%20Effective%20C++/" title="More Effective C++"><img src="/img/04/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="More Effective C++"></a><div class="content"><a class="title" href="/2023/12/01/04%20More%20Effective%20C++/" title="More Effective C++">More Effective C++</a><time datetime="2023-12-01T03:33:04.000Z" title="发表于 2023-12-01 11:33:04">2023-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/01/05%20Effective%20STL/" title="Effective STL"><img src="/img/05/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective STL"></a><div class="content"><a class="title" href="/2024/01/01/05%20Effective%20STL/" title="Effective STL">Effective STL</a><time datetime="2024-01-01T03:33:18.000Z" title="发表于 2024-01-01 11:33:18">2024-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/01/06%20Effective%20Modern%20C++/" title="Effective Modern C++"><img src="/img/06/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective Modern C++"></a><div class="content"><a class="title" href="/2024/02/01/06%20Effective%20Modern%20C++/" title="Effective Modern C++">Effective Modern C++</a><time datetime="2024-02-01T03:33:40.000Z" title="发表于 2024-02-01 11:33:40">2024-02-01</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/18/17%20%E5%8F%A4%E6%96%87%E8%A7%82%E6%AD%A2/" title="古文观止"><img src="/img/17/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="古文观止"/></a><div class="content"><a class="title" href="/2025/08/18/17%20%E5%8F%A4%E6%96%87%E8%A7%82%E6%AD%A2/" title="古文观止">古文观止</a><time datetime="2025-08-29T02:24:49.673Z" title="更新于 2025-08-29 10:24:49">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/23/16%20%E6%B2%A7%E6%B5%B7%E9%81%97%E7%8F%A0%C2%B7%E5%94%90%E8%AF%97%E5%AE%8B%E8%AF%8D%E6%8B%BE%E8%90%83/" title="沧海遗珠·唐诗宋词拾萃"><img src="/img/16/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="沧海遗珠·唐诗宋词拾萃"/></a><div class="content"><a class="title" href="/2025/07/23/16%20%E6%B2%A7%E6%B5%B7%E9%81%97%E7%8F%A0%C2%B7%E5%94%90%E8%AF%97%E5%AE%8B%E8%AF%8D%E6%8B%BE%E8%90%83/" title="沧海遗珠·唐诗宋词拾萃">沧海遗珠·唐诗宋词拾萃</a><time datetime="2025-07-28T00:54:31.796Z" title="更新于 2025-07-28 08:54:31">2025-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/25/02_6%20C++%20Lambda%20%E7%9A%84%E6%95%85%E4%BA%8B%E4%B9%8B%E9%99%84%E5%BD%95/" title="C++ Lambda 的故事——附录"><img src="/img/02/cover6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ Lambda 的故事——附录"/></a><div class="content"><a class="title" href="/2023/10/25/02_6%20C++%20Lambda%20%E7%9A%84%E6%95%85%E4%BA%8B%E4%B9%8B%E9%99%84%E5%BD%95/" title="C++ Lambda 的故事——附录">C++ Lambda 的故事——附录</a><time datetime="2025-07-28T00:54:31.789Z" title="更新于 2025-07-28 08:54:31">2025-07-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/03/top.png);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2023 - 2025 By 奇点创客</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const abcjsInit = () => {
    const abcjsFn = () => {
      setTimeout(() => {
        const sheets = document.querySelectorAll(".abc-music-sheet")
        for (let i = 0; i < sheets.length; i++) {
          const ele = sheets[i]
          if (ele.children.length > 0) continue

          // Parse parameters from data-params attribute
          let params = {}
          const dp = ele.getAttribute("data-params")
          if (dp) {
            try {
              params = JSON.parse(dp)
            } catch (e) {
              console.error("Failed to parse data-params:", e)
            }
          }

          // Merge parsed parameters with the responsive option
          // Ensures params content appears before responsive
          const options = { ...params, responsive: "resize" }

          // Render the music score using ABCJS.renderAbc
          ABCJS.renderAbc(ele, ele.innerHTML, options)
        }
      }, 100)
    }

    if (typeof ABCJS === "object") {
      abcjsFn()
    } else {
      btf.getScript("https://cdn.jsdelivr.net/npm/abcjs/dist/abcjs-basic-min.min.js").then(abcjsFn)
    }
  }

  if (window.pjax) {
    abcjsInit()
  } else {
    window.addEventListener("load", abcjsInit)
  }

  btf.addGlobalFn("encrypt", abcjsInit, "abcjs")
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: '6xahBDKE9bVdQzuufG4r0SrN-gzGzoHsz',
      appKey: 'aS53wAMJ32RwAJRsefQAsX9P',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","hOffset":50,"width":200,"height":400},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>