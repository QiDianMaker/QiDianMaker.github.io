

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/about/favicon.png">
  <link rel="icon" href="/images/about/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="QiDianMaker">
  <meta name="keywords" content="">
  
    <meta name="description" content="第 15 章 模板实参推导如果每个函数模板都要显式地指定模板实参，那么代码一下子就变得笨重起来（型如：concat&lt;std::string, int&gt;(s, 3)）。幸运的是，C++编译器常常可以自动判断模板实参类型，这是通过一个十分高效的过程——模板实参推导——来完成的。 本章中我们将详述模板实参推导这一过程的细节。C++世界的诸多大道产生的结果向来直观，模板实参推导也不例外。深入理">
<meta property="og:type" content="article">
<meta property="og:title" content="奇点创客">
<meta property="og:url" content="http://example.com/2025/05/31/cpp-template-ch/cpp-template-ch15/index.html">
<meta property="og:site_name" content="奇点创客">
<meta property="og:description" content="第 15 章 模板实参推导如果每个函数模板都要显式地指定模板实参，那么代码一下子就变得笨重起来（型如：concat&lt;std::string, int&gt;(s, 3)）。幸运的是，C++编译器常常可以自动判断模板实参类型，这是通过一个十分高效的过程——模板实参推导——来完成的。 本章中我们将详述模板实参推导这一过程的细节。C++世界的诸多大道产生的结果向来直观，模板实参推导也不例外。深入理">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-05-31T03:57:27.504Z">
<meta property="article:modified_time" content="2025-05-31T03:57:27.505Z">
<meta property="article:author" content="QiDianMaker">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>奇点创客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":60,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"cpp"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"6xahBDKE9bVdQzuufG4r0SrN-gzGzoHsz","app_key":"aS53wAMJ32RwAJRsefQAsX9P","server_url":"https://6xahbdke.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>奇点创客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                <span>文库</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/archives/">
                    <i class="iconfont icon-archive-fill"></i>
                    <span>归档</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    <i class="iconfont icon-category-fill"></i>
                    <span>分类</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/">
                    <i class="iconfont icon-tags-fill"></i>
                    <span>标签</span>
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-th-large"></i>
                <span>精神家园</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/books/">
                    <i class="iconfont icon-book"></i>
                    <span>读书</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/music/">
                    <i class="iconfont icon-music"></i>
                    <span>音乐</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/movies/">
                    <i class="iconfont icon-youtube-fill"></i>
                    <span>电影</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/travel/">
                    <i class="iconfont icon-instagram-fill"></i>
                    <span>旅行</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tools/">
                    <i class="iconfont icon-briefcase"></i>
                    <span>工具</span>
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/images/about/post.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.4)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        QiDianMaker
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-30 19:57" pubdate>
          2025年5月30日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          53k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          442 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header"></h1>
            
            
              <div class="markdown-body">
                
                <h2 id="第-15-章-模板实参推导"><a href="#第-15-章-模板实参推导" class="headerlink" title="第 15 章 模板实参推导"></a>第 15 章 模板实参推导</h2><p>如果每个函数模板都要显式地指定模板实参，那么代码一下子就变得笨重起来（型如：<code>concat&lt;std::string, int&gt;(s, 3)</code>）。幸运的是，C++编译器常常可以自动判断模板实参类型，这是通过一个十分高效的过程——模板实参推导——来完成的。</p>
<p>本章中我们将详述模板实参推导这一过程的细节。C++世界的诸多大道产生的结果向来直观，模板实参推导也不例外。深入理解本章还可以使我们日后避免遇到出人意料的情景。</p>
<p>模板实参推导起初是为了简化函数模板的调用而被发明出来，但随着发展，它已被扩展到各种其他用途，其中包括：根据initializer确定变量的类型。</p>
<h2 id="15-1-推导过程"><a href="#15-1-推导过程" class="headerlink" title="15.1 推导过程"></a>15.1 推导过程</h2><p>基本的推导过程会去比较“函数调用的实参类型”与“函数模板对应位置的参数化类型”，然后针对要被推导的一到多个参数，分别尝试去推断一个正确的替换项。每个“实参-参数对”都会独立分析，并且如果最终得出的结论有矛盾，那么推导过程就以失败告终。</p>
<p>考虑下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> b &lt; a ? a : b;<br>&#125;<br><br><span class="hljs-keyword">auto</span> g = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure>

<p>这里第一个调用实参的类型是<code>int</code>，因此我们原生的<code>max()</code>模板的参数<code>T</code>会被姑且推导成<code>int</code>。然而，第二个调用实参是<code>double</code>类型，基于此，<code>T</code>会被推导为<code>double</code>：这就与前一个推导产生了矛盾。注意：我们称之为“推导过程失败”，而不是“程序非法”。毕竟，可能存在另一个名为<code>max</code>（函数模板可以像普通函数那样被重载；参考P15节1.5和第16章）的模板，它的推导可以成功。</p>
<p>即使所有被推导的模板实参都可以一致地确定（即不产生矛盾），推导过程仍然可能会失败。这种情况发生于：在函数声明中，进行替换的模板实参可能会导致无效的结构。请看下例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">typename</span> T::ElementT <span class="hljs-title">at</span><span class="hljs-params">(T a, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> a[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> x = <span class="hljs-built_in">at</span>(p, <span class="hljs-number">7</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里<code>T</code>被推导为<code>int*</code>(<code>T</code>出现的地方只有一种参数类型，因此显然不会有矛盾)。然而，将<code>T</code>替换为<code>int*</code>在C++中对于返回类型<code>T::ElementT</code>来说显然是非法的，因此推导还是失败了。</p>
<p>我们仍然需要挖掘实参-参数的匹配是如何进行的。我们会使用下面的术语来进行描述：匹配类型A（调用实参的类型）和参数化类型P（调用参数的声明）。如果调用参数被声明为引用，那么P就是引用背后的类型，A是实参的类型。如果调用参数并非引用，那么P就是参数类型，而A类型则会经历数组和函数类型到指针类型的退化、以及忽略顶层<code>const</code>和<code>volatile</code>限定符，最终获取。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span></span>;        <span class="hljs-comment">// parameterized type P is T</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T&amp;)</span></span>;    <span class="hljs-comment">// parameterized type P is also T</span><br><br><span class="hljs-type">double</span> arr[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> seven = <span class="hljs-number">7</span>;<br><br><span class="hljs-built_in">f</span>(arr);        <span class="hljs-comment">// nonreference parameter:     T is double*</span><br><span class="hljs-built_in">g</span>(arr);        <span class="hljs-comment">// reference parameter:        T is double[20]</span><br><span class="hljs-built_in">f</span>(seven);    <span class="hljs-comment">// nonreference parameter:     T is int</span><br><span class="hljs-built_in">g</span>(seven);    <span class="hljs-comment">// reference parameter:        T is int const</span><br><span class="hljs-built_in">f</span>(<span class="hljs-number">7</span>);        <span class="hljs-comment">// nonreference parameter:    T is int</span><br><span class="hljs-built_in">g</span>(<span class="hljs-number">7</span>);        <span class="hljs-comment">// reference parameter:        T is int =&gt; ERROR: can&#x27;t pass 7 to int&amp;</span><br></code></pre></td></tr></table></figure>

<p>对调用<code>f(arr)</code>来说，<code>arr</code>数组类型会退化为类型<code>double*</code>，也就是被推导出来的<code>T</code>的类型。在<code>f(seven)</code>中<code>const</code>限定符被忽略了，因此T被推导为<code>int</code>。<code>g(arr)</code>的推导则恰恰相反，<code>T</code>被推导为类型<code>double[20]</code>(没有发生退化)。类似地，<code>g(seven)</code>有一个类型为<code>int const</code>的左值实参，并且因为在匹配引用参数时，<code>const</code>和<code>volatile</code>限定符不会被去除，<code>T</code>会被推导成<code>int const</code>。然而，<code>g(7)</code>想要推导<code>T</code>为<code>int</code>（非类的右值表达式永远不会有cv限定），这一推导最终会失败，这是因为实参<code>7</code>无法作为一个<code>int&amp;</code>类型的参数被传递（译者注：右值不能传参给左值引用）。</p>
<p>引用型参数不会退化这一事实，对于参数为字符串字面量的场合来说可能会令人诧异。再来看看使用引用型参数的<code>max()</code>模板声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-type">const</span>&amp; <span class="hljs-title">max</span><span class="hljs-params">(T <span class="hljs-type">const</span>&amp; a, T <span class="hljs-type">const</span>&amp; b)</span></span>;<br></code></pre></td></tr></table></figure>

<p>对于表达式<code>max(&quot;Apple&quot;, &quot;Pie&quot;)</code>来说，我们合理的期望<code>T</code>能被推导为<code>char const*</code>。然而事与愿违，<code>Apple</code>的类型是<code>char const[6]</code>、<code>Pie</code>的类型是<code>char const[4]</code>。由于推导涉及了引用型参数，这里并不会进行数组到指针的退化，因此若想要推导成功，<code>T</code>必须既得是<code>char[6]</code>又得是<code>char[4]</code>。显然，这绝无可能。可以参考P115节7.4中对于如何处理这一场景的一个探讨。</p>
<h2 id="15-2-推导上下文"><a href="#15-2-推导上下文" class="headerlink" title="15.2 推导上下文"></a>15.2 推导上下文</h2><p>比仅是一个<code>T</code>要复杂得多的参数类型也可以匹配给定的实参类型。这里有一些相当基础的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(T*)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> E, <span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(E(&amp;)[N])</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> T3&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">(T1 (T2::*)(T3*))</span></span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span>*)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span>*** ppp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">bool</span> b[<span class="hljs-number">42</span>];<br>  <span class="hljs-built_in">f1</span>(ppp);        <span class="hljs-comment">// deduces T to be int**</span><br>  <span class="hljs-built_in">f2</span>(b);        <span class="hljs-comment">// deduces E to be bool and N to be 42</span><br>  <span class="hljs-built_in">f3</span>(&amp;S::f);    <span class="hljs-comment">// deduces T1 = void, T2 = S, and T3 = double</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>复杂的类型声明都是用比它更简单的结构（例如指针、引用、数组、函数声明；成员指针声明；模板ID等）来组成的，匹配过程从最顶层结构开始处理，向下递归到各种组成元素。可以说基于这一方法，大部分类型声明结构都可以进行匹配，而这些结构也被称为“推导上下文“。然而，有一些结构不能作为推导上下文。诸如：</p>
<ul>
<li>限定类型的名称。例如，形如<code>Q&lt;T&gt;::X</code>的类型名称永远不会用来推导模板参数<code>T</code>。</li>
<li>不仅仅是非类型参数的非类型表达式。例如，形如<code>S&lt;I+1&gt;</code>的类型名称永远不会用于推导<code>I</code>。再比如，<code>T</code>也不会通过匹配形如<code>int(&amp;)[sizeof(S&lt;T&gt;)]</code>类型的参数来推导。</li>
</ul>
<p>这些限制合乎常理，因为通常来说，推导并不是唯一的（甚至不一定是有限的），尽管有时候会很容易忽略这些限定类型的名称。此外，不能推导的上下文并不直接意味着：对应的程序有错误、甚至是前面分析过的参数不能再次进行类型推导。为了阐释这一事实，考虑下面这个更为错综复杂的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> I = <span class="hljs-type">int</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fppm</span><span class="hljs-params">(<span class="hljs-type">void</span> (X&lt;N&gt;::*p)(<span class="hljs-keyword">typename</span> X&lt;N&gt;::I))</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">fppm</span>(&amp;X&lt;<span class="hljs-number">33</span>&gt;::f);        <span class="hljs-comment">// fine: N deduced to be 33</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在函数模板<code>fppm()</code>中，子结构<code>X&lt;N&gt;::I</code>是一个不可推导上下文。然而，具有成员指针类型（即<code>X&lt;N&gt;::*p</code>）的成员类型部分<code>X&lt;N&gt;</code>是一个可推导上下文。于是，可以根据这个可推导上下文获得参数<code>N</code>，然后把<code>N</code>放入不可推导上下文<code>X&lt;N&gt;::I</code>，就能获得与实参<code>＆X&lt;33&gt;::f</code>相配的类型。因此基于这个实参-参数对的推导就是成功的。</p>
<p>反之，对于完全依赖推导上下文的参数类型来说，有可能会产生推导矛盾。例如，假设我们已恰当地声明过类模板<code>X</code>和<code>Y</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(X&lt;Y&lt;T&gt;, Y&lt;T&gt;&gt;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">f</span>(X&lt;Y&lt;<span class="hljs-type">int</span>&gt;, Y&lt;<span class="hljs-type">int</span>&gt;&gt;());    <span class="hljs-comment">// OK</span><br>  <span class="hljs-built_in">f</span>(X&lt;Y&lt;<span class="hljs-type">int</span>&gt;, Y&lt;<span class="hljs-type">char</span>&gt;&gt;());    <span class="hljs-comment">// ERROR: deduction fails</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>第二个调用的问题在于两个实参对于参数<code>T</code>的推导存在矛盾（对此二例，函数调用实参都是临时的对象，这一对象借由调用类模板<code>X</code>的默认构造器而获得）。</p>
<h2 id="15-3-特殊的推导情景"><a href="#15-3-特殊的推导情景" class="headerlink" title="15.3 特殊的推导情景"></a>15.3 特殊的推导情景</h2><p>还有一些特殊的情景：用于推导的实参-参数对（A, P）并非来源于函数调用的实参和函数模板的参数。第一种情景出现在取函数模板地址的时候。此时，P是函数模板声明的参数化类型（即下面<code>f</code>的类型），而A是被赋值（或者初始化）的指针（即下面的<code>pf</code>）所代表的函数类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T, T)</span></span>;<br><br><span class="hljs-built_in">void</span> (*pf)(<span class="hljs-type">char</span>,<span class="hljs-type">char</span>) = &amp;f;<br></code></pre></td></tr></table></figure>

<p>在本例中，P是<code>void(T, T)</code>，而A是<code>void(char, char)</code>。推导随着<code>T</code>被<code>char</code>替换而成功，而<code>pf</code>用特化体<code>f&lt;char&gt;</code>的地址进行初始化。</p>
<p>类似地，函数类型在一些其他特殊情况下也被P和A所使用：</p>
<ul>
<li>确定重载函数模板之间的偏序</li>
<li>将某个显式特化体与某个函数模板匹配</li>
<li>将某个显式实例化体与某个模板匹配</li>
<li>将某个友元函数模板特化体与某个模板匹配</li>
<li>将占位(replacement)<code>operator delete</code>或是<code>operator delete[]</code>与对应的占位<code>operator new</code>或<code>operator new[]</code>模板匹配。</li>
</ul>
<p>这些话题中的部分内容，以及类模板偏特化中模板实参推导的使用，会在第16章中进行展开。</p>
<p>另一种特殊情况和类型转换运算符模板一起出现。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">operator</span> T&amp;();<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在这种情况下，对于实参-参数对(P, A)，它的获取过程就好像涉及到了我们试图转换的类型的实参和转换运算符的返回类型的参数一样。下面的代码阐释了这一情景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> (&amp;)[<span class="hljs-number">20</span>])</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(S s)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">f</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里，我们试图把<code>S</code>转换为类型<code>int(&amp;)[20]</code>，因此，类型A就是<code>int[20]</code>，而类型P为<code>T</code>。<code>T</code>用<code>int[20]</code>替换，推导得以成功。</p>
<p>最后，对于<code>auto</code>占位类型来说，也需要一些特殊的处理。这会在P303节15.10.4中进行讨论。</p>
<h2 id="15-4-初始化列表-initializer-list"><a href="#15-4-初始化列表-initializer-list" class="headerlink" title="15.4 初始化列表(initializer list)"></a>15.4 初始化列表(initializer list)</h2><p>当函数调用的实参是一个初始化列表时，该实参是没有特定类型的，因此通常来说，对于给定实参-参数对(A, P)，不会进行任何推导，因为这里并不存在A。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T p)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">f</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);        <span class="hljs-comment">// ERROR: cannot deduce T from a braced list</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>然而，如果在移除引用、顶层const和volatile限定后，参数类型<code>P</code>与某个具有可推导模式的类型<code>P&#39;</code>的<code>std::initializer_list&lt;P&#39;&gt;</code>等价，则推导过程会将初始化列表的每个元素类型与<code>P&#39;</code>进行比较，仅当所有元素具有相同类型时，推导才会成功。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// deduce/initlist.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(std::initializer_list&lt;T&gt;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;);                        <span class="hljs-comment">// OK: T is deduced to int</span><br>    <span class="hljs-built_in">f</span>(&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-number">42</span>&#125;);    <span class="hljs-comment">// ERROR: T deduced to both char and int</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>类似地，如果参数类型<code>P</code>是对具有元素类型<code>P&#39;</code>的数组类型的引用，其中<code>P&#39;</code>是具有可推导模式的某个类型，那么推导过程也会将初始化列表的每个元素的类型与<code>P&#39;</code>进行比较，当且仅当所有元素具有相同的类型时，推导才会成功。此外，如果（数组）边界有一个可推导模式（即，使用一个非类型模板参数），那么该边界会被推导为初始化列表中元素的数量。</p>
<h2 id="15-5-参数包"><a href="#15-5-参数包" class="headerlink" title="15.5 参数包"></a>15.5 参数包</h2><p>推导过程会逐一匹配每个实参到每个参数来确定模板实参的值。然而在对可变模板进行模板实参推导时，参数和实参之间1比1的关系就被打破了，这是因为一个参数包可以匹配多个实参。在本例中，同一个参数包(P)被匹配到了多个实参(A)，并且每次匹配都会为P中的任何模板参数包产生附加值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Rest&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(First first, Rest... rest)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">double</span> j, <span class="hljs-type">int</span>* k)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">f</span>(i, j, k);    <span class="hljs-comment">// deduces First to int, Rest to &#123;double, int*&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>此处对首个函数参数的推导很简单，毕竟它并没有卷入任何参数包。第二个函数参数，<code>rest</code>，是一个函数参数包。它的类型是一个包展开(<code>Rest...</code>)，其模式为类型<code>Rest</code>：该模式用作P，与第二和第三调用参数的类型A进行比较。当匹配第一个A时（类型<code>double</code>），模板参数包<code>Rest</code>的第一个值被推导为<code>double</code>。类似地，与第二个A进行匹配时，模板参数包<code>Rest</code>的第二个值被推导为<code>int*</code>。因此，推导确定了参数包<code>Rest</code>的值序列为<code>&#123;double, int*&#125;</code>。替换以上推导结果就可以得到函数类型<code>void(int, double, int*)</code>，它与函数调用的每个实参类型相匹配。</p>
<p>由于对函数参数包进行推导使用了扩展的模式进行比较，所以该模式可以是任意复杂的，并且多个模板参数和参数包的值可以从每个实参类型中确定。考虑下面的函数<code>h1()</code>和<code>h2()</code>的推导行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">pair</span> &#123; &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Rest&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h1</span><span class="hljs-params">(pair&lt;T, Rest&gt; <span class="hljs-type">const</span>&amp;...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts, <span class="hljs-keyword">typename</span>... Rest&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h2</span><span class="hljs-params">(pair&lt;Ts, Rest&gt; <span class="hljs-type">const</span>&amp;...)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; pif, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; pid, pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; pdd)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">h1</span>(pif, pid);    <span class="hljs-comment">// OK: deduces T to int, Rest to &#123;float, double&#125;</span><br>  <span class="hljs-built_in">h2</span>(pif, pid);    <span class="hljs-comment">// OK: deduces Ts to &#123;int, int&#125;, Rest to &#123;float, double&#125;</span><br>  <span class="hljs-built_in">h1</span>(pif, pdd);    <span class="hljs-comment">// ERROR: T deduced to int from the 1st arg, but to double from the 2nd</span><br>  <span class="hljs-built_in">h2</span>(pif, pdd);    <span class="hljs-comment">// OK: deduces Ts to &#123;int, double&#125;, Rest to &#123;float, double&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>对<code>h1()</code>和<code>h2()</code>来说，P都是引用类型，它们分别与非限定版本的引用相匹配，再次用于推导每个参数类型（分别为<code>pair&lt;T, Rest&gt;</code>和<code>pair&lt;Ts, Rest&gt;</code>的引用）。由于所有的参数和实参都是类模板<code>pair</code>的特化，因此进行了模板实参的比较。对<code>h1()</code>来说，第一个模板实参<code>T</code>不是参数包，因此它的值是独立地对每个实参进行推导的。如果推导的结果出现矛盾（正如对<code>h1</code>的第二次调用那样），推导就会失败。对于<code>h1()</code>和<code>h2()</code>中的第二个<code>pair</code>模板实参<code>Rest</code>、以及<code>h2()</code>中的第一个<code>pair</code>模板实参<code>Ts</code>，推导会根据A的每个实参类型来确定一连串的参数包的值。</p>
<p>参数包的推导不仅限于“实参-参数对”来自调用参数的函数参数包。实际上，在函数参数列表或模板参数列表末尾的包展开处推导都会被使用。例如，考虑一个简单的<code>Tuple</code>类型上的两个相似操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuple</span> &#123; &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">f1</span><span class="hljs-params">(Tuple&lt;Types...&gt;, Tuple&lt;Types...&gt;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types1, <span class="hljs-keyword">typename</span>... Types2&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">f2</span><span class="hljs-params">(Tuple&lt;Types1...&gt;, Tuple&lt;Types2...&gt;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(Tuple&lt;<span class="hljs-type">short</span>, <span class="hljs-type">int</span>, <span class="hljs-type">long</span>&gt; sv, Tuple&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>, <span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>&gt; uv)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">f1</span>(sv, sv);    <span class="hljs-comment">// OK: Types is deduced to &#123;short int, long&#125;</span><br>  <span class="hljs-built_in">f2</span>(sv, sv);    <span class="hljs-comment">// OK: Types1 is deduced to &#123;short, int, long&#125;,</span><br>                  <span class="hljs-comment">//     Types2 is deduced to &#123;short, int, long&#125;</span><br>  <span class="hljs-built_in">f1</span>(sv, uv);    <span class="hljs-comment">// ERROR: Types is deduced to &#123;short, int, long&#125; from the 1st arg, </span><br>                  <span class="hljs-comment">//        but to &#123;unsigned short, unsigned, unsigned long&#125; from the 2nd</span><br>  <span class="hljs-built_in">f2</span>(sv, uv);    <span class="hljs-comment">// OK: Types1 is deduced to &#123;short, int, long&#125;,</span><br>                  <span class="hljs-comment">//     Types2 is deduced to &#123;unsigned short, unsigned, unsigned long&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>f1()</code>和<code>f2()</code>中，模板参数包都是将<code>Tuple</code>类型内嵌的包展开模式与调用实参所提供的<code>Tuple</code>类型进行比较，为一致的模板参数包推导出正确的值。函数<code>f1()</code>对两个函数参数使用相同的模板参数包<code>Types</code>，确保只有当两个函数调用实参有相同的<code>Tuple</code>特化体类型时，才能推导成功。而<code>f2()</code>则为每个函数参数各使用了一个参数包，因此两个调用参数可以不同——也就可以使用<code>Tuple</code>的两种特化体类型。</p>
<h3 id="15-5-1-字面量操作符模板"><a href="#15-5-1-字面量操作符模板" class="headerlink" title="15.5.1 字面量操作符模板"></a>15.5.1 字面量操作符模板</h3><p>字面量操作符模板的实参通过一种独特的方式来确定。下面的例子进行了阐释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">char</span>...&gt; <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span> _B7();    <span class="hljs-comment">// #1</span><br>...<br><span class="hljs-type">int</span> a = <span class="hljs-number">121</span>_B7;        <span class="hljs-comment">// #2</span><br></code></pre></td></tr></table></figure>

<p>这里，#2处的初始化器包含了一个用户定义的字面量（它会转换成对字面操作符模板的调用，使用的模板实参列表为<code>&lt;&#39;1&#39;,&#39;2&#39;,&#39;1&#39;&gt;</code>）。因此，字面量操作符的实现体可能如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">char</span>... cs&gt;<br><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _B7()<br>&#123;<br>  std::array&lt;<span class="hljs-type">char</span>,<span class="hljs-keyword">sizeof</span>...(cs)&gt; chars&#123;cs...&#125;;    <span class="hljs-comment">// initialize array of passed chars</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : chars) &#123;                            <span class="hljs-comment">// and use it (print it here)</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;&#x27;&quot;</span> &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot;&#x27;&quot;</span>;<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  <span class="hljs-keyword">return</span> ...;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它会为121.5_B7输出<code>&#39;1&#39; &#39;2&#39; &#39;1&#39; &#39;.&#39; &#39;5&#39;</code>。</p>
<p>请注意，仅在没有后缀的情况下仍然有效的数值字面量才支持此技术。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> b = <span class="hljs-number">01.3</span>_B7;    <span class="hljs-comment">// OK: deduces &lt;&#x27;0&#x27;,&#x27;1&#x27;,&#x27;.&#x27;,&#x27;3&#x27;&gt;</span><br><span class="hljs-keyword">auto</span> c = <span class="hljs-number">0xFF00</span>_B7;    <span class="hljs-comment">// OK: deduces &lt;&#x27;0&#x27;,&#x27;x&#x27;,&#x27;F&#x27;,&#x27;F&#x27;,&#x27;0&#x27;,&#x27;0&#x27;&gt;</span><br><span class="hljs-keyword">auto</span> d = <span class="hljs-number">0815</span>_B7;    <span class="hljs-comment">// ERROR: 8 is no valid octal literal </span><br><span class="hljs-keyword">auto</span> e = hello_B7;    <span class="hljs-comment">// ERROR: identifier hello_B7 is not defined</span><br><span class="hljs-keyword">auto</span> f = <span class="hljs-string">&quot;hello&quot;</span>_B7;    <span class="hljs-comment">// ERROR: literal operator _B7 does not match</span><br></code></pre></td></tr></table></figure>

<p>参考P599节25.6对这一特性的应用：编译期计算整型字面量。</p>
<h2 id="15-6-右值引用"><a href="#15-6-右值引用" class="headerlink" title="15.6 右值引用"></a>15.6 右值引用</h2><p>C++11引入的右值引用促生了许多新技术，包括移动语义和完美转发。本节会描述右值引用与推导之间的交互。</p>
<h3 id="15-6-1-引用折叠法则"><a href="#15-6-1-引用折叠法则" class="headerlink" title="15.6.1 引用折叠法则"></a>15.6.1 引用折叠法则</h3><p>开发者不允许直接声明“引用的引用”：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> <span class="hljs-type">const</span>&amp; r = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span>&amp; &amp; ref2ref = i;    <span class="hljs-comment">// ERROR: reference to reference is invalid</span><br></code></pre></td></tr></table></figure>

<p>然而，当通过模板参数替换、类型别名或是<code>decltype</code>结构构造类型时，“引用的引用”将被允许。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> RI = <span class="hljs-type">int</span>&amp;;<br><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br>RI r = i;<br>RI <span class="hljs-type">const</span>&amp; rr = r;    <span class="hljs-comment">// OK: rr has type int&amp;</span><br></code></pre></td></tr></table></figure>

<p>判定像是这种组织结构的类型结果的规则，就是众所周知的引用折叠法则。首先，任何应用于内部引用顶层的<code>const</code>或<code>volatile</code>限定都会被舍弃（也就是说，只有内层引用的底层限定才会被保留）。此后，这两种引用会根据表15.1推导出单一引用，这种推导方式可以总结为一句话：“如果某个引用是左值引用，那么结果也一定是左值引用，否则就是右值引用”。</p>
<table>
<thead>
<tr>
<th>内层引用</th>
<th>外层引用</th>
<th>结果引用</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>&amp;</td>
<td>&amp;</td>
</tr>
<tr>
<td>&amp;</td>
<td>&amp;&amp;</td>
<td>&amp;</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>&amp;</td>
<td>&amp;</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>&amp;&amp;</td>
<td>&amp;&amp;</td>
</tr>
</tbody></table>
<center>表15.1 引用折叠法则</center>

<p>展示这一规则的更多示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> RCI = <span class="hljs-type">int</span> <span class="hljs-type">const</span> &amp;;<br>RCI <span class="hljs-keyword">volatile</span>&amp;&amp; r = <span class="hljs-number">42</span>;    <span class="hljs-comment">// OK: r has type int const &amp;;</span><br><span class="hljs-keyword">using</span> RRI = <span class="hljs-type">int</span>&amp;&amp;;<br>RRI <span class="hljs-type">const</span>&amp;&amp; rr = <span class="hljs-number">42</span>;    <span class="hljs-comment">// OK: rr has type int&amp;&amp;</span><br></code></pre></td></tr></table></figure>

<p>这里<code>volatile</code>被应用在<code>RCI</code>这一引用类型（<code>int const&amp;</code>的别名）的顶层，因此会被丢弃掉。这一类型的顶层又放置了一个右值引用，但是由于底层类型是一个左值引用（左值引用在引用折叠规则中“更优先”），所以最终的类型保留为<code>int const&amp;</code>（或者<code>RCI</code>类型、一个等价的别名）。类似地，<code>RRI</code>的顶层const会被丢弃，在右值引用类型上应用一个右值引用，最后的结果依然是一个右值引用类型（可以绑定到像42这样的右值上）。</p>
<h3 id="15-6-2-转发引用"><a href="#15-6-2-转发引用" class="headerlink" title="15.6.2 转发引用"></a>15.6.2 转发引用</h3><p>如同P91节6.1所介绍的那样，当函数参数是一个转发引用（函数模板参数中的右值引用）时，模板实参推导会呈现另一种表现形式。此时，模板实参推导不仅会考虑函数调用实参的类型，同时也会考虑该实参是左值还是右值。如果实参是一个左值，那么模板实参推导所确定的类型就是该实参类型的左值引用类型，引用折叠规则会确保所替换的参数可以成为一个左值引用。如果实参不是左值，那么模板参数所推导的类型就是实参类型，而替代的参数是该类型的右值引用。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; p)</span></span>;    <span class="hljs-comment">// p is a forwarding reference</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">int</span> <span class="hljs-type">const</span> j = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">f</span>(i);        <span class="hljs-comment">// argument is an lvalue; deduces T to int&amp; and</span><br>              <span class="hljs-comment">// parameter p has type int&amp;</span><br>  <span class="hljs-built_in">f</span>(j);        <span class="hljs-comment">// argument is an lvalue; deduces T to int const&amp; </span><br>              <span class="hljs-comment">// parameter p has type int const&amp;</span><br>  <span class="hljs-built_in">f</span>(<span class="hljs-number">2</span>);        <span class="hljs-comment">// argument is an rvalue; deduces T to int</span><br>              <span class="hljs-comment">// parameter p has type int&amp;&amp;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在调用<code>f(i)</code>中，模板参数<code>T</code>被推导为<code>int&amp;</code>，因为表达式<code>i</code>是一个类型为<code>int</code>的左值。<code>T</code>替换<code>int&amp;</code>到参数类型<code>T&amp;&amp;</code>中需要引用折叠，这里我们使用规则<code>&amp;</code>+<code>&amp;&amp;</code>-&gt;<code>&amp;</code>来得出结论：参数类型为<code>int&amp;</code>，如此就可以完美的接受<code>int</code>类型的左值。相对的，在调用<code>f(2)</code>中，实参<code>2</code>是一个右值，模板参数因此直接被推导为右值的类型（即<code>int</code>）。这里不需要进行引用折叠，其结果直接就是<code>int&amp;&amp;</code>（同样地，对实参来说这是一个合适的参数类型）。</p>
<p>当<code>T</code>被推导为一个引用类型时，对于模板的实例化来说有些有趣的效果。例如，使用类型<code>T</code>声明的局部变量，在用左值实例化后，会有一个引用类型，而此时它就需要一个初始化器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp;)</span>    <span class="hljs-comment">// p is a forwarding reference</span></span><br><span class="hljs-function"></span>&#123;<br>  T x;    <span class="hljs-comment">// for passed lvalues, x is a reference</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这就意味着函数<code>f()</code>的定义需要很小心地使用类型<code>T</code>，或者函数模板本身根本不为左值参数生效。为了解决这一困境，<code>std::remove_reference</code>类型萃取常常被用来确保<code>x</code>不是一个引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp;)</span>    <span class="hljs-comment">// p is a forwarding reference</span></span><br><span class="hljs-function"></span>&#123;<br>  std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt; x;        <span class="hljs-comment">// x is never a reference</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="15-6-3-完美转发"><a href="#15-6-3-完美转发" class="headerlink" title="15.6.3 完美转发"></a>15.6.3 完美转发</h3><p>右值引用特殊的推导规则和引用折叠法则组合在一起使得编写一个接受任何实参的函数模板来捕捉其表征属性（它的类型、是左值还是右值）成为了可能。函数模板此后可以“转发”这一实参给另一个函数，恰如此例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>  ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(C&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(C <span class="hljs-type">const</span>&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(C&amp;&amp;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forwardToG</span><span class="hljs-params">(T&amp;&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">g</span>(<span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(x));    <span class="hljs-comment">// forward x to g()</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  C v;<br>  C <span class="hljs-type">const</span> c;<br>  forwardToG(v);    <span class="hljs-comment">// eventually calls g(C&amp;)</span><br>  forwardToG(c);    <span class="hljs-comment">// eventually calls g(C const&amp;)</span><br>  forwardToG(<span class="hljs-built_in">C</span>());    <span class="hljs-comment">// eventually calls g(C&amp;&amp;)</span><br>  forwardToG(std::<span class="hljs-built_in">move</span>(v));    <span class="hljs-comment">// eventually calls g(C&amp;&amp;)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上例所展示的技术被称为完美转发(perfect forwarding)，因为通过<code>forwardToG()</code>间接调用<code>g()</code>的效果与直接调用<code>g()</code>相同：没有额外的拷贝，选择的重载函数<code>g()</code>也一模一样。</p>
<p><code>static_cast</code>的使用需要一些额外的解释。在每个<code>forwardToG()</code>的实例化体中，参数<code>x</code>要么是一个左值引用，要么是一个右值引用。而无论如何，表达式<code>x</code>本身一定是一个（其引用类型的）左值。<code>static_cast</code>会将<code>x</code>转换为其原始类型（不管左值还是右值）。类型<code>T&amp;&amp;</code>要么折叠成一个左值引用（如果原本的实参是一个左值，那么<code>T</code>就是一个左值引用），要么是一个右值引用（原本的实参就是一个右值），因此<code>static_cast</code>的结果就有了一致的类型，不论原本的实参是左值也好、右值也罢，如此，就实现了完美转发。</p>
<p>如P91节6.1所介绍的那样，C++标准库提供了一个函数模板<code>std::forward&lt;&gt;()</code>（在头文件<code>&lt;utility&gt;</code>中），它被用来取代<code>static_cast</code>进行完美转发。相比晦涩难懂的<code>static_cast</code>结构来说，使用这一模板对开发者来说更加表意，同时也防止了诸如少写了一个<code>&amp;</code>所导致的错误。那么，上面的例子可以更为简明地写成这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">forwardToG</span><span class="hljs-params">(T&amp;&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">g</span>(std::forward&lt;T&gt;(x));    <span class="hljs-comment">// forward x to g()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>可变模板的完美转发</strong></p>
<p>完美转发与可变模板搭配在一起，可以让函数模板接受任意数量的函数调用实参并将它们逐一转发到另一个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt; <span class="hljs-type">void</span> <span class="hljs-title">forwardToG</span><span class="hljs-params">(Ts&amp;&amp;... xs)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">g</span>(std::forward&lt;Ts&gt;(xs)...);    <span class="hljs-comment">// forward all xs to g()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>forwardToG()</code>的实参会为参数包<code>Ts</code>分别被推导出合适的值（见P275节15.5），因此类型以及每个参数的左值性或右值性都会被捕获。包展开（见P201节12.4.1）在调用<code>g()</code>时会将每个实参都应用上述的完美转发技术进行转发。</p>
<p>尽管它拥有一个“完美转发”的名字，但实际上，从它不能捕获表达式所有感兴趣属性的意义上来说，完美转发实际上并不“完美”。例如，它无法区分左值是不是一个位域(bit-field)左值，也无法捕获表达式是否有特定的常量值。后者尤其在我们处理空指针常量时常常导致问题（它是一个整型类型、常量零值）。由于表达式常量值不会被完美转发所捕获，下例中的重载解析对直接调用<code>g()</code>和转发调用<code>g()</code>来说，表现上会有所区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(...)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">forwardToG</span><span class="hljs-params">(T&amp;&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">g</span>(std::forward&lt;T&gt;(x));    <span class="hljs-comment">// forward x to g()</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">g</span>(<span class="hljs-number">0</span>);                <span class="hljs-comment">// calls g(int*)</span><br>  forwardToG(<span class="hljs-number">0</span>);    <span class="hljs-comment">// eventually calls g(...)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这也是为什么使用<code>nullptr</code>(C++11所引入)取代空指针常量的一个原因：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">g</span>(<span class="hljs-literal">nullptr</span>);        <span class="hljs-comment">// calls g(int*)</span><br>forwardToG(<span class="hljs-literal">nullptr</span>);    <span class="hljs-comment">// eventually calls g(int*)</span><br></code></pre></td></tr></table></figure>

<p>我们所有完美转发的例子都聚焦于传递的函数实参要如何保留其精准的类型以及它是一个左值或是右值。当转发函数调用的返回值需要传递给另一个函数时，也面临着同样的问题（类型和值的分类，对左值和右值的概括在附录B中进行了讨论）。可以借助C++11引入的<code>decltype</code>语法（在P298节15.10.2中描述），使用这样一个有些繁琐的惯用法来解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">forwardToG</span><span class="hljs-params">(Ts&amp;&amp;... xs)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(g(std::forward&lt;Ts&gt;(xs))</span></span><br><span class="hljs-params"><span class="hljs-function">&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">return</span> g(std::forward&lt;Ts&gt;(xs)...);    <span class="hljs-comment">// forward all xs to g()</span></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure>

<p>请注意，<code>return</code>语句的表达式被拷贝到了<code>decltype</code>类型里，因此返回表达式的准确类型会被计算出来。尾随返回类型被使用（即，函数名称前的<code>auto</code>占位符和指示返回类型的<code>-&gt;</code>），使得函数参数包<code>xs</code>也在<code>decltype</code>类型的作用域。该转发函数会“完美地”转发所有实参给<code>g()</code>，然后再“完美地”转发其返回值给调用者。</p>
<p>C++14引入了额外的特性来简化这一情景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">forwardToG</span><span class="hljs-params">(Ts&amp;&amp;... xs)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">g</span>(std::forward&lt;Ts&gt;(xs)...);    <span class="hljs-comment">// forward all xs to g()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用<code>decltype(auto)</code>做返回类型会指示编译器通过函数定义来推导返回类型。参见P296节15.10.1和P301节15.10.3。</p>
<h3 id="15-6-4-意外的推导"><a href="#15-6-4-意外的推导" class="headerlink" title="15.6.4 意外的推导"></a>15.6.4 意外的推导</h3><p>对完美转发来说，右值引用的特殊推导规则非常有用。然而，有时候它们可能会令人惊讶，这是因为函数模板通常会泛化函数签名中的类型，不会影响它所允许的参数是何种类型（左值或右值）。考虑下例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">int_lvalues</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;)</span></span>;        <span class="hljs-comment">// accepts lvalues of type int</span><br><span class="hljs-function">templte&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">lvalues</span><span class="hljs-params">(T&amp;)</span></span>;    <span class="hljs-comment">// accepts lvalues of any type</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">int_rvalues</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp;)</span></span>;    <span class="hljs-comment">// accepts rvalues of type int</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">anything</span><span class="hljs-params">(T&amp;&amp;)</span></span>;    <span class="hljs-comment">// SURPRISE: accepts lvalues and</span><br>                                            <span class="hljs-comment">// rvalues of any type</span><br></code></pre></td></tr></table></figure>

<p>抽象出一个像<code>int_lvalues</code>那样的函数的开发者，可能会对函数模板<code>anything</code>可以接受左值而感到诧异。幸运的是，只有当函数参数写成特定的模板参数<code>&amp;&amp;</code>的形式时（作为函数模板的一部分且命名的模板参数是由该函数模板所声明），才会应用这一推导行为。因此，下面这些例子的情形都不会应用推导规则：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>(X&amp;&amp;);        <span class="hljs-comment">// X is not a template parameter</span><br>    <span class="hljs-built_in">X</span>(T&amp;&amp;);        <span class="hljs-comment">// this constructor is not a function template</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Other&gt; <span class="hljs-title">X</span><span class="hljs-params">(X&lt;U&gt;&amp;&amp;)</span></span>;    <span class="hljs-comment">// X&lt;U&gt; is not a template parameter</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt; <span class="hljs-title">X</span><span class="hljs-params">(U, T&amp;&amp;)</span></span>;        <span class="hljs-comment">// T is a template parameter from </span><br>                                        <span class="hljs-comment">// an outer template</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>尽管模板推导规则有着这些令人惊讶的行为，在实践中，这种行为导致问题的情况并不经常出现。当出现问题时，你可以组合使用SFINAE（参考P129节8.4和P284节15.7）和诸如<code>std::enable_if</code>的类型萃取来约束模板只能接受右值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> std::enable_if&lt;!std::is_lvalue_reference&lt;T&gt;::value&gt;::<span class="hljs-function">type </span><br><span class="hljs-function"><span class="hljs-title">rvalues</span><span class="hljs-params">(T&amp;&amp;)</span></span>;    <span class="hljs-comment">// accepts rvalue of any type</span><br></code></pre></td></tr></table></figure>

<h2 id="15-7-SFINAE-Substitution-Failure-Is-Not-An-Error"><a href="#15-7-SFINAE-Substitution-Failure-Is-Not-An-Error" class="headerlink" title="15.7 SFINAE(Substitution Failure Is Not An Error)"></a>15.7 SFINAE(Substitution Failure Is Not An Error)</h2><p>SFINAE(替换失败并非错误)原则在P129节8.4中介绍过，它是模板实参推导中在重载解析期间防止不相干的函数模板产生错误的关键先生。</p>
<p>例如，考虑这样一对函数模板，它们从给定的容器或数组榨取起始的迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">unsigned</span> N&gt;</span><br><span class="hljs-function">T* <span class="hljs-title">begin</span><span class="hljs-params">(T (&amp;array)[N])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">typename</span> Container::iterator <span class="hljs-title">begin</span><span class="hljs-params">(Container&amp; c)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">begin</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>  <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br>  <br>  ::<span class="hljs-built_in">begin</span>(v);    <span class="hljs-comment">// OK: only container begin() matches, because the first deduction fails</span><br>  ::<span class="hljs-built_in">begin</span>(a);    <span class="hljs-comment">// OK: only array begin() matches, because the second substitution fails</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一个<code>begin()</code>调用的实参是<code>std::vector&lt;int&gt;</code>，它试图为两个<code>begin()</code>函数模板做模板实参推导：</p>
<ul>
<li>对数组<code>begin()</code>的模板实参推导失败了，因为<code>std::vector</code>不是一个数组，所以被忽略。</li>
<li>模板实参推导对容器<code>begin</code>成功了，<code>Container</code>被推导成<code>std::vector&lt;int&gt;</code>，因此函数模板可以被实例化，也可以被调用。</li>
</ul>
<p>第二个<code>begin()</code>调用的实参是一个数组，也会部分失败：</p>
<ul>
<li>对数组<code>begin()</code>推导成功，<code>T</code>被推导为<code>int</code>，<code>N</code>被推导为<code>10</code>。</li>
<li>对容器<code>begin()</code>来说，推导需要将<code>Container</code>替换为<code>int[10]</code>，这本身没有问题，但是如此产生的返回类型<code>Container::iterator</code>却是无效的（因为数组类型并没有嵌套的名为<code>iterator</code>的类型）。在其他上下文中，试图访问一个本不存在的嵌套类型会立即导致一个编译期错误。而在模板实参的替换中，SFINAE会将这种错误转换成推导失败，并且不再将这一函数模板纳入考虑。因此，第二个<code>begin()</code>候选会被忽略，第一个<code>begin()</code>函数模板的特化体会被调用。</li>
</ul>
<h3 id="15-7-1-立即上下文"><a href="#15-7-1-立即上下文" class="headerlink" title="15.7.1 立即上下文"></a>15.7.1 立即上下文</h3><p>SFINAE阻止了那些无效类型或表达式的生成，包括因歧义或非法访问控制所产生的错误，它们发生在函数模板替换的立即上下文中。比起定义“函数模板替换的立即上下文”，对“不在该上下文中”进行定义可能更为容易。具体来说，在函数模板替换过程中，为了推导而发生的下面这些实例化期间的事，都不在函数模板替换的立即上下文中：</p>
<ul>
<li>类模板的定义（即，类模板本身以及其基类列表）</li>
<li>函数模板的定义（即，函数模板本身，对构造函数来说，是其构造初始化器）</li>
<li>变量模板初始化</li>
<li>默认实参</li>
<li>默认成员初始化</li>
<li>异常规范(exception specification)</li>
</ul>
<p>此外，任何由替换过程所触发的特殊成员函数的隐式定义也不属于替换的立即上下文。除这些以外，其余部分都被算在立即上下文中。</p>
<p>因此，如果在替换函数模板声明的模板参数时需要类模板实例化（因为该类被引用了），则实例化过程产生的错误并不在函数模板替换的即时上下文中，因此它会产生一个真正的错误（即使另一个函数模板可以无错误地匹配上）。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> iterator = T*;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Array&lt;T&gt;::iterator first, Array&lt;T&gt;::iterator last)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T*, T*)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">f</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-comment">// ERROR: substituting int&amp; for T in the first function template</span><br>                      <span class="hljs-comment">// instantiates Array&lt;int&amp;&gt;, which then fails</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>本例与前例最主要的差别在于失败发生的位置。前例中，失败发生在形成一个类型为<code>typename Container::iterator</code>之时，它在<code>begin()</code>函数模板替换的立即上下文中。而本例中，失败发生在<code>Array&lt;int&amp;&gt;</code>的实例化体中，尽管它是由函数模板上下文所触发，但实际上是发生在类模板<code>Array</code>的上下文中。因此，SFINAE原则并不适用，编译器会产生一个错误。</p>
<p>这里有一个C++14的例子——基于推导返回类型（P296节15.10.1）——在函数模板定义的实例化时导致错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">(T p)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> p-&gt;m;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(...)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">auto</span> <span class="hljs-title">g</span><span class="hljs-params">(T p)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(f(p))</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">g</span>(<span class="hljs-number">42</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用<code>g(42)</code>会推导<code>T</code>为<code>int</code>。这使得<code>g()</code>声明的替换需要我们去确定<code>f(p)</code>的类型（<code>p</code>现在已知为类型<code>int</code>），然后再确定<code>f()</code>的返回类型。<code>f()</code>有两个候选者。非模板候选者是匹配的，但它不是一个良选，这是因为它匹配的是一个省略型参数。不幸的是，模板候选者有一个推导的返回类型，因而我们必须实例化它的定义来确定该返回类型。该实例化会因为<code>p-&gt;m</code>无效而失败（因为<code>p</code>是<code>int</code>），并且该错误发生在替换上下文之外（因为它在随后的函数定义实例化体中），这就导致本次失败会产生一个错误。为此，我们推荐在可以容易地显式化指定返回类型时，避免使用推导返回类型。</p>
<p>SFINAE设计之初，是旨在消除由函数模板重载所带来的因非意图匹配而产生的奇怪错误，正如容器<code>begin</code>这一例子。然而，探测无效表达式或类型的能力可以实现卓越的编译期技巧，以允许我们判断某个特定的语法是否是合法的。这些技巧将在P416节19.4中进行讨论。</p>
<p>在P424节19.4.4中，有一个特别的例子：让类型萃取SFINAE-friendly来避免立即上下文所产生的问题。</p>
<h2 id="15-8-推导的限制"><a href="#15-8-推导的限制" class="headerlink" title="15.8 推导的限制"></a>15.8 推导的限制</h2><p>模板实参推导是一个强大的特性，对于大部分函数模板调用来说它消除了显式地指定模板实参的必要性，并且还使能了函数模板重载（见P15节1.5）和类模板偏特化（见P347节16.4）。然而，开发者可能会在使用模板时遇到一些使用上的限制，这些限制会在本节中进行讨论。</p>
<h3 id="15-8-1-合法的实参转换"><a href="#15-8-1-合法的实参转换" class="headerlink" title="15.8.1 合法的实参转换"></a>15.8.1 合法的实参转换</h3><p>通常来说，模板推导会尝试去找到一个函数模板参数的替换，使得参数化类型P与类型A等同。然而，当无法达成这一条件，而P在推导上下文中又包含了一个模板参数时，一些差别也可以容忍：</p>
<ul>
<li>如果原始的参数使用了引用声明，被替换的P类型相比A类型可以有进一步的<code>const/volatile</code>限定</li>
<li>如果A类型是一个指针或是类成员指针类型，它可以通过限定转换（换句话说，就是一种增加<code>const</code>或&#x2F;和<code>volatile</code>限定符的转换）来转换成一个替换的P类型。</li>
<li>除非推导发生于类型转换操作符模板，替代的P类型可以是A类型的基类或是指向其基类的指针。举个例子：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B&lt;T&gt; &#123;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(B&lt;T&gt;*)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(D&lt;<span class="hljs-type">long</span>&gt; dl)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">f</span>(&amp;dl);    <span class="hljs-comment">// deduction succeeds with T substituted with long</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果P在推导上下文中不包含模板参数，那么所有的隐式转换都是合法的。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(T, <span class="hljs-keyword">typename</span> T::X)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">V</span> &#123;<br>  <span class="hljs-built_in">V</span>();<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">double</span>);<br>  &#125;;<br>&#125;v;<br><span class="hljs-type">int</span> r = <span class="hljs-built_in">f</span>(v, <span class="hljs-number">7.0</span>);    <span class="hljs-comment">// OK: T is deduced to V through the first parameter,</span><br>                    <span class="hljs-comment">// which causes the second parameter to have type V::X</span><br>                    <span class="hljs-comment">// which can be constructed from a double value</span><br></code></pre></td></tr></table></figure>

<p>仅当严格匹配不可行时才会考虑宽松的匹配要求。即便附加了这些转换，推导也仅仅在可以找到满足A类型到P类型的合适替换时才会成功。</p>
<p>请注意，这些规则的适用范围相当狭隘，例如它不考虑为使调用成功而可行的函数实参的各种转换。比如，对下面<code>max()</code>函数模板的调用（该模板在P269节15.1介绍）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string <span class="hljs-title">maxWithHello</span><span class="hljs-params">(std::string s)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">max</span>(s, <span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里，模板实参推导根据第一个实参会把<code>T</code>推导为<code>std::string</code>，而第二个实参会把<code>T</code>推导为<code>char[6]</code>，所以模板实参推导会失败，这是因为两个参数使用的是同一个模板实参。这种失败可能有些令人诧异，因为字符串字面量<code>&quot;hello&quot;</code>可以被隐式转换成<code>std::string</code>，并且调用<code>::max&lt;std::string&gt;(s, &quot;helloa&quot;)</code>是可行的。</p>
<p>或许还有更令人惊讶的：当两个实参有着从公共基类继承下来的不同的类类型时，推导并不会将公共基类作为推导类型的候选者进行考虑。可参考P7节1.2关于这一议题的讨论以及可行的解决方案。</p>
<h3 id="15-8-2-类模板实参"><a href="#15-8-2-类模板实参" class="headerlink" title="15.8.2 类模板实参"></a>15.8.2 类模板实参</h3><p>C++17之前，模板实参推导仅仅应用于函数和成员函数模板。特别地，类模板的实参不会根据其中某一个构造器的实参来进行推导。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">S</span>(T b) : <span class="hljs-built_in">a</span>(b) &#123;&#125;<br>  <span class="hljs-keyword">private</span>:<br>    T a;<br>&#125;;<br><span class="hljs-function">S <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">12</span>)</span></span>;    <span class="hljs-comment">// ERROR before C++17: the class template parameter T was not deduced from</span><br>            <span class="hljs-comment">// the constructor call argument 12</span><br></code></pre></td></tr></table></figure>

<p>这一限制在C++17中被解除——参考P313节15.12。</p>
<h3 id="15-8-3-默认调用实参"><a href="#15-8-3-默认调用实参" class="headerlink" title="15.8.3 默认调用实参"></a>15.8.3 默认调用实参</h3><p>函数调用的默认实参可以在函数模板中指定，正如普通函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(T* loc, T <span class="hljs-type">const</span>&amp; val = T())</span></span><br><span class="hljs-function"></span>&#123;<br>  *loc = val;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>事实上，如上例所示，函数调用的默认实参可以依赖于模板参数。这种依赖型默认实参仅在没有提供显式的实参时才会被实例化。这一原则保证了下方示例的合法性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">S</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br>&#125;;<br><br><span class="hljs-function">S <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">init</span>(&amp;s, <span class="hljs-built_in">S</span>(<span class="hljs-number">7</span>,<span class="hljs-number">42</span>));    <span class="hljs-comment">// T() is invalid for T = S, but the default</span><br>                          <span class="hljs-comment">// call argument T() needs no instantiation</span><br>                        <span class="hljs-comment">// because  an explicit argument is given</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>即使默认实参不具有依赖性，它也依然无法被用于推导模板实参。这意味着在C++中，下面的写法是非法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T x = <span class="hljs-number">42</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">f</span>&lt;<span class="hljs-type">int</span>&gt;();    <span class="hljs-comment">// OK: T = int</span><br>  <span class="hljs-built_in">f</span>();        <span class="hljs-comment">// ERROR: cannot deduce T from default call argument</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="15-8-4-异常规范"><a href="#15-8-4-异常规范" class="headerlink" title="15.8.4 异常规范"></a>15.8.4 异常规范</h3><p>与默认实参一样，异常规范也仅仅在它们被需要时才会实例化。这意味着他们不会参与模板实参推导。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T, <span class="hljs-type">int</span>)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(nonexistent(T()))</span></span>;    <span class="hljs-comment">// #1</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T, ...)</span></span>;    <span class="hljs-comment">// #2 (C-style vararg function)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">f</span>(i, i);    <span class="hljs-comment">// ERROR: chooses #1, but the expression nonexistent(T()) is ill-formed</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>函数标记#1处的<code>noexcept</code>规范尝试调用一个<code>nonexistent</code>函数。通常来说，函数模板声明中这样的错误会直接触发模板实参推导失败（SFINAE），然后再通过选择标记#2处的函数使用省略型参数匹配是重载解析中最差的匹配，参考附录C）来匹配调用<code>f(i, i)</code>。然而，由于异常规范并没有参与到模板实参推导，重载解析还是会选择标记#1，这就导致当<code>noexcept</code>规范在随后实例化时，程序出现问题。</p>
<p>相同的规则适用于列出潜在异常类型的异常规范：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T, <span class="hljs-type">int</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> T::Nonexistent)</span></span>;    <span class="hljs-comment">// #1</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T, ...)</span></span>;                                    <span class="hljs-comment">// #2</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">g</span>(i, i);    <span class="hljs-comment">// ERROR: chooses #1, but the type T::Nonexistent is ill-formed</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>然而，这些“动态的”异常规范自C++11起就不再推荐使用(deprecated)，它们在C++17中被移除。</p>
<h2 id="15-9-显式的函数模板实参"><a href="#15-9-显式的函数模板实参" class="headerlink" title="15.9 显式的函数模板实参"></a>15.9 显式的函数模板实参</h2><p>当函数模板实参无法被推导时，通过尾随在函数模板名后显式地指定亦然可行。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; T <span class="hljs-title">default_value</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> T&#123;&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">default_value</span>&lt;<span class="hljs-type">int</span>&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对可推导的模板参数来说这也是可行的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">compute</span><span class="hljs-params">(T p)</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">compute</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一旦一个模板实参被显式指定了，其对应的参数就不再被推导。同时，函数调用的参数也被允许进行类型转换（对推导调用来说是不行的）。上例中，实参<code>2</code>在<code>compute&lt;double&gt;(2)</code>调用中会被隐式转换成<code>double</code>。</p>
<p>也可以显式指定模板实参的其中一部分。然而，被显式指定的部分必须始终按模板参数从左到右排好顺序。因此，那些不能被推导的（或者最可能被显式指定的）参数应该放在最前面。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Out, <span class="hljs-keyword">typename</span> In&gt;</span><br><span class="hljs-function">Out <span class="hljs-title">convert</span><span class="hljs-params">(In p)</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">convert</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">42</span>);    <span class="hljs-comment">// the type of parameter ps is deduced,</span><br>                                  <span class="hljs-comment">// but the return type is explicitly specified</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>有时候，通过指定一个空模板实参列表对于确保所选的函数是一个模板实例也很有用，此时模板实参还是会进行推导：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;        <span class="hljs-comment">// #1</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; T <span class="hljs-title">f</span><span class="hljs-params">(T)</span></span>;    <span class="hljs-comment">// #2</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">f</span>(<span class="hljs-number">42</span>);        <span class="hljs-comment">// calls #1</span><br>  <span class="hljs-keyword">auto</span> y = f&lt;&gt;(<span class="hljs-number">42</span>);        <span class="hljs-comment">// calls #2</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里<code>f(42)</code>会选择非模板函数，因为对于重载解析来说，相比函数模板，它更倾向于选择普通的函数（如果两者是等价的）。然而，对于<code>f&lt;&gt;(42)</code>来说，模板实参列表的存在打破了这一规则，非模板函数不再可选（即使没有指定实际的模板实参）。</p>
<p>在友元函数声明的上下文中，显式模板实参列表的存在会产生一个有趣的效用。考虑下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">namespace</span> N &#123;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">// OK</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> f&lt;&gt;();        <span class="hljs-comment">// ERROR: return type conflict</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当使用普通的标识符命名一个友元函数时，该函数仅仅会在最近一层的封闭作用域内进行查找，如果没有找到的话，就会在该作用域内声明一个新的实体（但它会保留“不可见性”，除非通过ADL查找；参考P220节13.2.2）。这就是我们的第一个友元声明：在<code>N</code>作用域内没有找到<code>f</code>的声明，所以会声明一个不可见的<code>N::f()</code>。</p>
<p>然而，当使用标识符尾随模板实参列表来命名友元函数时，模板必须在那一刻对一般查找是可见的，一般查找会向上搜索任意层作用域（根据其所需要）。因此，我们第二个声明会找到全局的函数模板<code>f()</code>，但是编译器会提出一个错误：返回类型不匹配（由于没有执行ADL，故前一个友元函数的声明会被忽略）。</p>
<p>显式指定的模板实参使用SFINAE法则来替换：如果在某个函数模板替换的立即上下文中出现了错误，那么它就会被丢弃，但是其他模板依然可能会成功。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">typename</span> T::EType <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// #1</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; T <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;                    <span class="hljs-comment">// #2</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">f</span>&lt;<span class="hljs-type">int</span>*&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里，#1处候选者在<code>int*</code>替换<code>T</code>时会失败，但在#2处却会成功，因此也就会选择#2这一候选。事实上，如果在替换之后仅余一个候选者，那么带有显式模板实参的函数模板名称看起来非常像一个普通的函数名称，包括在许多情况下退化为函数指针类型。也就是说，替换上面的<code>main()</code>为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> x = f&lt;<span class="hljs-type">int</span>*&gt;;    <span class="hljs-comment">// OK: x is a pointer to function</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这会产生合法的编译单元。然而，像是下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T, T)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> x = f&lt;<span class="hljs-type">int</span>*&gt;;        <span class="hljs-comment">// ERROR: there are two possible f&lt;int*&gt; here</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种用法就是非法的，因为<code>f&lt;int*&gt;</code>并没有标识着某一个单一的函数。</p>
<p>可变函数模板也可以使用显式模板实参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Ts&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Ts... ps)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">f</span>&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);    <span class="hljs-comment">// OK: 1 and 2 are converted to double</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>有趣的是，包可以被部分显式指定、部分显式推导：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Ts&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Ts... ps)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">f</span>&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);    <span class="hljs-comment">// OK: the template arguments are &lt;double, int, int&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="15-10-初始化器和表达式推导"><a href="#15-10-初始化器和表达式推导" class="headerlink" title="15.10 初始化器和表达式推导"></a>15.10 初始化器和表达式推导</h2><p>C++11引入了声明这样一种变量的能力：其类型可以根据initializer推导。C++11也提供了一种机制来表示某个命名实体（变量或函数）或是表达式的类型。这些机制十分易用，C++14和C++17对这一主题又进行了补充。</p>
<h3 id="15-10-1-auto类型指示符"><a href="#15-10-1-auto类型指示符" class="headerlink" title="15.10.1 auto类型指示符"></a>15.10.1 auto类型指示符</h3><p><code>auto</code>类型指示符在很多地方有着用武之地（主要是命名空间作用域和局部作用域），它会根据变量的初始化器推导变量类型。此时，<code>auto</code>被称作为一个占位符类型（另一个占位符类型是<code>decltype(auto)</code>），我们会在P298节15.10.2中对它进行描述。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useContainer</span><span class="hljs-params">(Container <span class="hljs-type">const</span>&amp; container)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">auto</span> pos = container.<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-keyword">while</span>(pos != container.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">auto</span>&amp; element = *pos++;<br>    ... <span class="hljs-comment">// operate on the element </span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上例中的两个<code>auto</code>，避免了去书写两个又臭又长的类型名称：容器的迭代器类型和迭代器的值类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typename</span> Container::const_iterator pos = container.<span class="hljs-built_in">begin</span>();<br>...<br><span class="hljs-keyword">typename</span> std::iterator_traits&lt;<span class="hljs-keyword">typename</span> Container::iterator&gt;::reference  element = *pos++;<br></code></pre></td></tr></table></figure>

<p><code>auto</code>的推导机制与模板实参推导机制相同。类型指示符<code>auto</code>取代模板类型参数<code>T</code>，然后推导可以继续进行，这就好像变量是一个函数参数，而其initializer是相应的函数实参。对例子中第一个<code>auto</code>来说，对应的情景如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">deducePos</span><span class="hljs-params">(T pos)</span></span>;<br><span class="hljs-built_in">deducePos</span>(container.<span class="hljs-built_in">begin</span>());<br></code></pre></td></tr></table></figure>

<p><code>T</code>是<code>auto</code>要推导的类型。这样做的直接后果之一是，类型为<code>auto</code>的变量永远不会是引用类型。第二个<code>auto</code>使用了<code>auto&amp;</code>来展示了如何产生一个推导类型的引用。它的推导与下面的函数模板和调用等价：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-title">deduceElement</span><span class="hljs-params">(T&amp; element)</span></span>;<br><span class="hljs-built_in">deduceElement</span>(*pos++);<br></code></pre></td></tr></table></figure>

<p>这里，<code>element</code>永远是引用类型，它的initializer无法产生一个临时对象。</p>
<p>组合<code>auto</code>与右值引用亦是可行的，但是这样做就让它看起来像是一个转发引用，因为<code>auto&amp;&amp; r = ...;</code>的推导模型基于这样一个函数模板：</p>
<p><code>template&lt;typename T&gt; void f(T&amp;&amp; fr); // auto replaced by template parameter T</code></p>
<p>这就解释了下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">auto</span>&amp;&amp; rr = <span class="hljs-number">42</span>;    <span class="hljs-comment">// OK: rvalue reference binds to an rvalue (auto = int)</span><br><span class="hljs-keyword">auto</span>&amp;&amp; lr = x;    <span class="hljs-comment">// Also OK: auto = int&amp; and reference collapsing makes</span><br>                <span class="hljs-comment">//             lr an lvalue reference</span><br></code></pre></td></tr></table></figure>

<p>在泛型代码中，这一技巧经常被用来绑定那些未知的函数或操作符调用结果的值类别（左值或是右值），而无需拷贝它们的结果。例如，常常推荐用这样的方式在循环中声明迭代值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt; <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(Container c)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;&amp; x : c) &#123;<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里我们不知道容器迭代器接口的签名，但是使用<code>auto&amp;&amp;</code>可以让我们确信在迭代时不会引入额外的值拷贝。如果需要完美转发边界值，那么<code>std::forward&lt;T&gt;()</code>可以像往常那样对变量使用。这使能了一种“延迟的”完美转发。可以参考P167节11.3的示例。</p>
<p>除了引用，我们还可以组合使用<code>auto</code>指示符来让某个变量拥有<code>const</code>，成为指针或是成员指针等等，但是<code>auto</code>必须是其声明的“主”类型。它不能嵌套在模板实参或类型指示符后面的声明符中作为一部分而存在。下面的示例予以了解释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123; T <span class="hljs-type">const</span> m; &#125;;<br><span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> N = <span class="hljs-number">400u</span>;    <span class="hljs-comment">// OK: constant of type unsigned int</span><br><span class="hljs-keyword">auto</span>* gp = (<span class="hljs-type">void</span>*)<span class="hljs-literal">nullptr</span>;    <span class="hljs-comment">// OK: gp has type void*</span><br><span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> S::*pm = &amp;X&lt;<span class="hljs-type">int</span>&gt;::m;        <span class="hljs-comment">// OK: pm has type int const X&lt;int&gt;::*</span><br>X&lt;<span class="hljs-keyword">auto</span>&gt; xa = <span class="hljs-built_in">X</span>&lt;<span class="hljs-type">int</span>&gt;();            <span class="hljs-comment">// ERROR: auto in template argument</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>::*pm2 = &amp;X&lt;<span class="hljs-type">int</span>&gt;::m;    <span class="hljs-comment">// ERROR: auto is part of the &quot;declarator&quot;</span><br></code></pre></td></tr></table></figure>

<p>至于为什么C++不支持上例中所有的情景，并没有什么技术上的原因，只不过是，C++委员会认为它所带来的额外实现成本以及潜在的滥用性超出了它的收益。</p>
<p>为了避免同时搞晕开发者和编译器，在C++11中古式的<code>auto</code>用法（作为一个存储类型指示符而存在）不再被允许（今后也一样）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> <span class="hljs-type">int</span> r = <span class="hljs-number">24</span>;        <span class="hljs-comment">// valid in C++03 but invalid in C++11</span><br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>auto</code>的古式用法（继承自C语言）一直是冗余的。大多数编译器通常可以将该用途与占位符区别开来（其实大可不必），以提供从旧C++代码到新C++代码的过渡。只不过，<code>auto</code>的古式用法在实践中非常罕见。</p>
<p><strong>返回类型的推导</strong><br>C++14新增了另一个推导<code>auto</code>占位符的情景，它出现于函数返回类型。例如：</p>
<p><code>auto f() &#123; return 42; &#125;</code></p>
<p>定义了一个返回类型为<code>int</code>的函数（<code>42</code>的类型）。它也可以使用尾缀返回类型语法来表示：</p>
<p><code>auto f() -&gt; auto &#123; return 42; &#125;</code></p>
<p>后者的第一个<code>auto</code>宣布了尾缀返回类型，第二个<code>auto</code>是一个推导的占位符类型。只不过，没有什么理由去支持更啰嗦的语法。</p>
<p>对lambda来说有着相同的默认机制存在：如果没有显式地指定返回类型，lambda表达式返回的类型会按照<code>auto</code>来推导：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> lm = [] (<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(x); &#125;;<br>        <span class="hljs-comment">// same as: [] (int x) -&gt; auto &#123; return f(x); &#125;;</span><br></code></pre></td></tr></table></figure>

<p>函数可以脱离定义而单独声明。对于返回类型需要推导的情景也是一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// forward declaration</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br></code></pre></td></tr></table></figure>

<p>但是，在这种情况下，前向声明的用法非常有限，因为在使用函数的任何位置，该定义都必须可见。也许令人惊讶的是，提供带有“已解决的”返回类型的前向声明是无效的。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">known</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">known</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;    <span class="hljs-comment">// ERROR: incompatible return type</span><br></code></pre></td></tr></table></figure>

<p>通常，由于风格上的偏爱，仅在将成员函数定义移到类定义外部时，前向声明推导的返回类型的函数才有作用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">// the definition will follow the class definition</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">S::f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br></code></pre></td></tr></table></figure>

<h4 id="可推导的非类型参数"><a href="#可推导的非类型参数" class="headerlink" title="可推导的非类型参数"></a>可推导的非类型参数</h4><p>在C++17之前，非类型参数只能通过指定的类型来声明。然而，这一类型可以是一个模板参数类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, T V&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>;<br>S&lt;<span class="hljs-type">int</span>, <span class="hljs-number">42</span>&gt;* ps;<br></code></pre></td></tr></table></figure>

<p>在本例中，需要指定非类型模板实参的类型——即指定<code>int</code>和42，这可能很乏味。因此，C++17增加了声明非类型模板参数的能力，这些参数的实际类型是从相应的模板实参推导出来的。它们如下所声明：</p>
<p><code>template&lt;auto V&gt; struct S;</code></p>
<p>于是就可以用<code>S&lt;42&gt;* ps;</code>。这里<code>S&lt;42&gt;</code>的类型<code>V</code>会被推导成<code>int</code>，这是因为<code>42</code>的类型是<code>int</code>。如果我们写作<code>S&lt;42u&gt;</code>，那么<code>V</code>的类型就会被推导成<code>unsigned int</code>(参考P294节15.10.1了解推导<code>auto</code>类型指示符的更多细节)。</p>
<p>请注意，对非类型模板参数类型的一般约束仍然有效。例如：<br><code>S&lt;3.14&gt;* pd;    // ERROR: floating-point nontype argument</code></p>
<p>具有这种可推导的非类型参数的模板定义通常还需要表示相应参数的实际类型。这可以通过<code>decltype</code>语法来完成（参考P298节15.10.2）。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> V&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Value</span> &#123;<br>  <span class="hljs-keyword">using</span> ArgType = <span class="hljs-keyword">decltype</span>(V);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>auto</code>非类型模板参数在参数化类成员的模板时也很有用。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PMClassT</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C, <span class="hljs-keyword">typename</span> M&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PMClassT</span>&lt;M C::*&gt; &#123;<br>    <span class="hljs-keyword">using</span> Type = C;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> PM&gt; <span class="hljs-keyword">using</span> PMClass = <span class="hljs-keyword">typename</span> PMClassT&lt;PM&gt;::Type;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> PMD&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CounterHandle</span> &#123;<br>  PMClass&lt;<span class="hljs-keyword">decltype</span>(PMD)&gt;&amp; c;<br>  <span class="hljs-built_in">CounterHandle</span>(PMClass&lt;<span class="hljs-keyword">decltype</span>(PMD)&gt;&amp; c) : <span class="hljs-built_in">c</span>(c) &#123;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">incr</span><span class="hljs-params">()</span> </span>&#123;<br>    ++(c.*PMD);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> &#123;<br>  <span class="hljs-type">int</span> i;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  S s&#123;<span class="hljs-number">41</span>&#125;;<br>  <span class="hljs-function">CounterHandle&lt;&amp;S::i&gt; <span class="hljs-title">h</span><span class="hljs-params">(s)</span></span>;<br>  h.<span class="hljs-built_in">incr</span>();    <span class="hljs-comment">// increases s.i</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里我们使用了一个辅助类模板<code>PMClassT</code>的一个偏特化（参考P347节16.4）来借由成员指针类型追溯到它的“父”类类型。有了<code>auto</code>模板参数，我们只需要指定成员指针常量<code>&amp;S::i</code>作为模板实参。在C++17之前，我们还得指定一个成员指针类型，如<code>OldCounterHandle&lt;int S::*, &amp;S::i&gt;</code>，看起来很笨重很冗余。</p>
<p>如你所愿，这一特性也可以为非类型参数包使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span>... VS&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Values</span> &#123;<br>&#125;;<br>Values&lt;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&gt; beginning;<br>Values&lt;<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-literal">nullptr</span>&gt; triplet;<br></code></pre></td></tr></table></figure>

<p><code>triplet</code>实例展示了每个非类型参数都可以被单独地推导。与多重可变声明场景（参考P303节15.10.4）不同的是，这里不需要每个推导都是相同的。</p>
<p>如果我们想强制每个非类型模板参数都相同，也是可以实现的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> V1, <span class="hljs-keyword">decltype</span>(V1)... VRest&gt; <span class="hljs-keyword">struct</span> <br><span class="hljs-title class_">HomogeneousValues</span> &#123;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>然而，此场景中模板实参列表不能为空。</p>
<p>可以参考P50节3.4中一个使用了<code>auto</code>作为模板参数类型的完整例子。</p>
<h3 id="15-10-2-用decltype表示表达式的类型"><a href="#15-10-2-用decltype表示表达式的类型" class="headerlink" title="15.10.2 用decltype表示表达式的类型"></a>15.10.2 用decltype表示表达式的类型</h3><p>尽管<code>auto</code>的使用可以避免书写变量类型，但想要使用该变量类型时就没那么容易了。<code>decltype</code>关键字解决了这一问题：它允许开发者表示某一个表达式或是声明的精准类型。然而，开发者应谨慎对待<code>decltype</code>产生的细微差别，具体取决于传递的参数是声明的实体还是一个表达式：</p>
<ul>
<li>如果<code>e</code>是某个实体（诸如变量、函数、枚举或是数据成员）或类成员访问的名称，<code>decltype(e)</code>产生的是该实体或表示的类成员的声明类型。因此，<code>decltype</code>可以用来检查变量的类型。当你想要完全匹配现有的声明的类型时，这很有用。例如，考虑下面的两个变量<code>y1</code>和<code>y2</code>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x = ...;<br><span class="hljs-keyword">auto</span> y1 = x + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">decltype</span>(x) y2 = x + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>依赖于<code>x</code>的初始化器，<code>y1</code>的类型与<code>x</code>可能相同、也可能不同：它依赖于<code>+</code>的行为。如果<code>x</code>被推导为一个<code>int</code>，那么<code>y1</code>也会是<code>int</code>。而如果<code>x</code>被推导为<code>char</code>，<code>y1</code>会是一个<code>int</code>，因为<code>char</code>和<code>1</code>(定义为<code>int</code>类型)相加得到的是<code>int</code>。对<code>y2</code>类型使用的<code>decltype(x)</code>保证了<code>y2</code>始终与<code>x</code>具有相同的类型。</p>
<ul>
<li>否则，如果e是任何其他表达式，则<code>decltype(e)</code>生成一个反映该表达式的类型和值类别的类型，如下所示：<ul>
<li>如果<code>e</code>是类型<code>T</code>的左值(lvalue)，<code>decltype(e)</code>产生的是<code>T&amp;</code>。</li>
<li>如果<code>e</code>是类型<code>T</code>的将亡值(xvalue)，<code>decltype(e)</code>产生的是<code>T&amp;&amp;</code>。</li>
<li>如果<code>e</code>是类型<code>T</code>的纯右值(prvalue)，<code>decltype(e)</code>产生的是<code>T</code>。</li>
</ul>
</li>
</ul>
<p>可以参考附录B关于值分类的详细描述。这些差别可以通过下面的例子来演示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(std::string&amp;&amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// check the type of s:</span><br>  std::is_lvalue_reference&lt;<span class="hljs-keyword">decltype</span>(s)&gt;::value;        <span class="hljs-comment">// false</span><br>  std::is_rvalue_reference&lt;<span class="hljs-keyword">decltype</span>(s)&gt;::value;        <span class="hljs-comment">// true (s as declared)</span><br>  std::is_same&lt;<span class="hljs-keyword">decltype</span>(s), std::string&amp;&gt;::value;    <span class="hljs-comment">// false</span><br>  std::is_same&lt;<span class="hljs-keyword">decltype</span>(s), std::string&amp;&amp;&gt;::value;    <span class="hljs-comment">// true</span><br>  <br>  <span class="hljs-comment">// check the value category of s used as expression:</span><br>  std::is_lvalue_reference&lt;<span class="hljs-keyword">decltype</span>((s))&gt;::value;    <span class="hljs-comment">// true (s is an lvalue)</span><br>  std::is_rvalue_reference&lt;<span class="hljs-keyword">decltype</span>((s))&gt;::value;    <span class="hljs-comment">// false</span><br>  std::is_same&lt;<span class="hljs-keyword">decltype</span>((s)), std::string&amp;&gt;::value;    <span class="hljs-comment">// true (T&amp; signals an lvalue)</span><br>  std::is_same&lt;<span class="hljs-keyword">decltype</span>((s)), std::string&amp;&amp;&gt;::value;    <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>前四个表达式中，<code>decltype</code>为变量<code>s</code>所使用：</p>
<p><code>decltype(s) // declared type of entity a designated by s</code></p>
<p>这意味着<code>decltype</code>产生的是<code>s</code>声明的类型——<code>std::string&amp;&amp;</code>。后四个表达式中，<code>decltype</code>的操作数不是一个名称（而是一个表达式<code>(s)</code>，名称在小括号中），此时，类型会反映出<code>(s)</code>的值类别：<br><code>decltype((s)) // check the value category of (s)</code></p>
<p>我们的表达式按名称指代一个变量，因此它是一个左值：根据上面的规则，这意味着<code>decltype(s)</code>是一个<code>std::string</code>的普通引用（即左值）。这是C++中为数不多的几个地方之一，用括号括起来的表达式除了影响运算符的关联性之外，还可以改变程序的含义。</p>
<p><code>decltype</code>会计算任意表达式<code>e</code>的类型这一事实在各个地方都可能有所帮助。具体而言，<code>decltype(e)</code>会保留表达式的充足信息，从而可以“完美地”描述返回表达式<code>e</code>本身的函数的返回类型：<code>decltype</code>会计算该表达式的类型，同时将表达式的值类别传播给函数的调用者。例如，考虑一个简单的转发函数<code>g()</code>，它返回被调用的<code>f()</code>的返回结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">??? <span class="hljs-built_in">f</span>();<br><br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">f</span>()) <span class="hljs-built_in">g</span>()<br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>g()</code>的返回类型依赖于<code>f()</code>的返回类型。如果<code>f()</code>返回的是一个<code>int&amp;</code>，<code>g()</code>的返回类型的计算会首先判断表达式<code>f()</code>是否具有类型<code>int</code>。该表达式是一个左值，因为<code>f()</code>返回的是左值引用，因此<code>g()</code>声明的返回类型就会是<code>int&amp;</code>。类似地，如果<code>f()</code>的返回类型是一个右值引用类型，<code>f()</code>的调用就是一个将亡值，而<code>decltype</code>会产生一个右值引用类型，它严格匹配<code>f()</code>返回的类型。本质上，这种形式的<code>decltype</code>拿到了任意表达式的主要特征（其类型和值类别），并以能够完美转发返回值的方式在类型系统中对其进行编码。</p>
<p><code>decltype</code>在<code>auto</code>推导不足以产生值的情景中也十分有用。例如，假设我们有一个变量<code>pos</code>，它是某种未知的迭代器类型，我们希望创建一个变量<code>element</code>，该<code>element</code>可以通过<code>pos</code>解引用来获取。写成：</p>
<p><code>auto element = *pos;</code></p>
<p>然而，这始终都会对元素进行一次拷贝。如果我们写成<code>auto&amp; element = *pos;</code>，那我们拿到的始终是该元素的引用，但如果迭代器的<code>operator*</code>返回的是一个值类型，程序就会出错。为了解决该问题，我们可以使用<code>decltype</code>来保留迭代器<code>operator*</code>返回结果的值或引用性：</p>
<p><code>decltype(*pos) element = *pos;</code></p>
<p>当迭代器提供的是引用时，就会产生一个引用类型，否则，就会进行值拷贝。它的主要缺陷在于它需要将初始化表达式书写两次：第一次在<code>decltype</code>中（这里不会进行计算），第二次在实际的初始化器中。C++14引入了<code>decltype(auto)</code>语法来解决这一问题，我们马上就会讨论到。</p>
<h3 id="15-10-3-decltype-auto"><a href="#15-10-3-decltype-auto" class="headerlink" title="15.10.3 decltype(auto)"></a>15.10.3 decltype(auto)</h3><p>C++14增加了一个组合使用<code>auto</code>和<code>decltype</code>的特性：<code>decltype(auto)</code>。正如<code>auto</code>这一类型指示符一样，它是一个类型占位符，并且变量的类型、返回类型或模板实参的类型由关联的表达式类型（初始化器、返回值或模板实参）确定。然而，与<code>auto</code>单单使用模板实参推导法则来确定类型有所不同，实际的类型是通过对表达式直接应用<code>decltype</code>语法来确定的。举个例子来说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;        <span class="hljs-comment">// i has type int</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span>&amp; ref = i;    <span class="hljs-comment">// ref hastype int const&amp; and refers to i </span><br><br><span class="hljs-keyword">auto</span> x = ref;    <span class="hljs-comment">// x has type int and is a new independent object</span><br><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) y = ref;    <span class="hljs-comment">// y has type int const&amp; and also refers to i</span><br></code></pre></td></tr></table></figure>

<p><code>y</code>的类型借由应用于初始化表达式的<code>decltype</code>获取，这里<code>ref</code>是一个<code>int const&amp;</code>。相对地，<code>auto</code>类型推导法则产生的则是类型<code>int</code>。</p>
<p>另一个例子展示了索引<code>std::vector</code>（产生一个左值）时的区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123; <span class="hljs-number">42</span> &#125;;<br><span class="hljs-keyword">auto</span> x = v[<span class="hljs-number">0</span>];        <span class="hljs-comment">// x denotes a new object of type int</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) y = v[<span class="hljs-number">0</span>];    <span class="hljs-comment">// y is a reference (type int&amp;)</span><br></code></pre></td></tr></table></figure>

<p>这就干净利落地解决了前面示例的问题：</p>
<p><code>decltype(*pos) element = *pos;</code></p>
<p>我们可以重写为：</p>
<p><code>decltype(auto) element = *pos;</code></p>
<p>对于返回类型来说它也常常十分便利。考虑下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapt</span><br>&#123;<br>  C container;<br>  ...<br>  <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-keyword">operator</span>[] (std::<span class="hljs-type">size_t</span> idx) &#123;<br>    <span class="hljs-keyword">return</span> container[idx];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果<code>container[idx]</code>产生的是左值，我们希望传递左值给调用者（调用者应该希望拿到地址来修改它）：此时需要一个左值引用类型，<code>decltype(auto)</code>可以解析出来。如果产生的是一个纯右值，那么引用类型会导致引用悬挂，但是幸运的是，在这种情景下，<code>decltype(auto)</code>会产生一个对象类型（而非引用类型）。</p>
<p>与<code>auto</code>不一样的是，<code>decltype(auto)</code>不允许指示符或声明操作符去修改它的类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)* p = (<span class="hljs-type">void</span>*)<span class="hljs-literal">nullptr</span>;    <span class="hljs-comment">// invalid</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> N = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-type">const</span> NN = N*N;        <span class="hljs-comment">// invalid</span><br></code></pre></td></tr></table></figure>

<p>同时也请注意初始化器中的小括号可能很关键（因为它们对<code>decltype</code>结构来说本身很关键，如P91节6.1所讨论）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) z = x;    <span class="hljs-comment">// object of type int</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) r = (x);    <span class="hljs-comment">// reference of type int&amp;</span><br></code></pre></td></tr></table></figure>

<p>这尤其意味着括号可能对return语句的有效性产生严重影响：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>...<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> r = <span class="hljs-built_in">g</span>();<br>  <span class="hljs-keyword">return</span> (r);        <span class="hljs-comment">// run-time ERROR: returns reference to temporary</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>自C++17起，<code>decltype(auto)</code>还可以对可推导的非类型参数使用（见P296节15.10.1）。下面的例子进行了演示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) Val&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span><br>&#123;<br>  ...<br>&#125;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> c = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> v = <span class="hljs-number">42</span>;<br>S&lt;c&gt; sc;    <span class="hljs-comment">// #1 produces S&lt;42&gt;</span><br>S&lt;(v)&gt; sv;    <span class="hljs-comment">// #2 produces S&lt;(int&amp;)v&gt;</span><br></code></pre></td></tr></table></figure>

<p>在#1处，<code>c</code>没有小括号包裹，推导出的类型就是<code>c</code>类型本身（即<code>int</code>）。因为<code>c</code>是<code>42</code>的常量表达式，它就等价于<code>S&lt;42&gt;</code>。在#2处，小括号的包裹导致<code>decltype(auto)</code>会推导出一个引用类型<code>int&amp;</code>，它可以绑定到全局变量<code>v</code>（类型为<code>int</code>）。因此，这样声明的类模板会依赖于<code>v</code>的引用，<code>v</code>值的改变都会影响类<code>S</code>的行为（参考P167节11.4了解更多细节）。（<code>S&lt;v&gt;</code>如果没有小括号的话，会产生一个错误，因为<code>decltype(v)</code>是一个<code>int</code>，此时期望的是一个类型为<code>int</code>的常量实参值。然而，<code>v</code>并不是一个常量<code>int</code>值。）</p>
<p>请注意，两种情况的性质有所不同。因此，我们认为此类非类型模板参数可能会引起意外，并且预计不会被广泛使用。</p>
<p>最后，给出关于在函数模板中使用推导的非类型参数的注解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> N&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> &#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> N&gt; <span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(S&lt;N&gt; p)</span></span>;<br>S&lt;<span class="hljs-number">42</span>&gt; x;<br><span class="hljs-type">int</span> r = <span class="hljs-built_in">f</span>(x);<br></code></pre></td></tr></table></figure>

<p>本例中，函数模板<code>f&lt;&gt;()</code>的参数<code>N</code>的类型由<code>S</code>的非类型参数类型推导。这是可行的，因为形如<code>X&lt;...&gt;</code>的名称(<code>X</code>是一个类模板)是一个可推导上下文。</p>
<p>然而，也有一些模式是无法被推导的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> V&gt; <span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">decltype</span>(V) p)</span></span>;<br><span class="hljs-type">int</span> r1 = <span class="hljs-built_in">deduce</span>&lt;<span class="hljs-number">42</span>&gt;(<span class="hljs-number">42</span>);    <span class="hljs-comment">// OK</span><br><span class="hljs-type">int</span> r2 = <span class="hljs-built_in">deduce</span>(<span class="hljs-number">42</span>);        <span class="hljs-comment">// ERROR: decltype(V) is a nondeduced context</span><br></code></pre></td></tr></table></figure>

<p>本例中，<code>decltype(V)</code>是一个不可推导上下文：并没有匹配实参<code>42</code>的独一无二的<code>V</code>值（例如，<code>decltype(7)</code>与<code>decltype(42)</code>产生相同的类型）。因此，非类型模板参数必须被显式地指定，才能使函数调用变得可行。</p>
<h3 id="15-10-4-auto推导的特殊情况"><a href="#15-10-4-auto推导的特殊情况" class="headerlink" title="15.10.4 auto推导的特殊情况"></a>15.10.4 auto推导的特殊情况</h3><p>除却简单的<code>auto</code>推导规则，还存在着一些特殊的情况。第一种情况发生在变量的初始化器是一个初始化列表的场景。对应的函数调用推导必定会失败，因为我们无法通过初始化列表实参来推导出一个模板参数的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deduceT</span><span class="hljs-params">(T)</span></span>;<br>...<br><span class="hljs-built_in">deduceT</span>(&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;);    <span class="hljs-comment">// ERROR</span><br><span class="hljs-built_in">deduceT</span>(&#123;<span class="hljs-number">1</span>&#125;);        <span class="hljs-comment">// ERROR</span><br></code></pre></td></tr></table></figure>

<p>然而，如果我们的函数有着如下更特定的参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> deduceInitList&lt;std::initializer_list&lt;T&gt;);<br>...<br><span class="hljs-built_in">deduceInitList</span>(&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;);    <span class="hljs-comment">// OK: T deduced as int</span><br></code></pre></td></tr></table></figure>

<p>那么推导就会成功。使用初始化列表来拷贝初始化（即，使用&#x3D;初始化）一个<code>auto</code>变量就定义而言，可以写成更加具体的参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> primes = &#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;;    <span class="hljs-comment">// primes is std::initializer_list&lt;int&gt;</span><br><span class="hljs-built_in">deduceT</span>(primes);                <span class="hljs-comment">// T deduced as std::initialize_list&lt;int&gt;</span><br></code></pre></td></tr></table></figure>

<p>在C++17之前，<code>auto</code>变量与之对应的直接初始化（即，不使用&#x3D;）也可以像这样处理，但是在C++17中对此进行了调整，以更好地满足大部分开发者所期望的行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> oops &#123; <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span> &#125;; <span class="hljs-comment">// ERROR in C++17</span><br><span class="hljs-keyword">auto</span> val &#123;<span class="hljs-number">2</span>&#125;;            <span class="hljs-comment">// OK: val has type int in C++17</span><br></code></pre></td></tr></table></figure>

<p>在C++17之前，两种初始化都是合法的，<code>oops</code>和<code>val</code>都会由类型<code>initializer_list&lt;int&gt;</code>进行初始化。</p>
<p>有趣的是，为拥有推导占位符类型作为返回类型的函数返回一个花括号初始化列表是不合法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">subtleError</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;; <span class="hljs-comment">// ERROR</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是因为函数作用域中的初始化列表是一个对象，它指向更底层的数组对象（每个元素值在列表中指定），在函数返回时它就过期了。允许这一语法通行就相当于认可悬垂引用的有效性。</p>
<p>另一种特殊的场景发生在多个变量使用同一个<code>auto</code>进行声明的地方，如下所示：</p>
<p><code>auto first = container.begin(), last = container.end();</code></p>
<p>此处，推导会为每个声明独立进行。换句话说，这里会为<code>first</code>引入模板类型参数<code>T1</code>，为<code>last</code>引入另一个模板类型参数<code>T2</code>。当且仅当两个推导都成功，且<code>T1</code>和<code>T2</code>具有相同的推导类型时，这些声明才是合法的。这会滋生一些有趣的案例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">auto</span> *cp = &amp;c, d = c;    <span class="hljs-comment">// OK</span><br><span class="hljs-keyword">auto</span> e = c, f = c+<span class="hljs-number">1</span>;    <span class="hljs-comment">// ERROR: deduction mismatch char vs int</span><br></code></pre></td></tr></table></figure>

<p>这里，共享的<code>auto</code>声明了两对变量。<code>cp</code>和<code>d</code>推导出同样的类型<code>char</code>，因此代码有效。然而<code>f</code>和<code>e</code>的声明却因为计算<code>c+1</code>时<code>char</code>和<code>int</code>的型别提升，导致推导结果不一致而最终产生错误。</p>
<p>推导返回类型的占位符也可能会出现某种平行的特殊情况。考虑下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">bool</span> b)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (b) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42.0</span>;    <span class="hljs-comment">// deduces return type double</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// ERROR: deduction conflict</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>本例中，每个返回语句都会独立进行推导，但是二者推导的结果却不一致，因此程序非法。如果返回表达式递归地调用函数，那么也不会发生推导，程序也是非法的，除非前面的推导已经确定了返回类型。这就意味着下面的代码是非法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> n * <span class="hljs-built_in">f</span>(n<span class="hljs-number">-1</span>);    <span class="hljs-comment">// ERROR: type of f(n-1) unknown</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是下面的这段等效的代码却是合法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            <span class="hljs-comment">// return type is deduced to be int</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> n*<span class="hljs-built_in">f</span>(n<span class="hljs-number">-1</span>);    <span class="hljs-comment">// OK: type of f(n-1) is int and so is type of n*f(n-1)</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>推导的返回类型还有另一种特殊的情景，即推导的变量类型或推导的非类型参数类型中没有对应项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123; &#125;            <span class="hljs-comment">// OK: return type is void</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-comment">// OK: return type is void</span><br></code></pre></td></tr></table></figure>

<p>但是<code>f1()</code>和<code>f2()</code>都是合法的，并且推导出一个<code>void</code>返回类型。然而，如果返回类型的样式不匹配<code>void</code>，比如这样的情景就是非法的：</p>
<p><code>auto* f3() &#123; &#125;    // ERROR: auto* cannot deduce as void</code></p>
<p>如你所愿，使用了推导返回类型的任何函数模板都需要该模板的即时实例化以确定返回类型。然而，出现SFINAE（参考P129节8.4和P284节15.7）时会产生一个令人惊讶的后果。考虑下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// deduce/resulttypetmpl.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">addA</span><span class="hljs-params">(T t, U u)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t+u)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> t + u;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addA</span><span class="hljs-params">(...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">addB</span><span class="hljs-params">(T t, U u)</span> -&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)</span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> t + u;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addB</span><span class="hljs-params">(...)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span>&#123;<br>&#125;;<br><br><span class="hljs-keyword">using</span> AddResultA = <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">addA</span>(<span class="hljs-built_in">X</span>(), <span class="hljs-built_in">X</span>()));    <span class="hljs-comment">// OK: AddResultA is void</span><br><span class="hljs-keyword">using</span> AddResultB = <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">addB</span>(<span class="hljs-built_in">X</span>(), <span class="hljs-built_in">X</span>()));    <span class="hljs-comment">// ERROR: instantiation of addB&lt;X&gt;</span><br>                                                <span class="hljs-comment">//            is ill-formed</span><br></code></pre></td></tr></table></figure>

<p>这里相比<code>decltype(t+u)</code>，<code>addB()</code>所使用的<code>decltype(auto)</code>会在重载解析期间引起一个错误：<code>addB()</code>模板函数体必须被完全实例化以确定其返回类型。调用<code>addB()</code>的实例化体并不在即时上下文中（参考P285节15.7.1），因此不会被SFINAE过滤，而是产生一个错误。因此一定要牢记：推导返回类型绝不仅仅是一个复杂的显式返回类型的缩写，它们在使用上要非常小心（即，要理解它们不应该在依赖于SFINAE属性的其他函数模板签名中被调用）。</p>
<h3 id="15-10-5-结构化绑定"><a href="#15-10-5-结构化绑定" class="headerlink" title="15.10.5 结构化绑定"></a>15.10.5 结构化绑定</h3><p>C++17增加了一种新的特性，名为结构化绑定(structured bindings)。它常常使用一个小例子来介绍：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MaybeInt</span> &#123; <span class="hljs-type">bool</span> valid; <span class="hljs-type">int</span> value; &#125;<br><span class="hljs-function">MaybeInt <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">auto</span> <span class="hljs-type">const</span>&amp;&amp; [b, N] = <span class="hljs-built_in">g</span>();    <span class="hljs-comment">// binds b and N to the members of the result of g()</span><br></code></pre></td></tr></table></figure>

<p>调用<code>g()</code>产生了一个值（本例中时一个简单的聚合类类型MaybeInt），它可以被分解成<br>“元素”（即<code>MaybeInt</code>的数据成员）。该调用产生的值就好像有一个标识符中括号列表<code>[b, N]</code>被不同的变量名所替换。假设该名称为<code>e</code>，那么初始化就等同于：</p>
<p><code>auto const&amp;&amp; e = g();</code></p>
<p>然后中括号中的每个标识符会绑定到<code>e</code>的对应元素上。因此，你可以认为<code>[b, N]</code>就是<code>e</code>中标识符的每个名字（我们会在下面讨论绑定的细节）。</p>
<p>语法上，结构化绑定必须总是有一个<code>auto</code>类型，它可以使用<code>const</code>或<code>volatile</code>限定符以及<code>&amp;</code>和<code>&amp;&amp;</code>声明运算符来扩展（但是不能用<code>*</code>指针声明符或是其他结构）。它的后面跟随着一个中括号列表，其中至少得有一个标识符（让人想起lambda表达式的捕获列表）。后面必须要有一个初始化器。</p>
<p>三种不同类别的实体可以初始化一个结构化绑定：</p>
<ol>
<li>第一种是简单的类类型，其中所有的非静态数据成员都是public权限（如上例）。为了应用这一场景，所有的非静态数据成员都必须是public权限（要么全部直接属于类本身，要么全部属于相同的、明确的公共基类；不得涉及匿名联合体）。在这种情况下，带括号的标识符的数量必须等于成员的数量，并且在结构化绑定范围内使用这些标识符之一就等于使用由<code>e</code>表示的对象的相应成员（具有所有相关属性；例如，如果相应的成员是位字段，则无法获取其地址）。</li>
<li>第二种是数组。考虑下例：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">double</span> pt[<span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">auto</span>&amp; [x, y, z] = pt;<br>  x = <span class="hljs-number">3.0</span>; y = <span class="hljs-number">4.0</span>; z = <span class="hljs-number">0.0</span>;<br>  <span class="hljs-built_in">plot</span>(pt);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>毫不奇怪，中括号中的初始化器只是未命名数组变量的相应元素的简写形式。数组元素的数量必须等于括号内的初始化器的数量。</p>
<p>还有另一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> -&gt; <span class="hljs-title">int</span><span class="hljs-params">(&amp;)</span>[2]</span>;    <span class="hljs-comment">// f() returns reference to int array</span><br><span class="hljs-keyword">auto</span> [ x, y ] = <span class="hljs-built_in">f</span>();    <span class="hljs-comment">// #1</span><br><span class="hljs-keyword">auto</span>&amp; [ r, s ] = <span class="hljs-built_in">f</span>();    <span class="hljs-comment">// #2</span><br></code></pre></td></tr></table></figure>

<p>行#1是特别的：通常来说，上面描述的实体<code>e</code>应该按照下面的形式来推导：<br><code>auto e = f();</code></p>
<p>然而，这种推导会退化为指向数组的指针，但是数组的结构化绑定却不会如此。反之，<code>e</code>被推导为一个数组类型的变量，类型与初始化器一致。此后该数组从初始化器中逐个元素拷贝：对于内置数组来说这是个不太寻常的概念。最后，<code>x</code>和<code>y</code>分别成为了表达式<code>e[0]</code>和<code>e[1]</code>的别名。</p>
<p>而行#2处则没有引入数组拷贝，它也遵循<code>auto</code>的法则。因此假想的<code>e</code>按照如下方式声明：<br><code>auto&amp; e = f();</code></p>
<p>它会得到一个数组引用，<code>x</code>和<code>y</code>再次分别成为表达式<code>e[0]</code>和<code>e[1]</code>的别名（调用<code>f()</code>所返回数组的成员左值引用）。</p>
<ol>
<li>最后，第三个选项是允许类似<code>std::tuple</code>的类拥有通过模板基础协议<code>get&lt;&gt;</code>分解元素的能力。这里我们把<code>E</code>视为表达式<code>(e)</code>的类型（<code>e</code>的概念同上）。由于<code>E</code>是表达式的类型，它永远不会是一个引用类型。如果表达式<code>std::tuple_size&lt;E&gt;::value</code>是一个合法的整型常量表达式，它必须与中括号标识符的数量相等（并且协议会乱入，优先于选项一，但不优先于数组的选项二）。让我们用n0，n1，n2等表示括号中的标识符。如果<code>e</code>具有名为<code>get</code>的任何成员，则行为就像将这些标识符按如下声明：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::tuple_element&lt;i, E&gt;::type&amp; ni = e.<span class="hljs-built_in">get</span>&lt;i&gt;();<br></code></pre></td></tr></table></figure>

<p>如果<code>e</code>被推导为拥有引用类型，或是：</p>
<p><code>std::tuple_element&lt;i, E&gt;::type&amp;&amp; ni = e.get&lt;i&gt;();</code></p>
<p>如果<code>e</code>没有成员<code>get</code>，则相应的声明会变成：</p>
<p><code>std::tuple_element&lt;i, E&gt;::type&amp; ni = get&lt;i&gt;(e);</code></p>
<p>或是<br><code>std::tuple_element&lt;i, E&gt;::type&amp;&amp; ni = get&lt;i&gt;(e);</code></p>
<p><code>get</code>只会在关联的类和命名空间中查找。（在所有情景中，<code>get</code>都被假设为一个模板，因此跟随的<code>&lt;</code>是一个尖括号（而非小于号）。）<code>std::tuple</code>，<code>std::pair</code>和<code>std::array</code>模板都实现了这一协议，下面的代码因而合法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><br>std::tuple&lt;<span class="hljs-type">bool</span>, <span class="hljs-type">int</span>&gt; bi&#123;<span class="hljs-literal">true</span>, <span class="hljs-number">42</span>&#125;;<br><span class="hljs-keyword">auto</span> [b, i] = bi;<br><span class="hljs-type">int</span> r = i;    <span class="hljs-comment">// initializes r to 42</span><br></code></pre></td></tr></table></figure>

<p>然而，对于添加<code>std::tuple_size</code>，<code>std::tuple_element</code>的特化并不困难，函数模板或是成员函数模板<code>get&lt;&gt;()</code>会让这一机制对任何类或枚举类型都能正常工作。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">M</span> &#123;&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">std</span>::tuple_size&lt;M&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">const</span> value = <span class="hljs-number">2</span>;    <span class="hljs-comment">// map M to a pair of values</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">std</span>::tuple_element&lt;<span class="hljs-number">0</span>, M&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-type">int</span>;            <span class="hljs-comment">// the first value will have type int</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">std</span>::tuple_element&lt;<span class="hljs-number">1</span>, M&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-type">double</span>;        <span class="hljs-comment">// the second value will have type double</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-keyword">auto</span> <span class="hljs-title">get</span><span class="hljs-params">(M)</span></span>;<br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">auto</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(M) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">auto</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(M) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">7.0</span>; &#125;<br><br><span class="hljs-keyword">auto</span> [i, d] = <span class="hljs-built_in">M</span>();    <span class="hljs-comment">// as if: int&amp;&amp; i = 42; double&amp;&amp; d = 7.0;</span><br></code></pre></td></tr></table></figure>

<p>注意，你只需要包含<code>&lt;utility&gt;</code>头文件来使用两个类元组（tuple-like）的访问协助函数<code>std::tuple_size&lt;&gt;</code>和<code>std::tuple_element&lt;&gt;</code>。</p>
<p>此外，还要注意上述的第三种情况（使用类元组协议）会执行一个真实的中括号初始化并绑定到实际的引用变量上；它们不是另一个表达式的别名（与第一、二类的类类型和数组的情况有所不同）。这很有趣，因为该引用初始化可能出错；例如，它可能会抛出异常，而异常如今是不可避免的。然而，C++标准化委员会也曾就不要关联标识符与初始化的引用进行过讨论，但是最后还是对每个标识符使用了<code>get&lt;&gt;()</code>表达式。这就使得结构化绑定在使用时，“第一个”值必须在“第二个”值被访问前进行测试（例如，基于<code>std::optional</code>）。</p>
<blockquote>
<p>译者注： 这一大段不太会翻译，因为我本身也不了解结构化绑定这一特性。</p>
</blockquote>
<h3 id="15-10-6-泛型lambda"><a href="#15-10-6-泛型lambda" class="headerlink" title="15.10.6 泛型lambda"></a>15.10.6 泛型lambda</h3><p>lambda一经问世，很快就成了C++11中最流行的特性，一部分原因在于它们显著地简化了C++标准库和许多其他流行的C++库中仿函数结构(functional constructs)的使用，而这归功于lambda简洁的语法。然而，在模板中lambda变得非常繁琐，这是因为它需要拼出参数和返回类型。例如，考虑这样一个函数模板，它在一个序列中寻找第一个负数值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter&gt;</span><br><span class="hljs-function">Iter <span class="hljs-title">findNegative</span><span class="hljs-params">(Iter first, Iter last)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">find_if</span>(first, last, [](<span class="hljs-keyword">typename</span> std::iterator_traits&lt;Iter&gt;::value_type value) &#123; <span class="hljs-keyword">return</span> value &lt; <span class="hljs-number">0</span>;&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这一函数模板中，lambda最复杂的一部分就是它的参数类型。C++14引入了泛型lambda的概念，使得一个或多个参数类型可以使用<code>auto</code>来推导型别，而不用具体的写出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter&gt;</span><br><span class="hljs-function">Iter <span class="hljs-title">findNegative</span><span class="hljs-params">(Iter first, Iter last)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">find_if</span>(first, last, [] (<span class="hljs-keyword">auto</span> value) &#123; <span class="hljs-keyword">return</span> value &lt; <span class="hljs-number">0</span>; &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对lambda参数<code>auto</code>的处理与使用初始化器的变量类型的<code>auto</code>处理相似：它同样由一个引入的模板类型参数<code>T</code>来取缔。然而，与变量场景不同的是，推导不会立刻执行，这是因为在lambda被创建的时候实参还是未知的。反之，lambda本身是个泛型，引入的模板类型参数被添加到了它的模板参数列表中。因此，上面例子的lambda可以使用任何实参类型来调用，只要该实参类型支持<code>&lt; 0</code>操作符且其结果可以被转换为<code>bool</code>即可。举个例子，这一lambda可以被<code>int</code>或是<code>float</code>值来调用。</p>
<p>为了理解lambda泛型的意义，我们先考虑一个非泛型lambda的实现模型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[] (<span class="hljs-type">int</span> i) &#123;<br>  <span class="hljs-keyword">return</span> i &lt; <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>C++编译器将该表达式翻译成一个新发明的lambda特定类类型的实例。这一实例被称作闭包(closure)或闭包对象(closure object)，类类型被称作闭包类型(closure type)。闭包类型有一个函数调用操作符，因此该闭包就是一个函数对象。对于这一lambda来说，闭包类型可能类似下面的类定义（为了方便与简洁，我们省略了函数到函数指针值的转换）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeCompilerSpecificNameX</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SomeCompilerSpecificNameX</span>();    <span class="hljs-comment">// only callable by the compiler</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> i &lt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果你检查lambda的型别分类，<code>std::is_class&lt;&gt;</code>始终会得到<code>true</code>值（参考P705节D.2.1）。</p>
<p>因此，lambda表达式生成的是该类（闭包类型）的对象。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">foo</span>(..., [] (<span class="hljs-type">int</span> i) &#123; <span class="hljs-keyword">return</span> i &lt; <span class="hljs-number">0</span>; &#125;);<br></code></pre></td></tr></table></figure>

<p>创建了一个编译器内部特定的类<code>SomeCompilerSpecificNameX</code>的闭包对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">foo</span>(..., SomeCompilerSpecificNameX&#123;&#125;);    <span class="hljs-comment">// pass an object of the closure type</span><br></code></pre></td></tr></table></figure>

<p>如果lambda想要捕获局部变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x, y;<br>...<br>[x, y](<span class="hljs-type">int</span> i) &#123;<br>  <span class="hljs-keyword">return</span> i &gt; x &amp;&amp; i &lt; y;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这些捕获将被设计成相关类类型的初始化成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeCompilerSpecificNameY</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>      <span class="hljs-type">int</span> _x, _y;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SomeCompilerSpecificNameY</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) <span class="hljs-comment">// only callable by the compiler</span><br>    : _x(x), _y(y) &#123;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> i &gt; _x &amp;&amp; i &lt; _y;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>对泛型lambda来说，函数调用操作符是一个成员函数模板，所以我们简单的泛型lambda:</p>
<p><code>[] (auto i) &#123; return i &lt; 0; &#125;</code></p>
<p>会被转移成下面的类（同样地，忽略了函数转换，在泛型lambda场景中它是一个转换函数模板）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomCompilerSecificNameZ</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SomeCompilerSpecificNameZ</span>();    <span class="hljs-comment">// only callable by compiler</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(T i)</span> <span class="hljs-type">const</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> i &lt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>成员函数模板会在闭包被调用时进行实例化，而不是在lambda表达式出现的地方。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Ts&gt; <span class="hljs-type">void</span> <span class="hljs-title">invoke</span> <span class="hljs-params">(F f, Ts... ps)</span> </span>&#123;<br>  <span class="hljs-built_in">f</span>(ps...);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">invoke</span>([](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y) &#123;<br>    std::cout &lt;&lt; x+y &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>  &#125;, <span class="hljs-number">21</span>, <span class="hljs-number">21</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里，lambda表达式出现于<code>main()</code>中，所以这里会创建一个关联的闭包。然而，闭包的调用操作符并没有在此处实例化。反之，<code>invoke()</code>函数模板使用了闭包类型作为第一个参数类型，<code>int</code>作为第二和第三个参数类型进行了实例化。<code>invoke</code>的实例化被称为闭包的拷贝（依然是一个与原始lambda关联的闭包），并且它实例化了<code>operator()</code>闭包模板来满足实例化调用<code>f(ps...)</code>。</p>
<h2 id="15-11-别名模板"><a href="#15-11-别名模板" class="headerlink" title="15.11 别名模板"></a>15.11 别名模板</h2><p>别名模板的推导是“透明的“。这意味着当别名模板与模板实参一起出现时，别名的定义（即&#x3D;右侧的类型）就会被实参所替换，产生的结果正是为推导所用。例如，模板实参推导对下面的三个调用都会成功：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// deduce/aliastemplate.cpp</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Cont&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> DequeStack = Stack&lt;T, std::deque&lt;T&gt;&gt;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Cont&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(Stack&lt;T, Cont&gt;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(DequeStack&lt;T&gt;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">(Stack&lt;T, std::deque&lt;T&gt;)</span></span>;    <span class="hljs-comment">// equivalent to f2</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(DequeStack&lt;<span class="hljs-type">int</span>&gt; intStack)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">f1</span>(intStack);    <span class="hljs-comment">// OK: T deduced to int, Cont deduced to std::deque&lt;int&gt;</span><br>  <span class="hljs-built_in">f2</span>(intStack);    <span class="hljs-comment">// OK: T deduced to int</span><br>  <span class="hljs-built_in">f3</span>(intStack);    <span class="hljs-comment">// OK: T deduced to int</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在第一个调用中(<code>f1()</code>)，<code>intStaack</code>对别名模板<code>DequeStack</code>的使用对推导没有作用：指定类型<code>DequeStack&lt;int&gt;</code>被视为类型<code>Stack&lt;int, std::deque&lt;int&gt;&gt;</code>。</p>
<p>第二个和第三个调用推导行为一直，因为<code>f2()</code>的<code>DequeStack&lt;T&gt;</code>和<code>f3()</code>的<code>Stack&lt;T, std::deque&lt;T&gt;&gt;</code>是等价的。对模板实参推导的目标来说，模板别名是透明的：它们可以用来区分和简化代码，但是对于推导如何进行确不会产生效果。</p>
<p>请注意，这是因为别名模板不能特化（参考章节16了解模板特化这一话题的更多细节）才行得通。假设下面的代码可行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">using</span> A = T;<br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">using</span> A&lt;<span class="hljs-type">int</span>&gt; = <span class="hljs-type">void</span>;        <span class="hljs-comment">// ERROR, but suppose it were possible...</span><br></code></pre></td></tr></table></figure>

<p>此时，我们无法将<code>A&lt;T&gt;</code>与<code>void</code>类型匹配，并得出结论<code>T</code>必须为<code>void</code>，因为<code>A&lt;int&gt;</code>和<code>A&lt;void&gt;</code>都等价于<code>void</code>。不可能做到这一点的事实保证，别名的每次使用都可以根据其定义进行一般性的扩展，从而使别名可以进行透明地推导。</p>
<h2 id="15-12-类模板实参推导"><a href="#15-12-类模板实参推导" class="headerlink" title="15.12 类模板实参推导"></a>15.12 类模板实参推导</h2><p>C++17引入了一种新的推导：从变量声明的初始化器或函数符号型别转换来推导类模板参数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> T3 = T2&gt;<br><span class="hljs-keyword">class</span> C<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// constructor for 0, 1, 2, or 3 arguments:</span><br>  <span class="hljs-built_in">C</span>(T1 x = T1&#123;&#125;, T2 y = T2&#123;&#125;, T3 z = T3&#123;&#125;);<br>  ...<br>&#125;;<br><span class="hljs-function">C <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">22</span>, <span class="hljs-number">44.3</span>, <span class="hljs-string">&quot;hi&quot;</span>)</span></span>;    <span class="hljs-comment">// OK in C++17: T1 is int, T2 is double, T3 is char const*</span><br><span class="hljs-function">C <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">22</span>, <span class="hljs-number">44.3</span>)</span></span>;            <span class="hljs-comment">// OK in C++17: T1 is int, T2 and T3 are double</span><br><span class="hljs-function">C <span class="hljs-title">c3</span><span class="hljs-params">(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;guy&quot;</span>)</span></span>;        <span class="hljs-comment">// OK in C++17: T1, T2, and T3 are char const*</span><br>C c4;                    <span class="hljs-comment">// ERROR: T1 and T2 are undefined</span><br><span class="hljs-function">C <span class="hljs-title">c5</span><span class="hljs-params">(<span class="hljs-string">&quot;hi&quot;</span>)</span></span>;                <span class="hljs-comment">// ERROR: T2 is undefined</span><br></code></pre></td></tr></table></figure>

<p>请注意，所有的参数都必须由推导过程或默认实参来确定。显式地指定一部分参数并推导剩下的参数是行不通的。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">C&lt;string&gt; <span class="hljs-title">c10</span><span class="hljs-params">(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;my&quot;</span>, <span class="hljs-number">42</span>)</span></span>;    <span class="hljs-comment">// ERROR: only T1 explicitly specified, T2 not deduced</span><br>C&lt;&gt; <span class="hljs-built_in">c11</span>(<span class="hljs-number">22</span>, <span class="hljs-number">44.3</span>, <span class="hljs-number">42</span>);            <span class="hljs-comment">// ERROR: neither T1 nor T2 explicitly specified</span><br><span class="hljs-function">C&lt;string, string&gt; <span class="hljs-title">c12</span><span class="hljs-params">(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;my&quot;</span>)</span></span>;    <span class="hljs-comment">// OK: T1 and T2 are deduced, T3 has default</span><br></code></pre></td></tr></table></figure>

<h3 id="15-12-1-推导指引"><a href="#15-12-1-推导指引" class="headerlink" title="15.12.1 推导指引"></a>15.12.1 推导指引</h3><p>考虑P288节15.8.2的一个示例，我们施加一些小变化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    T a;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">S</span>(T b) : <span class="hljs-built_in">a</span>(b) &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-title">S</span><span class="hljs-params">(T)</span> -&gt; S&lt;T&gt;</span>;    <span class="hljs-comment">// deduction guide</span><br><br>S x&#123;<span class="hljs-number">12</span>&#125;;        <span class="hljs-comment">// OK since C++17, same as S&lt;int&gt; x&#123;12&#125;;</span><br><span class="hljs-function">S <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-number">12</span>)</span></span>;        <span class="hljs-comment">// OK since C++17, same as S&lt;int&gt; y(12);</span><br><span class="hljs-keyword">auto</span> z = S&#123;<span class="hljs-number">12</span>&#125;;    <span class="hljs-comment">// OK since C++17, same as: auto z = S&lt;int&gt;&#123;12&#125;;</span><br></code></pre></td></tr></table></figure>

<p>新增的这种模板风格的结构叫做推导指引。它看起来有点像函数模板，但是它与函数模板在语法上有很多不同：</p>
<ul>
<li>看起来像尾缀返回类型的部分不能写成一个传统的返回类型。我们称这个指定的类型（本例中为<code>S&lt;T&gt;</code>）指引类型(guided type)。</li>
<li>没有前导<code>auto</code>关键字来指示尾缀返回类型。</li>
<li>推导指引的“名称”必须是同作用域内更早出现的类模板的非受限名称。</li>
<li>指引的指引类型必须是一个模板ID，它的模板名称与指引名称一致。</li>
<li>可以使用<code>explicit</code>说明符声明。</li>
</ul>
<p>在<code>S x(12);</code>这一声明中，说明符<code>S</code>被称为占位类类型(placeholder class type)。当使用这样的占位符时，被声明的变量名称必须紧随其后，并且后面一定要有初始化器。下面的代码是非法的：</p>
<p><code>S *p = &amp;x; // ERROR: syntax not permitted</code></p>
<p>如上例所书写的指引，声明<code>S x(12);</code>通过将与类<code>S</code>的推导指引视为重载集合，并尝试使用初始化器针对该重载集合来进行重载解析，对变量的类型进行推导。在这一场景中，集合内仅仅有一个指引在其中，它会成功地推导<code>T</code>为<code>int</code>，指引的指引类型为<code>S&lt;int&gt;</code>。这一指引类型因此被选为声明的类型。</p>
<p>请注意，如果类模板名称后面的多个声明都需要推导，那么每个声明都需要产生相同的类型。例如，使用上面的声明：</p>
<p><code>S s1(1), S2(2.0);    // ERROR: deduces S both as S&lt;int&gt; and S&lt;double&gt;</code></p>
<p>这与C++11中<code>auto</code>占位符类型的限制相似。</p>
<p>在前面的例子中，我们声明的推导指引与类<code>S</code>中声明的构造函数<code>S(T b)</code>之间有一个隐式的联系。然而，这种联系并不是必要的，这意味着推导指引也可以为聚合类模板所使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>  T val;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-title">A</span><span class="hljs-params">(T)</span> -&gt; A&lt;T&gt;</span>;    <span class="hljs-comment">// deduction guide</span><br></code></pre></td></tr></table></figure>

<p>如果没有推导指引，我们必须始终显式地指定模板实参（即使在C++17中也一样）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A&lt;<span class="hljs-type">int</span>&gt; a1&#123;<span class="hljs-number">42</span>&#125;;        <span class="hljs-comment">// OK</span><br><span class="hljs-function">A&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a2</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;        <span class="hljs-comment">// ERROR: not aggregate initialization</span><br>A&lt;<span class="hljs-type">int</span>&gt; a3 = &#123;<span class="hljs-number">42</span>&#125;;    <span class="hljs-comment">// OK</span><br>A a4 = <span class="hljs-number">42</span>;            <span class="hljs-comment">// ERROR: can&#x27;t deduce type</span><br></code></pre></td></tr></table></figure>

<p>但是如果有了上面的指引，就可以写成：</p>
<p><code>A a4 = &#123;42&#125;; // OK</code></p>
<p>这里有一个微妙之处在于，初始化器必须也是一个合法的聚合类初始化器，也就是说，它必须是一个花括号初始化列表。下面的一些替换是不被允许的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">A <span class="hljs-title">a5</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;        <span class="hljs-comment">// ERROR: not aggregate initialization</span><br>A a6 = <span class="hljs-number">42</span>;        <span class="hljs-comment">// ERROR: not aggregate initialization</span><br></code></pre></td></tr></table></figure>

<h3 id="15-12-2-隐式推导指引"><a href="#15-12-2-隐式推导指引" class="headerlink" title="15.12.2 隐式推导指引"></a>15.12.2 隐式推导指引</h3><p>通常，对于类模板中的每个构造函数都需要一个推导指引。这使得类模板实参推导的设计者为推导引入了一种隐式地机制。为类主模板的每个构造函数和构造函数模板都引入了一个等价的隐式推导指引，如下所述：</p>
<ul>
<li>隐式指引的模板参数列表由类模板的模板参数、构造函数模板的模板参数（构造函数模板的场合）构成。构造函数模板的模板参数会保留任何默认实参。</li>
<li>指引的“类函数”参数会从构造函数或构造函数模板中拷贝。</li>
<li>指引的指引类型就是模板的名称，其参数是从类模板中获取的模板参数。</li>
</ul>
<p>让我们应用到一个原始的类模板示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    T a;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">S</span>(T b) : <span class="hljs-built_in">a</span>(b) &#123;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>模板参数列表为<code>typename T</code>，类函数参数列表就是<code>(T b)</code>，指引类型也就是<code>S&lt;T&gt;</code>。因此，我们获得了一个指引，它与我们此前书写的那个用户声明的指引等价：即，为了达成我们想要的效果，该指引完全不必要！也就是说，仅书写原始的简单类模板（无需推导指引），我们还是可以有效地写成<code>S x(12);</code>，其中<code>x</code>的类型依然是期望的<code>S&lt;int&gt;</code>。</p>
<p>推导指引有一个不幸的歧义。考虑一下我们简单的类模板<code>S</code>和下面的实例化语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S x&#123;<span class="hljs-number">12</span>&#125;;    <span class="hljs-comment">// x has type S&lt;int&gt;</span><br>S y&#123;s1&#125;; <span class="hljs-function">S <span class="hljs-title">z</span><span class="hljs-params">(s1)</span></span>;<br></code></pre></td></tr></table></figure>

<p>我们已经看到了<code>x</code>有着类型<code>S&lt;int&gt;</code>，但是<code>x</code>和<code>y</code>应该是什么类型呢？这两种类型直觉上应该是<code>S&lt;S&lt;int&gt;&gt;</code>和<code>S&lt;int&gt;</code>。委员会在富有争议的情况下决定，这两种情况下都应为<code>S&lt;int&gt;</code>。为什么这是有争议的呢？考虑使用<code>vector</code>类型的一个相似的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector v&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;        <span class="hljs-comment">// vector&lt;int&gt;, not surprising</span><br>std::vector w2&#123;v, v&#125;;        <span class="hljs-comment">// vector&lt;vector&lt;int&gt;&gt;</span><br>std::vector w1&#123;v&#125;;            <span class="hljs-comment">// vector&lt;int&gt;!</span><br></code></pre></td></tr></table></figure>

<p>换句话说，拥有单个元素的花括号初始化器的推导与拥有多个元素的花括号初始化器有所差别。通常来说，人们只希望要其中的某一个结果，但是两者确并不一致。然而在泛型代码中，很容易忽视这一细小的差别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">(T p, Ts... ps)</span> </span>&#123;<br>  std::vector v&#123;p, ps...&#125;;        <span class="hljs-comment">// type depends on pack length</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里当<code>T</code>被推导为<code>vector</code>类型时，<code>v</code>在<code>ps</code>参数包为空或非空的情景下，<code>v</code>的类型是不一样的。</p>
<p>隐式模板指引本身的添加并没有争议。反对将它们引入的主要观点是该功能会自动将接口添加到现有库中。为了理解这一说法，再次考虑我们前面的类模板<code>S</code>。它的定义自C++引入类模板时就是有效的。假设，<code>S</code>的作者扩展了库，让<code>S</code>以更缜密的方式定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ValueArg</span> &#123;<br>  <span class="hljs-keyword">using</span> Type = T;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    T a;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ArgType = <span class="hljs-keyword">typename</span> ValueArg&lt;T&gt;::Type;<br>    <span class="hljs-built_in">S</span>(ArgType b) : <span class="hljs-built_in">a</span>(b) &#123;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在C++17之前，这样的转变（不太常见）不会影响现有的代码。然而，在C++17中它们禁用了隐式推导指引。让我们书写一个与隐式推导指引相仿的推导指引：模板参数列表和指引类型无需改变，但是类函数参数现在需要写成<code>ArgType</code>的形式，也就是<code>typename ValueArg&lt;T&gt;::Type</code>:</p>
<p><code>template&lt;typename&gt; S(typename ValueArg&lt;T&gt;::Type) -&gt; S&lt;T&gt;;</code></p>
<p>回想一下P271节15.2，类似<code>ValueArg&lt;T&gt;::</code>的名称限定符不是一个推导上下文。因此这种形式的推导指引是没有用的，它无法解析<code>S x(12);</code>这样的声明。换句话说，库的作者执行了这一转换可能会破坏其在C++17中的客户端代码。</p>
<p>这种情况下库的作者要怎么办呢？我们的建议就是小心地考虑每一个构造函数，在库剩余的生命期内是否希望它作为隐式推导指引的来源。如果不希望，就用诸如<code>typename ValueArg&lt;X&gt;::Type</code>来替换每一个可推导的类型为<code>X</code>的构造函数参数的实例。很不幸，没有更简单的方法去把隐式推导指引摘除。</p>
<h3 id="15-12-3-其他细微之处"><a href="#15-12-3-其他细微之处" class="headerlink" title="15.12.3 其他细微之处"></a>15.12.3 其他细微之处</h3><h4 id="注入式类名称"><a href="#注入式类名称" class="headerlink" title="注入式类名称"></a>注入式类名称</h4><p>考虑下例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter&gt; <span class="hljs-title">X</span><span class="hljs-params">(Iter b, Iter e)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter&gt; <span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">(Iter b, Iter e)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">X</span>(b, e);        <span class="hljs-comment">// What is this?</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这段代码在C++14中是合法的：<code>X(b, e)</code>中的<code>X</code>是注入式类名称，在该上下文中等价于<code>X&lt;T&gt;</code>（参考P221节13.2.3）。然而，对类模板实参推导这一规则来说，<code>X</code>会自然而然地等价于<code>X&lt;Iter&gt;</code>。</p>
<p>为了保留向后兼容性，类模板实参推导在模板名称是注入式类名称的场合下会被禁用。</p>
<h4 id="转发引用"><a href="#转发引用" class="headerlink" title="转发引用"></a>转发引用</h4><p>思考另一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Y</span> &#123;<br>  <span class="hljs-built_in">Y</span>(T <span class="hljs-type">const</span>&amp;);<br>  <span class="hljs-built_in">Y</span>(T&amp;&amp;);<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>  Y y = s;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>显然，这里的目的是通过拷贝构造函数所关联的隐式推导指引架构<code>T</code>推导为<code>std::string</code>。然而，将隐式推导指引显式地声明出来反而发生令人惊讶的事：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-title">Y</span><span class="hljs-params">(T <span class="hljs-type">const</span>&amp;)</span> -&gt; Y&lt;T&gt;</span>;    <span class="hljs-comment">// #1</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-title">Y</span><span class="hljs-params">(T&amp;&amp;)</span> -&gt; Y&lt;T&gt;</span>;        <span class="hljs-comment">// #2</span><br></code></pre></td></tr></table></figure>

<p>回想P277节15.6中模板实参推导的<code>T&amp;&amp;</code>的行为：作为一个转发引用，如果调用实参是一个左值类型，那么<code>T</code>也会被推导成引用类型。在上例中，推导过程中的实参就是表达式<code>s</code>，它是一个左值。隐式指引#1会把<code>T</code>推导为<code>std::string</code>，但是需要的实参会被调整成<code>std::string const</code>。而指引#2则会将<code>T</code>推导成一个引用类型<code>std::string&amp;</code>并产生一个相同类型的参数（这是因为引用折叠法则），这是一个更好的匹配候选，因为无需对类型添油加醋，附上一个<code>const</code>属性。</p>
<p>这一结果可能会令人惊讶，也可能会造成实例化错误（当类模板参数在不允许引用类型的上下文中使用时），更有甚者，会静默地生成非预期的实例（比如，生成悬垂引用）。</p>
<p>C++标准委员会因此决定，对于隐式推导指引，如果<code>T</code>是一个类模板参数（与构造函数模板参数对应；为那些特殊的推导规则而保留），在执行<code>T&amp;&amp;</code>的推导时，特殊的推导规则会被禁用。因此上面的例子可以将<code>T</code>推导为<code>std::string</code>，如你所愿。</p>
<h4 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h4><p>推导指引可以使用关键字<code>explicit</code>修饰。此时它仅仅会考虑直接的初始化场景，而不会考虑拷贝初始化场景。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z</span> &#123;<br>  <span class="hljs-built_in">Z</span>(T <span class="hljs-type">const</span>&amp;);<br>  <span class="hljs-built_in">Z</span>(T&amp;&amp;);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-title">Z</span><span class="hljs-params">(T <span class="hljs-type">const</span>&amp;)</span> -&gt; Z&lt;T, T&amp;&gt;</span>;        <span class="hljs-comment">// #1</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">explicit</span> <span class="hljs-title">Z</span><span class="hljs-params">(T&amp;&amp;)</span> -&gt; Z&lt;T, T&gt;</span>;    <span class="hljs-comment">// #2</span><br><br>Z z1 = <span class="hljs-number">1</span>;    <span class="hljs-comment">// only considers #1; same as: Z&lt;int, int&amp;&gt; z1 = 1;</span><br>Z z2&#123;<span class="hljs-number">2</span>&#125;;    <span class="hljs-comment">// prefers #2; same as: Z&lt;int, int&gt; z2&#123;2&#125;;</span><br></code></pre></td></tr></table></figure>

<p>注意这里的<code>z1</code>初始化使用了拷贝初始化，因此声明了<code>explicit</code>的推导指引#2就不会被考虑。</p>
<h4 id="拷贝构造和初始化列表"><a href="#拷贝构造和初始化列表" class="headerlink" title="拷贝构造和初始化列表"></a>拷贝构造和初始化列表</h4><p>考虑下面的类模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Ts&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tuple</span> &#123;<br>  <span class="hljs-built_in">Tuple</span>(Ts...);<br>  <span class="hljs-built_in">Tuple</span>(Tuple&lt;Ts...&gt; <span class="hljs-type">const</span>&amp;);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>为了理解隐式指引的效果，我们用显式地声明它们：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt; <span class="hljs-title">Tuple</span><span class="hljs-params">(Ts...)</span> -&gt; Tuple&lt;Ts...&gt;</span>;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt; <span class="hljs-title">Tuple</span><span class="hljs-params">(Tuple&lt;Ts...&gt; <span class="hljs-type">const</span>&amp;)</span> -&gt; Tuple&lt;Ts...&gt;</span>;<br></code></pre></td></tr></table></figure>

<p>现在看看下面的例子：</p>
<p><code>auto x = Tuple&#123;1,2&#125;;</code></p>
<p>这显然会选择第一个指引，因此第一个构造函数：<code>x</code>就是一个<code>Tuple&lt;int, int&gt;</code>。让我们继续看看下面的例子，它们使用了<code>x</code>拷贝的语法：</p>
<p><code>Tuple a = x;</code><br><code>Tuple b(x);</code></p>
<p>对<code>a</code>和<code>b</code>来说，两个指引都可以匹配。第一个指引会选择类型<code>Tuple&lt;Tuple&lt;int, int&gt;&gt;</code>，拷贝构造器关联的指引会生成<code>Tuple&lt;int, int&gt;</code>。幸运的是，第二个指引更加匹配，因此<code>a</code>和<code>b</code>都会从<code>x</code>拷贝构造出来。</p>
<p>现在。考虑使用花括号列表的例子：</p>
<p><code>Tuple c&#123;x, x&#125;;</code><br><code>Tuple d&#123;x&#125;;</code></p>
<p>例子中的第一个<code>x</code>仅仅可以匹配第一个指引，因此会产生<code>Tuple&lt;Tuple&lt;int,int&gt;, Tuple&lt;int, int&gt;&gt;</code>。这完全符合直觉，不足为奇。第二个示例则会将<code>d</code>推导为类型<code>Tuple&lt;Tuple&lt;int&gt;&gt;</code>。然而，它被视为一个拷贝构造（即，更倾向于第二个隐式指引）。这也会发生在functional-notation转换的场景：<br><code>auto e = Tuple&#123;x&#125;;</code></p>
<p>这里，<code>e</code>被推导为一个<code>Tuple&lt;int, int&gt;</code>，而非<code>Tuple&lt;Tuple&lt;int&gt;&gt;</code>。</p>
<h4 id="指引仅为推导所用"><a href="#指引仅为推导所用" class="headerlink" title="指引仅为推导所用"></a>指引仅为推导所用</h4><p>推导指引并非函数模板：它们仅仅用来推导模板参数，并不会被“调用”。这意味着不论是通过引用还是通过值来传递实参对指引声明并不重要。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Y</span> &#123;<br>  <span class="hljs-built_in">Y</span>(X&lt;T&gt; <span class="hljs-type">const</span>&amp;);<br>  <span class="hljs-built_in">Y</span>(X&lt;T&gt;&amp;&amp;);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-title">Y</span><span class="hljs-params">(X&lt;T&gt;)</span> -&gt; Y&lt;T&gt;</span><br></code></pre></td></tr></table></figure>

<p>注意看推导指引并没有完全与<code>Y</code>的两个构造函数保持一致。然而，这并没有什么关系，因为指引仅仅为推导所用。给定类型为<code>X&lt;TT&gt;</code>的<code>xtt</code>左值或是右值，它都会选择推导类型<code>Y&lt;TT&gt;</code>。然后，初始化会在<code>Y&lt;TT&gt;</code>的构造器上执行重载解析以判断需要调用哪一个（这取决于<code>xtt</code>是左值还是右值）。</p>
<h2 id="15-13-后记"><a href="#15-13-后记" class="headerlink" title="15.13 后记"></a>15.13 后记</h2><p>函数模板的模板实参推导本就是C++原始设计的一部分。实际上，显式模板实参的使用在很多年之后才成了C++的一部分。</p>
<p>SFINAE是一个术语，它在本书的第一版就介绍过了。这一术语很快就在C++开发者委员会中盛行。然而，在C++98中，SFINAE并没有那么强大：它仅仅适用于一个有限的类型操作符集合，并且没有覆盖任意表达式或访问控制。由于越来越多的技术开始依赖于SFINAE（参考P416节19.4），推广SFINAE显而易见。Steve Adamczyk和John Spicer开发了在C++11中实现的措辞（见论文N2634）。尽管标准中的措词更改相对较小，但事实证明某些编译器的实现工作量不成比例。</p>
<p><code>auto</code>类型指示符以及<code>decltype</code>语法最早在C++03中新增，但最终是C++11才正式引入。它们率先由Bjarne Stroustrup和Jaakko Jarvi发明（详见他们的论文N1607和N2343，里面分别有<code>auto</code>类型指示符和<code>decltype</code>）。</p>
<p>Stroustrup在他的原始C++实现（Cfront）中就已经考虑过<code>auto</code>语法。这一特性在C++11中引入，<code>auto</code>作为一个存储指示符的原始意义（从C语言继承）被保留下来，所以需要一个没有歧义的规则来决定该关键字应该如何解析。在Edison Design Group的前端实现这一特性的过程中，David Vandevoorde发现对于C++11开发者来说这可能会产生很多意外（N2337）。在审查了这一议题后，标准委员会决定抛弃<code>auto</code>的传统使用方法（在C++03程序中使用<code>auto</code>关键字的任何地方，都可以忽略它），见论文N2546（David Vandevoorde和Jens Maurer撰写）。这是在不首先弃用该功能的情况下从该语言中删除该功能的不寻常先例，但此后事实证明这是英明的决定。</p>
<p>GNU的GCC编译器接受一个扩展的<code>typeof</code>语法，它与<code>decltype</code>特性并没有什么差异，开发者曾一度发现它在模板编程中非常有用。不幸的是，这是在C语言的上下文中开发的功能，并不完全适合C ++。因此，C ++委员会无法按原样合并它，但也不能对其进行修改，因为这将破坏依赖GCC行为的现有代码。这就是为什么<code>decltype</code>没有被拼写成<code>typeof</code>的缘由。Jason Merrill和其他人提出了有力的论据，认为最好有不同的运算符，而不是（依赖于）目前的<code>decltype(x)</code>和<code>decltype((x))</code>之间的细微差别，但他们并没有说服力来更改最终规范。</p>
<p>在C++17中使用<code>auto</code>声明非类型模板参数的能力主要由Mike Spertus发明，齐心协力的还有James Touton, David Vandevoorde和其他人。这一特性的规格更改记录在P0127R2中。有趣的是，尚不清楚是否有意使用<code>decltype(auto)</code>代替<code>auto</code>成为该语言的一部分（显然，委员会未对此进行讨论，但超出了规范）。</p>
<p>Mike Spertus也驱动了C++17中类模板实参推导的开发，Richard Smith和Faisal Vali 贡献了显著的技术理念（包括推导指引）。论文P0091R3中具有被选为下一个语言标准的工作文件的规格说明。</p>
<p>结构化绑定主要由Herb Sutter所驱动，他与Gabriel Dos Reis和Bjarne Stroustrup撰写了论文P0144R1以提出这一特性。在委员会讨论期间进行了许多调整，包括使用方括号来分隔可分解的标识符。 Jens Maurer将提案翻译成标准的最终规范（P0217R3）。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://example.com/2025/05/31/cpp-template-ch/cpp-template-ch15/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>QiDianMaker</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月30日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2025年5月30日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"6xahBDKE9bVdQzuufG4r0SrN-gzGzoHsz","appKey":"aS53wAMJ32RwAJRsefQAsX9P","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div>
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
